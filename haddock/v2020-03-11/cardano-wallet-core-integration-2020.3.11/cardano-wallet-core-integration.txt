-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core integration test library.
--   
--   Shared core functionality for our integration test suites.
@package cardano-wallet-core-integration
@version 2020.3.11

module Cardano.Wallet.TransactionSpecShared
propMaxNumberOfInputsEstimation :: TransactionLayer t key -> Quantity "byte" Word16 -> Quantity "byte" Word16 -> Word8 -> Word8 -> Property
instance Test.QuickCheck.Arbitrary.Arbitrary (Data.Quantity.Quantity "byte" GHC.Word.Word16)

module Test.Integration.Faucet

-- | An opaque <a>Faucet</a> type from which one can get a wallet with
--   funds
data Faucet
Faucet :: MVar [Mnemonic 15] -> MVar [Mnemonic 15] -> MVar [Mnemonic 12] -> MVar [(Address, Coin) -> IO ByteString] -> Faucet
[shelley] :: Faucet -> MVar [Mnemonic 15]
[icarus] :: Faucet -> MVar [Mnemonic 15]
[random] :: Faucet -> MVar [Mnemonic 12]
[txBuilder] :: Faucet -> MVar [(Address, Coin) -> IO ByteString]
nextWallet :: NextWallet scheme => Faucet -> IO (Mnemonic (MnemonicSize scheme))

-- | Get a raw transaction builder. It constructs and sign a transaction
--   via an private key that is owned "externally". Returns a bytes string
--   ready to be sent to a node.
nextTxBuilder :: Faucet -> IO ((Address, Coin) -> IO ByteString)
seqMnemonics :: [Mnemonic 15]
icaMnemonics :: [Mnemonic 15]
rndMnemonics :: [Mnemonic 12]
instance Test.Integration.Faucet.NextWallet "shelley"
instance Test.Integration.Faucet.NextWallet "icarus"
instance Test.Integration.Faucet.NextWallet "random"

module Test.Integration.Framework.Request

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadCatch m, HasType (Text, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m t. (FromJSON a, MonadIO m, MonadCatch m) => Context t -> (Method, Text) -> Payload -> m (Status, a)

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException

-- | Running Context for our integration test
data Context t
Context :: IO () -> (Text, Manager) -> Port "wallet" -> Faucet -> (TxDescription -> (Natural, Natural)) -> BlockchainParameters -> Proxy t -> Context t

-- | Cleanup action for the context
[_cleanup] :: Context t -> IO ()

-- | The underlying BaseUrl and Manager used by the Wallet Client
[_manager] :: Context t -> (Text, Manager)

-- | Server TCP port
[_walletPort] :: Context t -> Port "wallet"

-- | A <a>Faucet</a> handle in to have access to funded wallets in
--   integration tests.
[_faucet] :: Context t -> Faucet

-- | A fee estimator for the integration tests
[_feeEstimator] :: Context t -> TxDescription -> (Natural, Natural)

-- | Blockchain parameters for the underlying chain
[_blockchainParameters] :: Context t -> BlockchainParameters
[_target] :: Context t -> Proxy t

-- | Describe a transaction in terms of its inputs and outputs
data TxDescription
DelegDescription :: Int -> Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
[nCertificates] :: TxDescription -> Int
PaymentDescription :: Int -> Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
[nChanges] :: TxDescription -> Int
instance GHC.Show.Show Test.Integration.Framework.Request.Headers
instance GHC.Show.Show Test.Integration.Framework.Request.Payload
instance GHC.Show.Show Test.Integration.Framework.Request.RequestException
instance GHC.Generics.Generic (Test.Integration.Framework.Request.Context t)
instance GHC.Show.Show Test.Integration.Framework.Request.TxDescription
instance GHC.Exception.Type.Exception Test.Integration.Framework.Request.RequestException

module Test.Integration.Framework.DSL

-- | Running Context for our integration test
data Context t
Context :: IO () -> (Text, Manager) -> Port "wallet" -> Faucet -> (TxDescription -> (Natural, Natural)) -> BlockchainParameters -> Proxy t -> Context t

-- | Cleanup action for the context
[_cleanup] :: Context t -> IO ()

-- | The underlying BaseUrl and Manager used by the Wallet Client
[_manager] :: Context t -> (Text, Manager)

-- | Server TCP port
[_walletPort] :: Context t -> Port "wallet"

-- | A <a>Faucet</a> handle in to have access to funded wallets in
--   integration tests.
[_faucet] :: Context t -> Faucet

-- | A fee estimator for the integration tests
[_feeEstimator] :: Context t -> TxDescription -> (Natural, Natural)

-- | Blockchain parameters for the underlying chain
[_blockchainParameters] :: Context t -> BlockchainParameters
[_target] :: Context t -> Proxy t

-- | A class to select the right command for a given 'Context t'
class KnownCommand t
commandName :: KnownCommand t => String

-- | Describe a transaction in terms of its inputs and outputs
data TxDescription
DelegDescription :: Int -> Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
[nCertificates] :: TxDescription -> Int
PaymentDescription :: Int -> Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
[nChanges] :: TxDescription -> Int

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadCatch m, HasType (Text, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m t. (FromJSON a, MonadIO m, MonadCatch m) => Context t -> (Method, Text) -> Payload -> m (Status, a)

-- | A file is eventually created on the given location
expectPathEventuallyExist :: HasCallStack => FilePath -> IO ()

-- | Expect a successful response, without any further assumptions.
expectSuccess :: (HasCallStack, MonadIO m, MonadFail m) => (s, Either RequestException a) -> m ()

-- | Expect an error response, without any further assumptions.
expectError :: (HasCallStack, MonadIO m, MonadFail m, Show a) => (s, Either RequestException a) -> m ()

-- | Expect an error response, without any further assumptions.
expectErrorMessage :: (HasCallStack, MonadIO m, MonadFail m, Show a) => String -> (s, Either RequestException a) -> m ()
expectField :: (HasCallStack, MonadIO m, MonadFail m, Show a) => Lens' s a -> (a -> Expectation) -> (Status, Either RequestException s) -> m ()
expectListField :: (HasCallStack, MonadIO m, MonadFail m, Show a) => Int -> Lens' s a -> (a -> Expectation) -> (Status, Either RequestException [s]) -> m ()

-- | Expects data list returned by the API to be of certain length
expectListSize :: (HasCallStack, MonadIO m, MonadFail m, Foldable xs) => Int -> (Status, Either RequestException (xs a)) -> m ()

-- | Expect a given response code on the response.
expectResponseCode :: (HasCallStack, MonadIO m, Show a) => Status -> (Status, a) -> m ()

-- | Expects a given string to be a valid JSON output corresponding to some
--   given data-type <tt>a</tt>. Returns this type if successful.
expectValidJSON :: forall m a. (HasCallStack, MonadFail m, FromJSON a) => Proxy a -> String -> m a
expectCliField :: (HasCallStack, MonadIO m, MonadFail m, Show a) => Lens' s a -> (a -> Expectation) -> s -> m ()
expectCliListField :: (HasCallStack, MonadIO m, MonadFail m, Show a) => Int -> Lens' s a -> (a -> Expectation) -> [s] -> m ()

-- | Expects wallet UTxO statistics from the request to be equal to
--   pre-calculated statistics.
expectWalletUTxO :: (HasCallStack, MonadIO m, MonadFail m) => [Word64] -> Either RequestException ApiUtxoStatistics -> m ()
between :: (Ord a, Show a) => (a, a) -> a -> Expectation
(.>=) :: (Ord a, Show a) => a -> a -> Expectation
(.>) :: (Ord a, Show a) => a -> a -> Expectation

-- | Apply <tt>a</tt> to all actions in sequence
verify :: Monad m => a -> [a -> m ()] -> m ()

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException
walletId :: HasType (ApiT WalletId) s => Lens' s Text
(</>) :: ToHttpApiData a => Text -> a -> Text
infixr 5 </>

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: () => [a] -> Int -> a
infixl 9 !!

-- | Create an empty wallet
emptyRandomWallet :: Context t -> IO ApiByronWallet
emptyIcarusWallet :: Context t -> IO ApiByronWallet
emptyByronWalletWith :: forall t. () => Context t -> String -> (Text, [Text], Text) -> IO ApiByronWallet

-- | Create an empty wallet
emptyWallet :: Context t -> IO ApiWallet

-- | Create an empty wallet
emptyWalletWith :: Context t -> (Text, Text, Int) -> IO ApiWallet
getFromResponse :: Lens' s a -> (Status, Either RequestException s) -> a
getFromResponseList :: Int -> Lens' s a -> (Status, Either RequestException [s]) -> a
json :: QuasiQuoter
joinStakePool :: forall t w. HasType (ApiT WalletId) w => Context t -> ApiT PoolId -> (w, Text) -> IO (Status, Either RequestException (ApiTransaction  'Testnet))
delegationFee :: forall t w. HasType (ApiT WalletId) w => Context t -> w -> IO (Status, Either RequestException ApiFee)
quitStakePool :: forall t w. HasType (ApiT WalletId) w => Context t -> (w, Text) -> IO (Status, Either RequestException (ApiTransaction  'Testnet))
selectCoins :: forall t w. HasType (ApiT WalletId) w => Context t -> w -> NonEmpty (AddressAmount  'Testnet) -> IO (Status, Either RequestException (ApiCoinSelection  'Testnet))
listAddresses :: Context t -> ApiWallet -> IO [ApiAddress  'Testnet]
listTransactions :: Context t -> ApiWallet -> Maybe UTCTime -> Maybe UTCTime -> Maybe SortOrder -> IO [ApiTransaction  'Testnet]
listAllTransactions :: Context t -> ApiWallet -> IO [ApiTransaction  'Testnet]

-- | teardown after each test (currently only deleting all wallets)
tearDown :: Context t -> IO ()
fixtureRawTx :: Context t -> (Address, Natural) -> IO ByteString
fixtureRandomWallet :: Context t -> IO ApiByronWallet

-- | Restore a faucet Random wallet and wait until funds are available.
fixtureRandomWalletMws :: Context t -> IO (ApiByronWallet, Mnemonic 12)
fixtureRandomWalletAddrs :: forall (n :: NetworkDiscriminant) t. PaymentAddress n ByronKey => Context t -> IO (ApiByronWallet, [Address])

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
--   
--   TODO: Remove duplication between Shelley / Byron fixtures.
fixtureRandomWalletWith :: forall (n :: NetworkDiscriminant) t. (EncodeAddress n, DecodeAddress n, PaymentAddress n ByronKey) => Context t -> [Natural] -> IO ApiByronWallet
fixtureIcarusWallet :: Context t -> IO ApiByronWallet

-- | Restore a faucet Icarus wallet and wait until funds are available.
fixtureIcarusWalletMws :: Context t -> IO (ApiByronWallet, Mnemonic 15)
fixtureIcarusWalletAddrs :: forall (n :: NetworkDiscriminant) t. PaymentAddress n IcarusKey => Context t -> IO (ApiByronWallet, [Address])

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
--   
--   TODO: Remove duplication between Shelley / Byron fixtures.
fixtureIcarusWalletWith :: forall (n :: NetworkDiscriminant) t. (EncodeAddress n, DecodeAddress n, PaymentAddress n IcarusKey) => Context t -> [Natural] -> IO ApiByronWallet

-- | Restore a faucet and wait until funds are available.
fixtureWallet :: Context t -> IO ApiWallet

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
fixtureWalletWith :: Context t -> [Natural] -> IO ApiWallet
fixtureWalletWithMnemonics :: Context t -> IO (ApiWallet, [Text])

-- | Total amount on each faucet wallet
faucetAmt :: Natural

-- | Each faucet wallet is composed of 10 times a single faucet UTxO of
--   100_000 Ada.
faucetUtxoAmt :: Natural
proc' :: FilePath -> [String] -> CreateProcess

-- | Wait for a booting wallet server to start. Wait up to 30s or fail.
waitForServer :: forall t ctx. (HasType (Port "wallet") ctx, KnownCommand t) => ctx -> IO ()

-- | <a>map</a> flipped.
for :: [a] -> (a -> b) -> [b]
utcIso8601ToText :: UTCTime -> Text
eventually :: String -> IO a -> IO a
eventuallyUsingDelay :: Int -> String -> IO a -> IO a

-- | Default passphrase used for fixture wallets
fixturePassphrase :: Text
waitForNextEpoch :: Context t -> IO ()
waitAllTxsInLedger :: forall t n. n ~  'Testnet => Context t -> ApiWallet -> IO ()
toQueryString :: [(Text, Text)] -> Text

-- | Override the method of a particular endpoint, mostly to exercise
--   invalid endpoints from existing ones.
withMethod :: Method -> (Method, Text) -> (Method, Text)

-- | Modifies the value of a path parameter at position <tt>n</tt> (indexed
--   from 0) with the given update function. Throws if the given endpoint
--   has no path parameter in the given position.
--   
--   <pre>
--   &gt;&gt;&gt; Link.getWallet @Shelley myWallet
--   ( "GET", "v2/wallets/2512a00e9653fe49a44a5886202e24d77eeb998f" )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withPathParam 0 (&lt;&gt; "suffix") $ Link.getWallet @Shelley myWallet
--   ( "GET", "v2/wallets/2512a00e9653fe49a44a5886202e24d77eeb998fsuffix" )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withPathParam 1 (const "suffix") $ Link.joinStakePool @Shelley myPool myWallet
--   ( "GET", "v2/stake-pools/2512a00e9653fe49a44a5886202e24d77eeb998f/wallets/patate" )
--   </pre>
withPathParam :: Int -> (Text -> Text) -> (Method, Text) -> (Method, Text)

-- | Generate an infinite list of addresses for icarus wallets
--   
--   To be typically used as:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (icarusAddresses @n)
--   [addr]
--   </pre>
icarusAddresses :: forall (n :: NetworkDiscriminant). PaymentAddress n IcarusKey => Mnemonic 15 -> [Address]

-- | Generate an infinite list of addresses for random wallets.
--   
--   To be typically used as:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (randomAddresses @n)
--   [addr]
--   </pre>
randomAddresses :: forall (n :: NetworkDiscriminant). PaymentAddress n ByronKey => Mnemonic 12 -> [Address]

-- | Handy constructor for ApiEpochInfo
mkEpochInfo :: EpochNo -> SlotParameters -> ApiEpochInfo

-- | Wallet not delegating and not about to join any stake pool.
notDelegating :: [(Maybe (ApiT PoolId), ApiEpochInfo)] -> ApiWalletDelegation
delegating :: ApiT PoolId -> [(Maybe (ApiT PoolId), ApiEpochInfo)] -> ApiWalletDelegation
getSlotParams :: Context t -> IO (EpochNo, SlotParameters)
command :: CmdResult r => [CmdOption] -> String -> [String] -> IO r

-- | Run a command using the 'cardano-wallet' executable for the target
--   <tt>t</tt>.
cardanoWalletCLI :: forall t r. (CmdResult r, KnownCommand t) => [String] -> IO r
generateMnemonicsViaCLI :: forall t r. (CmdResult r, KnownCommand t) => [String] -> IO r
createWalletViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> String -> String -> String -> IO (ExitCode, String, Text)
deleteWalletViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
getWalletUtxoStatisticsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
getWalletViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
listAddressesViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> [String] -> IO r
listStakePoolsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> IO r
listWalletsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> IO r
updateWalletNameViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> [String] -> IO r
updateWalletPassphraseViaCLI :: forall t s. (KnownCommand t, HasType (Port "wallet") s) => s -> String -> String -> String -> String -> IO (ExitCode, Text, Text)
postTransactionViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> String -> [String] -> IO (ExitCode, String, Text)
postTransactionFeeViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO (ExitCode, String, Text)
listTransactionsViaCLI :: forall t r s. (CmdResult r, HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO r
postExternalTransactionViaCLI :: forall t r s. (CmdResult r, HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO r
deleteTransactionViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> String -> IO r

module Test.Integration.Framework.TestData
chineseMnemonics9 :: [Text]
chineseMnemonics18 :: [Text]
frenchMnemonics12 :: [Text]
frenchMnemonics21 :: [Text]
invalidMnemonics12 :: [Text]
invalidMnemonics15 :: [Text]
japaneseMnemonics12 :: [Text]
japaneseMnemonics15 :: [Text]
mnemonics3 :: [Text]
mnemonics6 :: [Text]
mnemonics9 :: [Text]
mnemonics12 :: [Text]
mnemonics15 :: [Text]
notInDictMnemonics15 :: [Text]
mnemonics18 :: [Text]
mnemonics21 :: [Text]
mnemonics24 :: [Text]
specMnemonicByron :: [Text]
specMnemonicSentence :: [Text]
specMnemonicSecondFactor :: [Text]
arabicWalletName :: Text
falseWalletIds :: [(String, String)]
kanjiWalletName :: Text
polishWalletName :: Text
russianWalletName :: Text
wildcardsWalletName :: Text
cmdOk :: String
versionLine :: Text
payloadWith :: Text -> [Text] -> Payload
simplePayload :: Payload
updateNamePayload :: Text -> Payload
updatePassPayload :: Text -> Text -> Payload
errMsg400WalletIdEncoding :: String
errMsg400StartTimeLaterThanEndTime :: String -> String -> String
errMsg403Fee :: String
errMsg403DelegationFee :: Natural -> String
errMsg403NotEnoughMoney :: Int -> Int -> String
errMsg403NotEnoughMoney_ :: String
errMsg403UTxO :: String
errMsg403WrongPass :: String
errMsg403NoPendingAnymore :: Text -> String
errMsg404NoSuchPool :: Text -> String
errMsg403PoolAlreadyJoined :: Text -> String
errMsg403NotDelegating :: String
errMsg403NothingToMigrate :: Text -> String
errMsg404NoEndpoint :: String
errMsg404CannotFindTx :: Text -> String
errMsg403NoRootKey :: Text -> String
errMsg404NoWallet :: Text -> String
errMsg404NoEpochNo :: String -> String
errMsg403InputsDepleted :: String
errMsg403TxTooBig :: Int -> String
errMsg400MalformedTxPayload :: String
errMsg400WronglyEncodedTxPayload :: String
errMsg400ParseError :: String
errMsg403ZeroAmtOutput :: String
errMsg405 :: String
errMsg406 :: String
errMsg415 :: String
errMsg415OctetStream :: String
errMsg500 :: String
errMsg400NumberOfWords :: String
errMsgNotInDictionary :: String
errMsg403RejectedTip :: String

module Test.Integration.Scenario.API.Addresses
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.ByronTransactions
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.ByronWallets
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.HWWallets
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.Network
spec :: forall t. SpecWith (Context t)

module Test.Integration.Scenario.API.Transactions
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.Wallets
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Addresses
spec :: forall t n. (n ~  'Testnet, KnownCommand t) => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Miscellaneous
spec :: forall t. KnownCommand t => SpecWith ()

module Test.Integration.Scenario.CLI.Mnemonics
spec :: forall t. KnownCommand t => SpecWith ()

module Test.Integration.Scenario.CLI.Network
spec :: forall t. KnownCommand t => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Port
spec :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => SpecWith s

module Test.Integration.Scenario.CLI.Transactions
spec :: forall t n. (n ~  'Testnet, KnownCommand t) => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Wallets
spec :: forall t n. (n ~  'Testnet, KnownCommand t) => SpecWith (Context t)
