-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementation of the Bech32 segwit address format (BIP 0173).
--   
--   Implementation of the Bech32 segwit address format (BIP 0173).
@package bech32
@version 2020.1.21


-- | Implementation of the <a>Bech32</a> address format.
--   
--   From an original implementation by Marko Bencun:
--   
--   <a>sipa/bech32</a>
module Codec.Binary.Bech32.Internal

-- | Encode a human-readable string and data payload into a Bech32 string.
encode :: HumanReadablePart -> DataPart -> Either EncodingError Text

-- | Like <a>encode</a> but allows output to be longer than 90 characters.
--   This isn't ideal as the error detection becomes worse as string get
--   longer but it's still acceptable.
--   
--   From BIP-0173:
--   
--   Even though the chosen code performs reasonably well up to 1023
--   characters, other designs are preferable for lengths above 89
--   characters (excluding the separator).
encodeLenient :: HumanReadablePart -> DataPart -> Text

-- | Represents the set of error conditions that may occur while encoding a
--   Bech32 string.
data EncodingError
EncodedStringTooLong :: EncodingError

-- | Decode a Bech32 string into a human-readable part and data part.
decode :: Text -> Either DecodingError (HumanReadablePart, DataPart)

-- | Like <a>decode</a> but does not enforce a maximum length. See also
--   <a>encodeLenient</a> for details.
decodeLenient :: Text -> Either DecodingError (HumanReadablePart, DataPart)

-- | Represents the set of errors that may occur while decoding a Bech32
--   string with the <a>decode</a> function.
data DecodingError
StringToDecodeTooLong :: DecodingError
StringToDecodeTooShort :: DecodingError
StringToDecodeHasMixedCase :: DecodingError
StringToDecodeMissingSeparatorChar :: DecodingError

-- | In cases where it is possible to determine the exact locations of
--   erroneous characters, this list will encode those locations. Clients
--   can use this information to provide user feedback. In cases where it
--   isn't possible to reliably determine the locations of erroneous
--   characters, this list will be empty.
StringToDecodeContainsInvalidChars :: [CharPosition] -> DecodingError

-- | The length of the checksum portion of an encoded string, in bytes.
checksumLength :: Int

-- | The maximum length of an encoded string, in bytes. This length
--   includes the human-readable part, the separator character, the encoded
--   data portion, and the checksum.
encodedStringMaxLength :: Int

-- | The minimum length of an encoded string, in bytes. This length
--   includes the human-readable part, the separator character, the encoded
--   data portion, and the checksum.
encodedStringMinLength :: Int

-- | The separator character. This character appears immediately after the
--   human-readable part and before the data part.
separatorChar :: Char

-- | The length of the separator portion of an encoded string, in bytes.
separatorLength :: Int

-- | Represents the data part of a Bech32 string, as defined here:
--   <a>https://git.io/fj8FS</a>
data DataPart

-- | Returns true iff. the specified <a>DataPart</a> is valid.
dataPartIsValid :: DataPart -> Bool

-- | Constructs a <a>DataPart</a> from a <a>ByteString</a>.
--   
--   This function encodes a <a>ByteString</a> in such a way that
--   guarantees it can be successfully decoded with the
--   <a>dataPartToBytes</a> function:
--   
--   <pre>
--   dataPartToBytes (dataPartFromBytes b) == Just b
--   </pre>
dataPartFromBytes :: ByteString -> DataPart

-- | Constructs a <a>DataPart</a> from textual input. All characters in the
--   input must be a member of <a>dataCharList</a>, the set of characters
--   permitted to appear within the data part of a Bech32 string.
--   
--   Returns <a>Nothing</a> if any character in the input is not a member
--   of <a>dataCharList</a>.
--   
--   This function guarantees to satisfy the following property:
--   
--   <pre>
--   dataPartFromText (dataPartToText d) == Just d
--   </pre>
dataPartFromText :: Text -> Maybe DataPart

-- | Construct a <a>DataPart</a> directly from words.
--   
--   This function guarantees to satisfy the following properties:
--   
--   <pre>
--   dataPartFromWords (dataPartToWords d) == d
--   dataPartToWords (dataPartFromWords w) == w
--   </pre>
dataPartFromWords :: [Word5] -> DataPart

-- | Attempts to extract a <a>ByteString</a> from a <a>DataPart</a>.
--   
--   This function guarantees to satisfy the following property:
--   
--   <pre>
--   dataPartToBytes (dataPartFromBytes b) == Just b
--   </pre>
dataPartToBytes :: DataPart -> Maybe ByteString

-- | Converts a <a>DataPart</a> to <a>Text</a>, using the Bech32 character
--   set to render the data.
--   
--   This function guarantees to satisfy the following property:
--   
--   <pre>
--   dataPartFromText (dataPartToText d) == Just d
--   </pre>
dataPartToText :: DataPart -> Text

-- | Convert a <a>DataPart</a> into words.
dataPartToWords :: DataPart -> [Word5]

-- | If the specified character is permitted to appear within the data part
--   of a Bech32 string, this function returns that character's
--   corresponding <a>Word5</a> value. If the specified character is not
--   permitted, or if the specified character is upper-case, returns
--   <a>Nothing</a>.
dataCharToWord :: Char -> Maybe Word5

-- | Maps the specified <a>Word5</a> onto a character that is permitted to
--   appear within the data part of a Bech32 string.
dataCharFromWord :: Word5 -> Char

-- | A list of all characters that are permitted to appear within the data
--   part of a Bech32 string. See here for more details:
--   <a>https://git.io/fj8FS</a>
dataCharList :: String

-- | Represents the human-readable part of a Bech32 string, as defined
--   here: <a>https://git.io/fj8FS</a>
data HumanReadablePart

-- | Represents the set of error conditions that may occur while parsing
--   the human-readable part of a Bech32 string.
data HumanReadablePartError
HumanReadablePartTooShort :: HumanReadablePartError
HumanReadablePartTooLong :: HumanReadablePartError
HumanReadablePartContainsInvalidChars :: [CharPosition] -> HumanReadablePartError

-- | Parses the human-readable part of a Bech32 string, which obeys the
--   following definition:
--   
--   "The human-readable part, which is intended to convey the type of
--   data, or anything else that is relevant to the reader. This part MUST
--   contain 1 to 83 US-ASCII characters, with each character having a
--   value in the range [33-126]. HRP validity may be further restricted by
--   specific applications."
--   
--   Source:
--   <a>https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32</a>
humanReadablePartFromText :: Text -> Either HumanReadablePartError HumanReadablePart

-- | Like <a>humanReadablePartFromText</a>, but throws at runtime if given
--   an invalid <tt>hrp</tt> as text. It is recommended to only make use of
--   this function when using litterals. For example:
--   
--   <pre>
--   &gt;&gt;&gt; unsafeHumanReadablePartFromText "addr"
--   HumanReadablePart "addr"
--   </pre>
unsafeHumanReadablePartFromText :: HasCallStack => Text -> HumanReadablePart

-- | Get the raw text of the human-readable part of a Bech32 string.
humanReadablePartToText :: HumanReadablePart -> Text

-- | Convert the specified human-readable part to a list of words.
humanReadablePartToWords :: HumanReadablePart -> [Word5]

-- | The shortest length permitted for the human-readable part of a Bech32
--   string.
humanReadablePartMinLength :: Int

-- | The longest length permitted for the human-readable part of a Bech32
--   string.
humanReadablePartMaxLength :: Int

-- | The lower bound of the set of characters permitted to appear within
--   the human-readable part of a Bech32 string.
humanReadableCharMinBound :: Char

-- | The upper bound of the set of characters permitted to appear within
--   the human-readable part of a Bech32 string.
humanReadableCharMaxBound :: Char

-- | Big-endian conversion of a word string from base '2^frombits' to base
--   '2^tobits'. The <tt>frombits</tt> and <tt>twobits</tt> parameters must
--   be positive, while '2^frombits' and '2^tobits' must be smaller than
--   the size of <a>Word</a>. Every value in <tt>dat</tt> must be strictly
--   smaller than '2^frombits'.
convertBits :: Functor f => [Word] -> Int -> Int -> Pad f -> f [Word]
data Word5
word5 :: Integral a => a -> Word5
getWord5 :: Word5 -> Word8
toBase256 :: [Word5] -> Maybe [Word8]
toBase32 :: [Word8] -> [Word5]
noPadding :: Pad Maybe
yesPadding :: Pad Identity

-- | The zero-based position of a character in a string, counting from the
--   left.
newtype CharPosition
CharPosition :: Int -> CharPosition
instance GHC.Show.Show Codec.Binary.Bech32.Internal.Word5
instance GHC.Classes.Ord Codec.Binary.Bech32.Internal.Word5
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.Word5
instance GHC.Show.Show Codec.Binary.Bech32.Internal.HumanReadablePartError
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.HumanReadablePartError
instance GHC.Show.Show Codec.Binary.Bech32.Internal.DecodingError
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.DecodingError
instance GHC.Show.Show Codec.Binary.Bech32.Internal.CharPosition
instance GHC.Classes.Ord Codec.Binary.Bech32.Internal.CharPosition
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.CharPosition
instance GHC.Show.Show Codec.Binary.Bech32.Internal.EncodingError
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.EncodingError
instance GHC.Show.Show Codec.Binary.Bech32.Internal.HumanReadablePart
instance GHC.Base.Semigroup Codec.Binary.Bech32.Internal.HumanReadablePart
instance GHC.Base.Monoid Codec.Binary.Bech32.Internal.HumanReadablePart
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.HumanReadablePart
instance GHC.Show.Show Codec.Binary.Bech32.Internal.DataPart
instance GHC.Base.Semigroup Codec.Binary.Bech32.Internal.DataPart
instance GHC.Base.Monoid Codec.Binary.Bech32.Internal.DataPart
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.DataPart
instance GHC.Enum.Bounded Codec.Binary.Bech32.Internal.Word5
instance GHC.Enum.Enum Codec.Binary.Bech32.Internal.Word5
instance GHC.Arr.Ix Codec.Binary.Bech32.Internal.Word5


-- | Implementation of the <a>Bech32</a> address format.
--   
--   From an original implementation by Marko Bencun:
--   
--   <a>sipa/bech32</a>
module Codec.Binary.Bech32

-- | Encode a human-readable string and data payload into a Bech32 string.
encode :: HumanReadablePart -> DataPart -> Either EncodingError Text

-- | Like <a>encode</a> but allows output to be longer than 90 characters.
--   This isn't ideal as the error detection becomes worse as string get
--   longer but it's still acceptable.
--   
--   From BIP-0173:
--   
--   Even though the chosen code performs reasonably well up to 1023
--   characters, other designs are preferable for lengths above 89
--   characters (excluding the separator).
encodeLenient :: HumanReadablePart -> DataPart -> Text

-- | Represents the set of error conditions that may occur while encoding a
--   Bech32 string.
data EncodingError
EncodedStringTooLong :: EncodingError

-- | Decode a Bech32 string into a human-readable part and data part.
decode :: Text -> Either DecodingError (HumanReadablePart, DataPart)

-- | Like <a>decode</a> but does not enforce a maximum length. See also
--   <a>encodeLenient</a> for details.
decodeLenient :: Text -> Either DecodingError (HumanReadablePart, DataPart)

-- | Represents the set of errors that may occur while decoding a Bech32
--   string with the <a>decode</a> function.
data DecodingError
StringToDecodeTooLong :: DecodingError
StringToDecodeTooShort :: DecodingError
StringToDecodeHasMixedCase :: DecodingError
StringToDecodeMissingSeparatorChar :: DecodingError

-- | In cases where it is possible to determine the exact locations of
--   erroneous characters, this list will encode those locations. Clients
--   can use this information to provide user feedback. In cases where it
--   isn't possible to reliably determine the locations of erroneous
--   characters, this list will be empty.
StringToDecodeContainsInvalidChars :: [CharPosition] -> DecodingError

-- | Represents the data part of a Bech32 string, as defined here:
--   <a>https://git.io/fj8FS</a>
data DataPart

-- | Constructs a <a>DataPart</a> from a <a>ByteString</a>.
--   
--   This function encodes a <a>ByteString</a> in such a way that
--   guarantees it can be successfully decoded with the
--   <a>dataPartToBytes</a> function:
--   
--   <pre>
--   dataPartToBytes (dataPartFromBytes b) == Just b
--   </pre>
dataPartFromBytes :: ByteString -> DataPart

-- | Constructs a <a>DataPart</a> from textual input. All characters in the
--   input must be a member of <a>dataCharList</a>, the set of characters
--   permitted to appear within the data part of a Bech32 string.
--   
--   Returns <a>Nothing</a> if any character in the input is not a member
--   of <a>dataCharList</a>.
--   
--   This function guarantees to satisfy the following property:
--   
--   <pre>
--   dataPartFromText (dataPartToText d) == Just d
--   </pre>
dataPartFromText :: Text -> Maybe DataPart

-- | Attempts to extract a <a>ByteString</a> from a <a>DataPart</a>.
--   
--   This function guarantees to satisfy the following property:
--   
--   <pre>
--   dataPartToBytes (dataPartFromBytes b) == Just b
--   </pre>
dataPartToBytes :: DataPart -> Maybe ByteString

-- | Converts a <a>DataPart</a> to <a>Text</a>, using the Bech32 character
--   set to render the data.
--   
--   This function guarantees to satisfy the following property:
--   
--   <pre>
--   dataPartFromText (dataPartToText d) == Just d
--   </pre>
dataPartToText :: DataPart -> Text

-- | Represents the human-readable part of a Bech32 string, as defined
--   here: <a>https://git.io/fj8FS</a>
data HumanReadablePart

-- | Represents the set of error conditions that may occur while parsing
--   the human-readable part of a Bech32 string.
data HumanReadablePartError
HumanReadablePartTooShort :: HumanReadablePartError
HumanReadablePartTooLong :: HumanReadablePartError
HumanReadablePartContainsInvalidChars :: [CharPosition] -> HumanReadablePartError

-- | Parses the human-readable part of a Bech32 string, which obeys the
--   following definition:
--   
--   "The human-readable part, which is intended to convey the type of
--   data, or anything else that is relevant to the reader. This part MUST
--   contain 1 to 83 US-ASCII characters, with each character having a
--   value in the range [33-126]. HRP validity may be further restricted by
--   specific applications."
--   
--   Source:
--   <a>https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32</a>
humanReadablePartFromText :: Text -> Either HumanReadablePartError HumanReadablePart

-- | Get the raw text of the human-readable part of a Bech32 string.
humanReadablePartToText :: HumanReadablePart -> Text

-- | Like <a>humanReadablePartFromText</a>, but throws at runtime if given
--   an invalid <tt>hrp</tt> as text. It is recommended to only make use of
--   this function when using litterals. For example:
--   
--   <pre>
--   &gt;&gt;&gt; unsafeHumanReadablePartFromText "addr"
--   HumanReadablePart "addr"
--   </pre>
unsafeHumanReadablePartFromText :: HasCallStack => Text -> HumanReadablePart
