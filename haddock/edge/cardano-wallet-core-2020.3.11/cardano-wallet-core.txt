-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wallet Backend for a Cardano node.
--   
--   Please see README.md
@package cardano-wallet-core
@version 2020.3.11


-- | An implementation of the DBLayer which uses Persistent and SQLite.
module Cardano.DB.Sqlite

-- | Context for the SQLite <tt>DBLayer</tt>.
data SqliteContext
SqliteContext :: SqlBackend -> (forall a. SqlPersistT IO a -> IO a) -> Maybe FilePath -> Tracer IO DBLog -> SqliteContext

-- | A handle to the Persistent SQL backend.
[$sel:getSqlBackend:SqliteContext] :: SqliteContext -> SqlBackend

-- | <tt>safely</tt> run a query with logging and lock-protection
[$sel:runQuery:SqliteContext] :: SqliteContext -> forall a. SqlPersistT IO a -> IO a

-- | The actual database file, if any. If none, runs in-memory
[$sel:dbFile:SqliteContext] :: SqliteContext -> Maybe FilePath

-- | A <a>Tracer</a> for logging
[$sel:trace:SqliteContext] :: SqliteContext -> Tracer IO DBLog

-- | Size of chunks when inserting, updating or deleting many rows at once.
--   We only act on <a>chunkSize</a> values at a time. See also
--   <a>dbChunked</a>.
chunkSize :: Int

-- | Convert a single DB "updateMany" (or similar) query into multiple
--   updateMany queries with smaller lists of values.
--   
--   This is to prevent too many variables appearing in the SQL statement.
--   SQLITE_MAX_VARIABLE_NUMBER is 999 by default, and we will get a "too
--   many SQL variables" exception if that is exceeded.
--   
--   We choose a conservative value <a>chunkSize</a> &lt;&lt; 999 because
--   there can be multiple variables per row updated.
dbChunked :: ([a] -> SqlPersistT IO b) -> [a] -> SqlPersistT IO ()

-- | Finalize database statements and close the database connection.
--   
--   If the database connection is still in use, it will retry for up to a
--   minute, to let other threads finish up.
--   
--   This function is idempotent: if the database connection has already
--   been closed, calling this function will exit without doing anything.
destroyDBLayer :: SqliteContext -> IO ()

-- | Run an action, and convert any Sqlite constraints exception into the
--   given error result. No other exceptions are handled.
handleConstraint :: MonadCatch m => e -> m a -> m (Either e a)

-- | Opens the SQLite database connection, sets up query logging and
--   timing, runs schema migrations if necessary.
startSqliteBackend :: ManualMigration -> Migration -> Tracer IO DBLog -> Maybe FilePath -> IO (Either MigrationError SqliteContext)

-- | Run a raw query from the outside using an instantiate DB layer. This
--   is completely unsafe because it breaks the abstraction boundary and
--   can have disastrous results on the database consistency.
unsafeRunQuery :: SqliteContext -> SqlPersistT IO a -> IO a

-- | Encapsulates a manual migration action (or sequence of actions) to be
--   performed immediately after an SQL connection is initiated.
newtype ManualMigration
ManualMigration :: (Connection -> IO ()) -> ManualMigration
[$sel:executeManualMigration:ManualMigration] :: ManualMigration -> Connection -> IO ()

-- | Error type for when migrations go wrong after opening a database.
newtype MigrationError
MigrationError :: Text -> MigrationError
[$sel:getMigrationErrorMessage:MigrationError] :: MigrationError -> Text
data DBField
[DBField] :: forall record typ. PersistEntity record => EntityField record typ -> DBField
tableName :: DBField -> Text
fieldName :: DBField -> Text
fieldType :: DBField -> Text
data DBLog
MsgMigrations :: Either MigrationError Int -> DBLog
MsgQuery :: Text -> Severity -> DBLog
MsgRun :: Bool -> DBLog
MsgConnStr :: Text -> DBLog
MsgClosing :: Maybe FilePath -> DBLog
MsgDatabaseReset :: DBLog
MsgIsAlreadyClosed :: Text -> DBLog
MsgStatementAlreadyFinalized :: Text -> DBLog
MsgRemoving :: Text -> DBLog
MsgManualMigrationNeeded :: DBField -> Text -> DBLog
MsgManualMigrationNotNeeded :: DBField -> DBLog
MsgUpdatingForeignKeysSetting :: ForeignKeysSetting -> DBLog
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.DBLog
instance GHC.Classes.Eq Cardano.DB.Sqlite.DBLog
instance GHC.Show.Show Cardano.DB.Sqlite.DBLog
instance GHC.Generics.Generic Cardano.DB.Sqlite.DBLog
instance GHC.Show.Show Cardano.DB.Sqlite.ForeignKeysSetting
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.ForeignKeysSetting
instance GHC.Generics.Generic Cardano.DB.Sqlite.ForeignKeysSetting
instance GHC.Classes.Eq Cardano.DB.Sqlite.ForeignKeysSetting
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.MigrationError
instance GHC.Generics.Generic Cardano.DB.Sqlite.MigrationError
instance GHC.Classes.Eq Cardano.DB.Sqlite.MigrationError
instance GHC.Show.Show Cardano.DB.Sqlite.MigrationError
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.DB.Sqlite.DBLog
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.DB.Sqlite.DBLog
instance Data.Text.Class.ToText Cardano.DB.Sqlite.DBLog
instance GHC.Show.Show Cardano.DB.Sqlite.DBField
instance GHC.Classes.Eq Cardano.DB.Sqlite.DBField
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.DBField
instance Cardano.DB.Sqlite.MatchMigrationError Database.Persist.Types.Base.PersistException
instance Cardano.DB.Sqlite.MatchMigrationError Database.Sqlite.SqliteException
instance GHC.Exception.Type.Exception Cardano.DB.Sqlite.MigrationError


-- | This module contains utility functions for logging and mapping trace
--   data.
module Cardano.Wallet.Logging

-- | Converts a <a>Text</a> trace into any other type of trace that has a
--   <a>ToText</a> instance.
transformTextTrace :: ToText a => Trace IO Text -> Trace IO a

-- | Traces some data.
logTrace :: (MonadIO m, DefinePrivacyAnnotation a, DefineSeverity a) => Trace m a -> a -> m ()

-- | Strips out the data that <a>trMessage</a> (or
--   "Cardano.BM.Data.Tracer.toLogObject") adds.
fromLogObject :: Show a => Tracer IO a -> Tracer IO (LogObject a)

-- | Tracer transformer which converts 'Trace m a' to 'Tracer m a' by
--   wrapping typed log messages into a <a>LogObject</a>.
trMessage :: (MonadIO m, DefinePrivacyAnnotation a, DefineSeverity a) => Tracer m (LogObject a) -> Tracer m a

-- | Tracer transformer which transforms traced items to their
--   <a>ToText</a> representation and further traces them as a
--   <a>LogObject</a>. If the <a>ToText</a> representation is empty, then
--   no tracing happens.
trMessageText :: (MonadIO m, ToText a, DefinePrivacyAnnotation a, DefineSeverity a) => Tracer m (LogObject Text) -> Tracer m a

-- | Tracer transformer which removes tracing below the qgiven severity
--   limit.
filterTraceSeverity :: forall m a. Monad m => Severity -> Trace m a -> Trace m a

-- | Creates a tracer that prints any <a>ToText</a> log message. This is
--   useful for debugging functions in the REPL, when you need a
--   <a>Tracer</a> object.
stdoutTextTracer :: (MonadIO m, ToText a) => Tracer m a
instance (Control.Monad.IO.Class.MonadIO m, Data.Text.Class.ToText a, Cardano.BM.Data.Tracer.DefinePrivacyAnnotation a, Cardano.BM.Data.Tracer.DefineSeverity a) => Cardano.BM.Data.Tracer.Transformable Data.Text.Internal.Text m a


-- | Provides functions for checking if TCP ports can be connected to, or
--   are available to listen on.
--   
--   These can be used for: - Waiting until a server in another process has
--   started. - Start servers for testing when there may be multiple test
--   suites running in parallel.
module Cardano.Wallet.Network.Ports
data PortNumber

-- | Find a TCPv4 port which is likely to be free for listening on
--   <tt>localhost</tt>. This binds a socket, receives an OS-assigned port,
--   then closes the socket.
--   
--   Note that this is vulnerable to race conditions if another process
--   binds the port returned by <a>getRandomPort</a> before this process
--   does.
--   
--   Do not use this unless you have no other option.
getRandomPort :: IO PortNumber

-- | Checks whether <tt>connect()</tt> to a given TCPv4 <a>SockAddr</a>
--   succeeds or returns <a>eCONNREFUSED</a>.
--   
--   Rethrows connection exceptions in all other cases (e.g. when the host
--   is unroutable).
--   
--   Code courtesy of nh2: <a>https://stackoverflow.com/a/57022572</a>
isPortOpen :: SockAddr -> IO Bool

-- | Creates a <tt>SockAttr</tt> from host IP and port number.
--   
--   Example: &gt; simpleSockAddr (127,0,0,1) 8000
simpleSockAddr :: (Word8, Word8, Word8, Word8) -> PortNumber -> SockAddr

-- | Wait until a TCP port is open to connections according to a given
--   retry policy. Throws an exception if the time out is reached.
waitForPort :: RetryPolicyM IO -> PortNumber -> IO Bool

-- | Get the underlying port number for the given socket address. Fails for
--   UNIX socket addresses which aren't bound to any TCP port.
unsafePortNumber :: SockAddr -> PortNumber


-- | This module provides mnemonic (backup phrase) creation, and conversion
--   of a mnemonic to seed for wallet restoration.
--   
--   The module uses a lot of type-level machinery to ensure that entropy
--   and mnemonic sizes are all compatible and legit. Therefore, it isn't
--   possible to generate an invalid seed by using the smart constructors
--   below, and trying to generate an entropy of an invalid size will
--   result in a runtime error.
module Cardano.Wallet.Primitive.Mnemonic

-- | A backup-phrase in the form of a non-empty of Mnemonic words
--   Constructor isn't exposed.
data Mnemonic (mw :: Nat)
data Entropy (n :: Nat)

-- | Smart-constructor for the Entropy
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @(EntropySize 15) bytes
--   Entropy {} :: Entropy 160
--   </pre>
mkEntropy :: forall ent csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ByteString -> Either (EntropyError csz) (Entropy ent)

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   See also <a>FromMnemonic</a> to build a <a>Mnemonic</a> from lists of
--   words of variable sizes.
--   
--   <b>Property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall mw ent csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MnemonicError csz) (Mnemonic mw)

-- | Generate Entropy of a given size using a random seed.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @(EntropySize 12)
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall ent csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MnemonicError csz

-- | This wraps EntropyError of <a>Cardano.Encoding.BIP39</a>
newtype MnemonicException csz

-- | Invalid entropy length or checksum
UnexpectedEntropyError :: EntropyError csz -> MnemonicException csz
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw

-- | Convert <a>Entropy</a> to a plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]
data EntropyError (csz :: Nat)
ErrInvalidEntropyLength :: Int -> Int -> EntropyError
ErrInvalidEntropyChecksum :: Checksum csz -> Checksum csz -> EntropyError
data DictionaryError
ErrInvalidDictionaryWord :: String -> DictionaryError
data MnemonicWordsError
ErrWrongNumberOfWords :: Int -> Int -> MnemonicWordsError
type ValidEntropySize (n :: Nat) = (KnownNat n, NatWithinBound Int n, Elem n 96 : 128 : 160 : 192 : 224 : 256 : ([] :: [Nat]))
type ValidChecksumSize (ent :: Nat) (csz :: Nat) = (KnownNat csz, NatWithinBound Int csz, Elem csz 3 : 4 : 5 : 6 : 7 : 8 : ([] :: [Nat]), CheckSumBits ent ~ csz)
type ValidMnemonicSentence (mw :: Nat) = (KnownNat mw, NatWithinBound Int mw, Elem mw 9 : 12 : 15 : 18 : 21 : 24 : ([] :: [Nat]))
type ConsistentEntropy (ent :: Nat) (mw :: Nat) (csz :: Nat) = (ValidEntropySize ent, ValidChecksumSize ent csz, ValidMnemonicSentence mw, MnemonicWords ent ~ mw)
type family CheckSumBits (n :: Nat) :: Nat
type family EntropySize (n :: Nat) :: Nat
type family MnemonicWords (n :: Nat) :: Nat
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.MnemonicError csz)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Mnemonic.MnemonicError csz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Wallet.Primitive.Mnemonic.MnemonicException csz)


-- | Template Haskell function for getting the git revision from the local
--   repo. This is a separate module due to the GHC stage restriction.
module Cardano.Wallet.Version.TH

-- | Git revision found by running <tt>git rev-parse</tt>. If <tt>git</tt>
--   could not be executed, then this will be an empty string.
gitRevFromGit :: Q Exp


-- | Extra helpers for safe decoding of binary data.
module Data.Binary.Get.Safe

-- | A safe version of <tt>runGet</tt> which doesn't throw on error.
eitherRunGet :: Get a -> ByteString -> Either String a


-- | Provides a mechanism for Daedalus to discover what port the
--   cardano-wallet server is listening on.
--   
--   See
--   <a>https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options</a>
--   for more information about the message protocol.
--   
--   There are two separate message formats and IO mechanisms, depending on
--   whether the OS is Windows or not. On Windows, a duplex named pipe is
--   used for communication with the parent process. If modifying this
--   code, do not add concurrent sending and receiving of messages. It will
--   get stuck, because asynchronous reading and writing to named pipes is
--   not possible.
module Cardano.Wallet.DaedalusIPC

-- | Start up the Daedalus IPC process. It's called <a>daedalusIPC</a>, but
--   this could be any nodejs program that needs to start cardano-wallet.
--   All it does is reply with a port number when asked, using a very
--   nodejs-specific IPC method.
--   
--   If the IPC channel was successfully set up, this function won't return
--   until the parent process exits. Otherwise, it will return immediately.
--   Before returning, it will log an message about why it has exited.
daedalusIPC :: Tracer IO DaedalusIPCLog -> Int -> IO ()
data DaedalusIPCLog
MsgStarting :: DaedalusIPCLog
MsgNotEnabled :: DaedalusIPCLog
MsgStartupError :: Text -> DaedalusIPCLog
MsgSendHello :: DaedalusIPCLog
MsgReceive :: Either Text MsgIn -> DaedalusIPCLog
MsgFinished :: Text -> DaedalusIPCLog
instance GHC.Classes.Eq Cardano.Wallet.DaedalusIPC.NodeChannelError
instance GHC.Show.Show Cardano.Wallet.DaedalusIPC.NodeChannelError
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance GHC.Classes.Eq Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance GHC.Show.Show Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance GHC.Generics.Generic Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance GHC.Classes.Eq Cardano.Wallet.DaedalusIPC.MsgOut
instance GHC.Show.Show Cardano.Wallet.DaedalusIPC.MsgOut
instance GHC.Classes.Eq Cardano.Wallet.DaedalusIPC.MsgIn
instance GHC.Show.Show Cardano.Wallet.DaedalusIPC.MsgIn
instance Data.Text.Class.ToText Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance Cardano.BM.Data.Tracer.ToObject Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.Wallet.DaedalusIPC.DaedalusIPCLog
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DaedalusIPC.MsgOut
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DaedalusIPC.MsgIn
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DaedalusIPC.MsgIn

module Data.Function.Utils

-- | Apply a function <tt>n</tt> times to the specified input.
applyN :: Integral n => n -> (a -> a) -> a -> a


-- | Representation of values with an associated (free) unit of measure.
--   Useful to disambiguate primitive types like <a>Int</a> or <a>Value</a>
--   which can be in different bases depending on the context.
module Data.Quantity

-- | <tt>Quantity (unit :: Symbol) a</tt> is a primitive <tt>a</tt>
--   multiplied by an <tt>unit</tt>.
--   
--   Example:
--   
--   Instead of providing the unit implicitly as a comment, or a part of a
--   name
--   
--   <pre>
--   &gt;&gt;&gt; a :: Word32 -- in lovelace
--   </pre>
--   
--   we can write
--   
--   <pre>
--   &gt;&gt;&gt; a :: Quantity "lovelace" Word32
--   </pre>
--   
--   which now has a different type from
--   
--   <pre>
--   &gt;&gt;&gt; b :: Quantity "lovelace/byte" Word32
--   </pre>
--   
--   so mixing them up is more difficult.
--   
--   The unit is mostly a phantom type, but it is also included in the
--   <tt>ToJSON</tt>/<tt>FromJSON</tt> instances.
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode $ Quantity @"lovelace" 14
--   {"unit":"lovelace","quantity":14}
--   </pre>
newtype Quantity (unit :: Symbol) a
Quantity :: a -> Quantity a
[getQuantity] :: Quantity a -> a

-- | Opaque Haskell type to represent values between 0 and 100 (incl).
data Percentage
data MkPercentageError
PercentageOutOfBoundsError :: MkPercentageError

-- | Safe constructor for <a>Percentage</a>
--   
--   Takes an input in the range [0, 1].
mkPercentage :: Rational -> Either MkPercentageError Percentage
getPercentage :: Percentage -> Rational

-- | Turn a <tt>Percentage</tt> to a <tt>Double</tt> (without any extra
--   rounding.)
percentageToDouble :: Percentage -> Double
instance GHC.Classes.Eq Data.Quantity.MkPercentageError
instance GHC.Show.Show Data.Quantity.MkPercentageError
instance GHC.Classes.Ord Data.Quantity.Percentage
instance GHC.Classes.Eq Data.Quantity.Percentage
instance GHC.Show.Show Data.Quantity.Percentage
instance GHC.Generics.Generic Data.Quantity.Percentage
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Quantity.Quantity unit a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Quantity.Quantity unit a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Quantity.Quantity unit a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Quantity.Quantity unit a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Quantity.Quantity unit a)
instance GHC.Generics.Generic (Data.Quantity.Quantity unit a)
instance Control.DeepSeq.NFData Data.Quantity.Percentage
instance Data.Aeson.Types.ToJSON.ToJSON Data.Quantity.Percentage
instance Data.Aeson.Types.FromJSON.FromJSON Data.Quantity.Percentage
instance GHC.Enum.Bounded Data.Quantity.Percentage
instance Data.Text.Class.ToText Data.Quantity.Percentage
instance Data.Text.Class.FromText Data.Quantity.Percentage
instance GHC.Base.Functor (Data.Quantity.Quantity any)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Quantity.Quantity unit a)
instance (GHC.TypeLits.KnownSymbol unit, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Data.Quantity.Quantity unit a)
instance (GHC.TypeLits.KnownSymbol unit, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Data.Quantity.Quantity unit a)
instance Data.Text.Class.FromText b => Data.Text.Class.FromText (Data.Quantity.Quantity sym b)
instance Data.Text.Class.ToText b => Data.Text.Class.ToText (Data.Quantity.Quantity sym b)
instance (GHC.TypeLits.KnownSymbol unit, Formatting.Buildable.Buildable a) => Formatting.Buildable.Buildable (Data.Quantity.Quantity unit a)


-- | This module contains the core primitive of a Wallet. This is roughly a
--   Haskell translation of the <a>Formal Specification for a Cardano
--   Wallet</a>
--   
--   It doesn't contain any particular business-logic code, but define a
--   few primitive operations on Wallet core types as well.
module Cardano.Wallet.Primitive.Types
data Block
Block :: !BlockHeader -> ![Tx] -> ![DelegationCertificate] -> Block
[$sel:header:Block] :: Block -> !BlockHeader
[$sel:transactions:Block] :: Block -> ![Tx]
[$sel:delegations:Block] :: Block -> ![DelegationCertificate]
data BlockHeader
BlockHeader :: SlotId -> Quantity "block" Word32 -> !Hash "BlockHeader" -> !Hash "BlockHeader" -> BlockHeader
[$sel:slotId:BlockHeader] :: BlockHeader -> SlotId
[$sel:blockHeight:BlockHeader] :: BlockHeader -> Quantity "block" Word32
[$sel:headerHash:BlockHeader] :: BlockHeader -> !Hash "BlockHeader"
[$sel:parentHeaderHash:BlockHeader] :: BlockHeader -> !Hash "BlockHeader"

-- | Primitive <tt>Tx</tt>-type.
--   
--   Currently tailored for jormungandr in that inputs are <tt>(TxIn,
--   Coin)</tt> instead of <tt>TxIn</tt>. We might have to revisit this
--   when supporting another node.
data Tx
Tx :: Hash "Tx" -> ![(TxIn, Coin)] -> ![TxOut] -> Tx

-- | Jörmungandr computes transaction id by hashing the full content of the
--   transaction, which includes witnesses. Therefore, we need either to
--   keep track of the witnesses to be able to re-compute the tx id every
--   time, or, simply keep track of the id itself.
[$sel:txId:Tx] :: Tx -> Hash "Tx"

-- | NOTE: Order of inputs matters in the transaction representation. The
--   transaction id is computed from the binary representation of a tx, for
--   which inputs are serialized in a specific order.
[$sel:resolvedInputs:Tx] :: Tx -> ![(TxIn, Coin)]

-- | NOTE: Order of outputs matter in the transaction representations.
--   Outputs are used as inputs for next transactions which refer to them
--   using their indexes. It matters also for serialization.
[$sel:outputs:Tx] :: Tx -> ![TxOut]
data TxIn
TxIn :: !Hash "Tx" -> !Word32 -> TxIn
[$sel:inputId:TxIn] :: TxIn -> !Hash "Tx"
[$sel:inputIx:TxIn] :: TxIn -> !Word32
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[$sel:address:TxOut] :: TxOut -> !Address
[$sel:coin:TxOut] :: TxOut -> !Coin
data TxMeta
TxMeta :: !TxStatus -> !Direction -> !SlotId -> !Quantity "block" Word32 -> !Quantity "lovelace" Natural -> TxMeta
[$sel:status:TxMeta] :: TxMeta -> !TxStatus
[$sel:direction:TxMeta] :: TxMeta -> !Direction
[$sel:slotId:TxMeta] :: TxMeta -> !SlotId
[$sel:blockHeight:TxMeta] :: TxMeta -> !Quantity "block" Word32
[$sel:amount:TxMeta] :: TxMeta -> !Quantity "lovelace" Natural

-- | The effect of a <tt>Transaction</tt> on the wallet balance.
data Direction

-- | The wallet balance decreases.
Outgoing :: Direction

-- | The wallet balance increases or stays the same.
Incoming :: Direction
data TxStatus
Pending :: TxStatus
InLedger :: TxStatus

-- | <tt>SealedTx</tt> is a serialised transaction that is ready to be
--   submited to the node.
newtype SealedTx
SealedTx :: ByteString -> SealedTx
[$sel:getSealedTx:SealedTx] :: SealedTx -> ByteString

-- | Full expanded and resolved information about a transaction, suitable
--   for presentation to the user.
data TransactionInfo
TransactionInfo :: !Hash "Tx" -> ![(TxIn, Maybe TxOut)] -> ![TxOut] -> !TxMeta -> Quantity "block" Natural -> UTCTime -> TransactionInfo

-- | Transaction ID of this transaction
[$sel:txInfoId:TransactionInfo] :: TransactionInfo -> !Hash "Tx"

-- | Transaction inputs and (maybe) corresponding outputs of the source.
--   Source information can only be provided for outgoing payments.
[$sel:txInfoInputs:TransactionInfo] :: TransactionInfo -> ![(TxIn, Maybe TxOut)]

-- | Payment destination.
[$sel:txInfoOutputs:TransactionInfo] :: TransactionInfo -> ![TxOut]

-- | Other information calculated from the transaction.
[$sel:txInfoMeta:TransactionInfo] :: TransactionInfo -> !TxMeta

-- | Number of slots since the transaction slot.
[$sel:txInfoDepth:TransactionInfo] :: TransactionInfo -> Quantity "block" Natural

-- | Creation time of the block including this transaction.
[$sel:txInfoTime:TransactionInfo] :: TransactionInfo -> UTCTime

-- | An unsigned transaction.
--   
--   See <a>Tx</a> for a signed transaction.
data UnsignedTx
UnsignedTx :: NonEmpty (TxIn, TxOut) -> NonEmpty TxOut -> UnsignedTx
[$sel:unsignedInputs:UnsignedTx] :: UnsignedTx -> NonEmpty (TxIn, TxOut)
[$sel:unsignedOutputs:UnsignedTx] :: UnsignedTx -> NonEmpty TxOut
txIns :: Set Tx -> Set TxIn

-- | True if the given tuple refers to a pending transaction
isPending :: TxMeta -> Bool
inputs :: Tx -> [TxIn]

-- | Representation of Cardano addresses. Addresses are basically a
--   human-friendly representation of public keys. Historically in Cardano,
--   there exists different sort of addresses, and new ones are to come. So
--   far, we can distinguish between three types of addresses:
--   
--   <ul>
--   <li>Byron Random addresses, which holds a payload with derivation path
--   details</li>
--   <li>Byron Sequential addresses, also known as Icarus'style
--   addresses</li>
--   <li>Shelley base addresses, see also
--   <a>implementation-decisions/address</a></li>
--   </ul>
--   
--   For more details, see also <a>About Address Derivation</a>
--   
--   Shelley base addresses can be declined into two types:
--   
--   <ul>
--   <li>Single Addresses: which only holds a public spending key</li>
--   <li>Group Addresses: which hold both a spending and delegation
--   keys</li>
--   </ul>
--   
--   It'll therefore seem legitimate to represent addresses as:
--   
--   <pre>
--   data Address
--     = ByronAddress !ByteString
--     | SingleAddress !XPub
--     | GroupAddress !XPub XPub
--   </pre>
--   
--   However, there's a major drawback to this approach: we have to
--   consider all three constructors everywhere, and make sure we test
--   every function using them three despite having no need for such
--   fine-grained representation.
--   
--   Indeed, from the wallet core code, addresses are nothing more than an
--   opaque bunch of bytes that can be compared with each others. When
--   signing transactions, we have to lookup addresses anyway and
--   therefore, can re-derive their corresponding public keys. The only
--   moment the distinction between address type matters is when it comes
--   to representing addresses at the edge of the application (the API
--   layer). And here, this is precisely where we need to also what target
--   backend we're connected to. Different backends use different encodings
--   which may not be compatible.
--   
--   Therefore, for simplicity, it's easier to consider addresses as
--   "bytes", and only peak into these bytes whenever we need to do
--   something with them. This makes it fairly clear that addresses are
--   just an opaque string for the wallet layer and that the underlying
--   encoding is rather agnostic to the underlying backend.
newtype Address
Address :: ByteString -> Address
[$sel:unAddress:Address] :: Address -> ByteString

-- | Denotes if an address has been previously used or not... whether that
--   be in the output of a transaction on the blockchain or one in our
--   pending set.
data AddressState
Used :: AddressState
Unused :: AddressState

-- | Also known as a staking key, chimeric account is used in group-type
--   address for staking purposes. It is a public key of the account
--   address
newtype ChimericAccount
ChimericAccount :: ByteString -> ChimericAccount
[$sel:unChimericAccount:ChimericAccount] :: ChimericAccount -> ByteString

-- | Represent a delegation certificate.
data DelegationCertificate
CertDelegateNone :: ChimericAccount -> DelegationCertificate
CertDelegateFull :: ChimericAccount -> PoolId -> DelegationCertificate
dlgCertAccount :: DelegationCertificate -> ChimericAccount
dlgCertPoolId :: DelegationCertificate -> Maybe PoolId

-- | Pool ownership data from the stake pool registration certificate.
data PoolRegistrationCertificate
PoolRegistrationCertificate :: !PoolId -> ![PoolOwner] -> Percentage -> Quantity "lovelace" Word64 -> PoolRegistrationCertificate
[$sel:poolId:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> !PoolId
[$sel:poolOwners:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> ![PoolOwner]
[$sel:poolMargin:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> Percentage
[$sel:poolCost:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> Quantity "lovelace" Word64

-- | Coins are stored as Lovelace (reminder: 1 Lovelace = 1e-6 ADA)
newtype Coin
Coin :: Word64 -> Coin
[$sel:getCoin:Coin] :: Coin -> Word64
isValidCoin :: Coin -> Bool
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[$sel:getUTxO:UTxO] :: UTxO -> Map TxIn TxOut

-- | Compute the balance of a UTxO
balance :: UTxO -> Natural

-- | Compute the balance of a unwrapped UTxO
balance' :: [(TxIn, TxOut)] -> Word64

-- | Pick a random element from a UTxO, returns <a>Nothing</a> if the UTxO
--   is empty. Otherwise, returns the selected entry and, the UTxO minus
--   the selected one.
pickRandom :: MonadRandom m => UTxO -> m (Maybe (TxIn, TxOut), UTxO)

-- | ins⋪ u
excluding :: UTxO -> Set TxIn -> UTxO

-- | a ⊆ b
isSubsetOf :: UTxO -> UTxO -> Bool

-- | ins⊲ u
restrictedBy :: UTxO -> Set TxIn -> UTxO

-- | u ⊳ outs
restrictedTo :: UTxO -> Set TxOut -> UTxO

-- | Allows us to define the "domain" of any type — <tt>UTxO</tt> in
--   particular — and use <a>dom</a> to refer to the <i>inputs</i> of an
--   <i>utxo</i>.
--   
--   This is the terminology used in the <a>Formal Specification for a
--   Cardano Wallet</a> uses.
class Dom a where {
    type family DomElem a :: *;
}
dom :: Dom a => a -> Set (DomElem a)
data UTxOStatistics
UTxOStatistics :: ![HistogramBar] -> !Word64 -> BoundType -> UTxOStatistics
[$sel:histogram:UTxOStatistics] :: UTxOStatistics -> ![HistogramBar]
[$sel:allStakes:UTxOStatistics] :: UTxOStatistics -> !Word64
[$sel:boundType:UTxOStatistics] :: UTxOStatistics -> BoundType
data HistogramBar
HistogramBar :: !Word64 -> !Word64 -> HistogramBar
[$sel:bucketUpperBound:HistogramBar] :: HistogramBar -> !Word64
[$sel:bucketCount:HistogramBar] :: HistogramBar -> !Word64
data BoundType

-- | Compute UtxoStatistics from UTxOs
computeUtxoStatistics :: BoundType -> UTxO -> UTxOStatistics

-- | Smart-constructor to create bounds using a log-10 scale
log10 :: BoundType
data BlockchainParameters
BlockchainParameters :: Hash "Genesis" -> StartTime -> FeePolicy -> SlotLength -> EpochLength -> Quantity "byte" Word16 -> Quantity "block" Word32 -> ActiveSlotCoefficient -> BlockchainParameters

-- | Hash of the very first block
[$sel:getGenesisBlockHash:BlockchainParameters] :: BlockchainParameters -> Hash "Genesis"

-- | Start time of the chain.
[$sel:getGenesisBlockDate:BlockchainParameters] :: BlockchainParameters -> StartTime

-- | Policy regarding transaction fee.
[$sel:getFeePolicy:BlockchainParameters] :: BlockchainParameters -> FeePolicy

-- | Length, in seconds, of a slot.
[$sel:getSlotLength:BlockchainParameters] :: BlockchainParameters -> SlotLength

-- | Number of slots in a single epoch.
[$sel:getEpochLength:BlockchainParameters] :: BlockchainParameters -> EpochLength

-- | Maximum size of a transaction (soft or hard limit).
[$sel:getTxMaxSize:BlockchainParameters] :: BlockchainParameters -> Quantity "byte" Word16

-- | Length of the suffix of the chain considered unstable
[$sel:getEpochStability:BlockchainParameters] :: BlockchainParameters -> Quantity "block" Word32

-- | In Genesis/Praos, corresponds to the % of active slots (i.e. slots for
--   which someone can be elected as leader).
[$sel:getActiveSlotCoefficient:BlockchainParameters] :: BlockchainParameters -> ActiveSlotCoefficient
newtype ActiveSlotCoefficient
ActiveSlotCoefficient :: Double -> ActiveSlotCoefficient
[$sel:unActiveSlotCoefficient:ActiveSlotCoefficient] :: ActiveSlotCoefficient -> Double

-- | Number of slots in a single epoch
newtype EpochLength
EpochLength :: Word32 -> EpochLength
[$sel:unEpochLength:EpochLength] :: EpochLength -> Word32
newtype EpochNo
EpochNo :: Word31 -> EpochNo
[$sel:unEpochNo:EpochNo] :: EpochNo -> Word31

-- | A linear equation of a free variable <tt>x</tt>. Represents the <tt>x
--   -&gt; a + b*x</tt> function where <tt>x</tt> can be the transaction
--   size in bytes or, a number of inputs + outputs.
--   
--   <tt>a</tt>, <tt>b</tt> and <tt>c</tt> are constant coefficients.
--   
--   FIXME <a>Double</a> is an old artifact from the Byron era on
--   cardano-sl. It must go.
data FeePolicy
LinearFee :: Quantity "lovelace" Double -> Quantity "lovelace/byte" Double -> Quantity "lovelace/certificate" Double -> FeePolicy

-- | A slot identifier is the combination of an epoch and slot.
data SlotId
SlotId :: !EpochNo -> !SlotNo -> SlotId
[$sel:epochNumber:SlotId] :: SlotId -> !EpochNo
[$sel:slotNumber:SlotId] :: SlotId -> !SlotNo

-- | Duration of a single slot.
newtype SlotLength
SlotLength :: NominalDiffTime -> SlotLength
[$sel:unSlotLength:SlotLength] :: SlotLength -> NominalDiffTime
newtype SlotNo
SlotNo :: Word32 -> SlotNo
[$sel:unSlotNo:SlotNo] :: SlotNo -> Word32

-- | Blockchain start time
newtype StartTime
StartTime :: UTCTime -> StartTime
slotParams :: BlockchainParameters -> SlotParameters
data SyncProgress
Ready :: SyncProgress
Syncing :: !Quantity "percent" Percentage -> SyncProgress
newtype SyncTolerance
SyncTolerance :: NominalDiffTime -> SyncTolerance

-- | Construct a <a>SyncTolerance</a> from a number of <b>seconds</b>
mkSyncTolerance :: Int -> SyncTolerance

-- | Convert the specified value into an <a>EpochNo</a>, or fail if the
--   value is too large.
unsafeEpochNo :: HasCallStack => Word32 -> EpochNo

-- | Calculate the time at which an epoch begins.
epochStartTime :: SlotParameters -> EpochNo -> UTCTime

-- | Return the epoch immediately before the given epoch, or <a>Nothing</a>
--   if there is no representable epoch before the given epoch.
epochPred :: EpochNo -> Maybe EpochNo

-- | Return the epoch immediately after the given epoch, or <a>Nothing</a>
--   if there is no representable epoch after the given epoch.
epochSucc :: EpochNo -> Maybe EpochNo

-- | The essential parameters necessary for performing slot arithmetic.
data SlotParameters
SlotParameters :: EpochLength -> SlotLength -> StartTime -> ActiveSlotCoefficient -> SlotParameters
[$sel:getEpochLength:SlotParameters] :: SlotParameters -> EpochLength
[$sel:getSlotLength:SlotParameters] :: SlotParameters -> SlotLength
[$sel:getGenesisBlockDate:SlotParameters] :: SlotParameters -> StartTime
[$sel:getActiveSlotCoefficient:SlotParameters] :: SlotParameters -> ActiveSlotCoefficient

-- | Estimate restoration progress based on:
--   
--   <ul>
--   <li>The current local tip</li>
--   <li>The last slot</li>
--   </ul>
--   
--   For the sake of this calculation, we are somewhat conflating the
--   definitions of slots and block height. Because we can't reliably
--   _trust_ that the current node is actually itself synced with the
--   network. So, we compute the progress as:
--   
--   <pre>
--   p = h / (h + X)
--   </pre>
--   
--   Where:
--   
--   <ul>
--   <li><tt>h</tt>: the number of blocks we have ingested so far.</li>
--   <li><tt>X</tt>: the estimatd remaining slots to reach the network
--   tip.</li>
--   </ul>
--   
--   Initially, <tt>X</tt> gives a relatively poor estimation of the
--   network height, as it assumes that every next slot will be a block.
--   But, as we ingest blocks, <tt>h</tt> becomes bigger and <tt>X</tt>
--   becomes smaller making the progress estimation better and better. At
--   some point, <tt>X</tt> is null, and we have `p = h / h`
syncProgress :: SyncTolerance -> SlotParameters -> BlockHeader -> SlotId -> SyncProgress

-- | Helper to compare the <i>local tip</i> with the slot corresponding to
--   a <tt>UTCTime</tt>, and calculate progress based on that.
syncProgressRelativeToTime :: SyncTolerance -> SlotParameters -> BlockHeader -> UTCTime -> SyncProgress

-- | Convert a <a>SlotId</a> to the number of slots since genesis.
flatSlot :: EpochLength -> SlotId -> Word64

-- | Convert a <a>flatSlot</a> index to <a>SlotId</a>.
--   
--   This function will fail if applied to a value that is higher than the
--   maximum value of <a>flatSlot</a> for the specified <a>EpochLength</a>.
fromFlatSlot :: EpochLength -> Word64 -> SlotId

-- | The time that a slot begins.
slotStartTime :: SlotParameters -> SlotId -> UTCTime

-- | For the given time <tt>t</tt>, determine the ID of the earliest slot
--   with start time <tt>s</tt> such that 't ≤ s'.
slotCeiling :: SlotParameters -> UTCTime -> SlotId

-- | For the given time <tt>t</tt>, determine the ID of the latest slot
--   with start time <tt>s</tt> such that 's ≤ t'.
slotFloor :: SlotParameters -> UTCTime -> Maybe SlotId

-- | For the given time <tt>t</tt>, determine the ID of the unique slot
--   with start time <tt>s</tt> and end time <tt>e</tt> such that 's ≤ t ≤
--   e'.
slotAt :: SlotParameters -> UTCTime -> Maybe SlotId

-- | <tt>slotDifference a b</tt> is how many slots <tt>a</tt> is after
--   <tt>b</tt>. The result is non-negative, and if <tt>b &gt; a</tt> then
--   this function returns zero.
slotDifference :: SlotParameters -> SlotId -> SlotId -> Quantity "slot" Natural

-- | Returns the earliest slot.
slotMinBound :: SlotId

-- | Return the slot immediately before the given slot.
slotPred :: SlotParameters -> SlotId -> Maybe SlotId

-- | Return the slot immediately after the given slot.
slotSucc :: SlotParameters -> SlotId -> SlotId

-- | Transforms the given inclusive time range into an inclusive slot
--   range.
--   
--   This function returns a slot range if (and only if) the specified time
--   range intersects with the life of the blockchain.
--   
--   If, on the other hand, the specified time range terminates before the
--   start of the blockchain, this function returns <a>Nothing</a>.
slotRangeFromTimeRange :: SlotParameters -> Range UTCTime -> Maybe (Range SlotId)

-- | Additional information about a wallet that can't simply be derived
--   from the blockchain like <tt>Wallet s</tt> is.
--   
--   Whereas <tt>Wallet s</tt> in <a>Primitive</a> can be updated using
--   <tt>applyBlock</tt>, <tt>WalletMetadata</tt> is not*.
--   
--   <ul>
--   <li>) Except for possibly <a>WalletDelegationNext</a> and
--   <a>$sel:delegation:WalletMetadata</a>...</li>
--   </ul>
data WalletMetadata
WalletMetadata :: !WalletName -> !UTCTime -> !Maybe WalletPassphraseInfo -> !WalletDelegation -> WalletMetadata
[$sel:name:WalletMetadata] :: WalletMetadata -> !WalletName
[$sel:creationTime:WalletMetadata] :: WalletMetadata -> !UTCTime
[$sel:passphraseInfo:WalletMetadata] :: WalletMetadata -> !Maybe WalletPassphraseInfo
[$sel:delegation:WalletMetadata] :: WalletMetadata -> !WalletDelegation
newtype WalletId
WalletId :: Digest Blake2b_160 -> WalletId
[$sel:getWalletId:WalletId] :: WalletId -> Digest Blake2b_160

-- | Length-restricted name of a wallet
newtype WalletName
WalletName :: Text -> WalletName
[$sel:getWalletName:WalletName] :: WalletName -> Text

-- | Calling 'fromText @WalletName' on shorter longer string will fail.
walletNameMinLength :: Int

-- | Calling 'fromText @WalletName' on a longer string will fail.
walletNameMaxLength :: Int
data WalletDelegation
WalletDelegation :: !WalletDelegationStatus -> ![WalletDelegationNext] -> WalletDelegation
[$sel:active:WalletDelegation] :: WalletDelegation -> !WalletDelegationStatus
[$sel:next:WalletDelegation] :: WalletDelegation -> ![WalletDelegationNext]
data WalletDelegationStatus
NotDelegating :: WalletDelegationStatus
Delegating :: !PoolId -> WalletDelegationStatus
data WalletDelegationNext
WalletDelegationNext :: !EpochNo -> !WalletDelegationStatus -> WalletDelegationNext
[$sel:changesAt:WalletDelegationNext] :: WalletDelegationNext -> !EpochNo
[$sel:status:WalletDelegationNext] :: WalletDelegationNext -> !WalletDelegationStatus
newtype WalletPassphraseInfo
WalletPassphraseInfo :: UTCTime -> WalletPassphraseInfo
[$sel:lastUpdatedAt:WalletPassphraseInfo] :: WalletPassphraseInfo -> UTCTime
data WalletBalance
WalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> WalletBalance
[$sel:available:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:total:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:reward:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
class IsDelegatingTo a
isDelegatingTo :: IsDelegatingTo a => (PoolId -> Bool) -> a -> Bool

-- | Identifies a stake pool. For Jörmungandr a <a>PoolId</a> is the
--   blake2b-256 hash of the stake pool registration certificate.
newtype PoolId
PoolId :: ByteString -> PoolId
[$sel:getPoolId:PoolId] :: PoolId -> ByteString

-- | A stake pool owner, which is a public key encoded in bech32 with
--   prefix ed25519_pk.
newtype PoolOwner
PoolOwner :: ByteString -> PoolOwner
[$sel:getPoolOwner:PoolOwner] :: PoolOwner -> ByteString
data StakeDistribution
StakeDistribution :: Quantity "lovelace" Word64 -> [(PoolId, Quantity "lovelace" Word64)] -> Quantity "lovelace" Word64 -> StakeDistribution
[$sel:dangling:StakeDistribution] :: StakeDistribution -> Quantity "lovelace" Word64
[$sel:pools:StakeDistribution] :: StakeDistribution -> [(PoolId, Quantity "lovelace" Word64)]
[$sel:unassigned:StakeDistribution] :: StakeDistribution -> Quantity "lovelace" Word64
poolIdBytesLength :: Int

-- | Represents a sort order, applicable to the results returned by a
--   query.
data SortOrder

-- | Sort in ascending order.
Ascending :: SortOrder

-- | Sort in descending order.
Descending :: SortOrder

-- | Represents a range of values.
--   
--   A range is defined by two <i>optional</i> bounds:
--   
--   <ol>
--   <li>an <i>inclusive</i> lower bound</li>
--   <li>an <i>inclusive</i> upper bound</li>
--   </ol>
--   
--   There are four cases:
--   
--   TODO: table
data Range a
Range :: Maybe a -> Maybe a -> Range a
[$sel:inclusiveLowerBound:Range] :: Range a -> Maybe a
[$sel:inclusiveUpperBound:Range] :: Range a -> Maybe a

-- | Represents a range boundary.
data RangeBound a
NegativeInfinity :: RangeBound a
InclusiveBound :: a -> RangeBound a
PositiveInfinity :: RangeBound a

-- | The range that includes everything.
wholeRange :: Range a

-- | Returns <a>True</a> if (and only if) the given range has an upper
--   bound and the specified value is greater than the upper bound.
isAfterRange :: Ord a => a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has a lower bound
--   and the specified value is smaller than the lower bound.
isBeforeRange :: Ord a => a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the first given range is a
--   subrange of the second given range.
isSubrangeOf :: Ord a => Range a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given value is not smaller
--   than the lower bound (if present) of the given range and is not
--   greater than the upper bound (if present) of the given range.
isWithinRange :: Ord a => a -> Range a -> Bool

-- | Apply a function to the lower bound of a range.
mapRangeLowerBound :: (a -> a) -> Range a -> Range a

-- | Apply a function to the upper bound of a range.
mapRangeUpperBound :: (a -> a) -> Range a -> Range a

-- | Returns <a>True</a> if (and only if) the given range has both a lower
--   and upper bound.
rangeIsFinite :: Range a -> Bool

-- | Returns <a>True</a> if (and only if) the range covers exactly one
--   value.
rangeIsSingleton :: Eq a => Range a -> Bool

-- | Returns <a>True</a> if (and only if) the lower bound of a range is not
--   greater than its upper bound.
rangeIsValid :: Ord a => Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has a lower
--   bound.
rangeHasLowerBound :: Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has an upper
--   bound.
rangeHasUpperBound :: Range a -> Bool

-- | Get the lower bound of a <a>Range</a>.
rangeLowerBound :: Range a -> RangeBound a

-- | Get the upper bound of a <a>Range</a>.
rangeUpperBound :: Range a -> RangeBound a

-- | Magic constant associated to a given network
newtype ProtocolMagic
ProtocolMagic :: Int32 -> ProtocolMagic
[$sel:getProtocolMagic:ProtocolMagic] :: ProtocolMagic -> Int32

-- | Hard-coded protocol magic for the Byron TestNet
testnetMagic :: ProtocolMagic

-- | Hard-codedo protocol magic for the Byron MainNet
mainnetMagic :: ProtocolMagic
newtype Hash (tag :: Symbol)
Hash :: ByteString -> Hash
[$sel:getHash:Hash] :: Hash -> ByteString

-- | A polymorphic wrapper type with a custom show instance to display data
--   through <a>Buildable</a> instances.
newtype ShowFmt a
ShowFmt :: a -> ShowFmt a
[$sel:unShowFmt:ShowFmt] :: ShowFmt a -> a

-- | Checks whether or not an invariant holds, by applying the given
--   predicate to the given value.
--   
--   If the invariant does not hold (indicated by the predicate function
--   returning <a>False</a>), throws an error with the specified message.
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [1,2,3] (not . null)
--   [1, 2, 3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [] (not . null)
--   *** Exception: not empty
--   </pre>
invariant :: String -> a -> (a -> Bool) -> a

-- | Compute distance between two numeric values |a - b|
distance :: (Ord a, Num a) => a -> a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Block
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Block
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Block
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Block
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UnsignedTx
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UnsignedTx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TransactionInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TransactionInfo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TransactionInfo
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.BlockchainParameters
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.BlockchainParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.BlockchainParameters
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.ChimericAccount
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ChimericAccount
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ChimericAccount
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ChimericAccount
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ProtocolMagic
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ProtocolMagic
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ProtocolMagic
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotParameters
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SyncTolerance
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SyncTolerance
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SyncTolerance
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SyncProgress
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SyncProgress
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SyncProgress
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletDelegation
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletDelegation
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletDelegation
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Num.Num Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.SlotNo
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotNo
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SlotNo
instance GHC.Num.Num Cardano.Wallet.Primitive.Types.SlotNo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotNo
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.SlotNo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotNo
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.SlotNo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotNo
instance GHC.Real.Fractional Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Num.Num Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxOStatistics
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxOStatistics
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxOStatistics
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Coin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.FeePolicy
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.FeePolicy
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.FeePolicy
instance Data.ByteArray.Types.ByteArrayAccess Cardano.Wallet.Primitive.Types.SealedTx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SealedTx
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SealedTx
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SealedTx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Direction
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Direction
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Direction
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.Direction
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Direction
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Direction
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StakeDistribution
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StakeDistribution
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StakeDistribution
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.RangeBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.RangeBound a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.Range a)
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.Range
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Range a)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletName
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.PoolOwner
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance Formatting.Buildable.Buildable a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Block
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Block
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.BlockHeader
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.BlockHeader
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxO
instance Cardano.Wallet.Primitive.Types.Dom Cardano.Wallet.Primitive.Types.UTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.UTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxIn
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxIn
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.TxIn, Cardano.Wallet.Primitive.Types.TxOut)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.BlockchainParameters
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.BlockchainParameters
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.Hash tag)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Hash tag)
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.Types.Hash tag)
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "Tx")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "Account")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "Genesis")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "Block")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "BlockHeader")
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.DelegationCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ChimericAccount
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.ProtocolMagic
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.StartTime
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.EpochLength
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotLength
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.SyncTolerance
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.SyncTolerance
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SyncProgress
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.SyncProgress
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SyncProgress
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletMetadata
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletDelegation
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletDelegation
instance Cardano.Wallet.Primitive.Types.IsDelegatingTo Cardano.Wallet.Primitive.Types.WalletDelegation
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance Cardano.Wallet.Primitive.Types.IsDelegatingTo Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxMeta
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxMeta
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SlotId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.EpochNo
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.EpochNo
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxOStatistics
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.HistogramBar
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxOut
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxOut
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Coin
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Coin
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Coin
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.AddressState
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.AddressState
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Address
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Address
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Address
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Address
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.FeePolicy
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.FeePolicy
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.FeePolicy
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Direction
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Direction
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Direction
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Direction
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxStatus
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxStatus
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TxStatus
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TxStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolOwner
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.PoolOwner
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance Cardano.Wallet.Primitive.Types.IsDelegatingTo Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.PoolId
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.PoolId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.SortOrder
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.SortOrder
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletName
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletName


-- | Provides the API of Coin Selection algorithm and Fee Calculation This
--   module contains the implementation of adjusting coin selection for a
--   fee. The sender pays for the fee and additional inputs are picked
--   randomly. For more information refer to:
--   <a>https://iohk.io/blog/self-organisation-in-coin-selection/</a>
module Cardano.Wallet.Primitive.CoinSelection
data CoinSelection
CoinSelection :: [(TxIn, TxOut)] -> [TxOut] -> [Coin] -> CoinSelection

-- | Picked inputs
[inputs] :: CoinSelection -> [(TxIn, TxOut)]

-- | Picked outputs
[outputs] :: CoinSelection -> [TxOut]

-- | Resulting changes
[change] :: CoinSelection -> [Coin]

-- | Calculate the sum of all input values
inputBalance :: CoinSelection -> Word64

-- | Calculate the sum of all output values
outputBalance :: CoinSelection -> Word64

-- | Calculate the sum of all output values
changeBalance :: CoinSelection -> Word64
feeBalance :: CoinSelection -> Word64
data ErrCoinSelection e

-- | UTxO exhausted during input selection We record the balance of the
--   UTxO as well as the size of the payment we tried to make.
ErrNotEnoughMoney :: Word64 -> Word64 -> ErrCoinSelection e

-- | UTxO is not enough fragmented for the number of transaction outputs We
--   record the number of UTxO entries as well as the number of the outputs
--   of the transaction.
ErrUtxoNotEnoughFragmented :: Word64 -> Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the max number of allowed
--   inputs was reached.
ErrMaximumInputsReached :: Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the available inputs are
--   depleted even when UTxO is properly fragmented and with enough funds
--   to cover payment
ErrInputsDepleted :: ErrCoinSelection e

-- | Somewhat, we ended up generating an invalid coin selection because of
--   inputs passed down to the coin selection function, or because a target
--   backend has extra-limitations not covered by our coin selection
--   algorithm.
ErrInvalidSelection :: e -> ErrCoinSelection e
data CoinSelectionOptions e
CoinSelectionOptions :: (Word8 -> Word8) -> (CoinSelection -> Either e ()) -> CoinSelectionOptions e

-- | Maximum number of inputs allowed for a given number of outputs
[maximumNumberOfInputs] :: CoinSelectionOptions e -> Word8 -> Word8

-- | Returns any backend-specific error regarding coin selection
[validate] :: CoinSelectionOptions e -> CoinSelection -> Either e ()
instance GHC.Classes.Eq e => GHC.Classes.Eq (Cardano.Wallet.Primitive.CoinSelection.ErrCoinSelection e)
instance GHC.Show.Show e => GHC.Show.Show (Cardano.Wallet.Primitive.CoinSelection.ErrCoinSelection e)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.CoinSelection.CoinSelectionOptions e)
instance GHC.Classes.Eq Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Show.Show Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Generics.Generic Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Base.Monoid Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.CoinSelection.CoinSelection


-- | This module contains the implementation of largestFirst input
--   selection algorithm
module Cardano.Wallet.Primitive.CoinSelection.LargestFirst

-- | Largest-first input selection policy
largestFirst :: forall m e. Monad m => CoinSelectionOptions e -> NonEmpty TxOut -> UTxO -> ExceptT (ErrCoinSelection e) m (CoinSelection, UTxO)


-- | This module contains the implementation of random input selection
--   algorithm
module Cardano.Wallet.Primitive.CoinSelection.Random

-- | Random-Improve Algorithm
--   
--   <ol>
--   <li>Randomly select outputs from the UTxO until the payment value is
--   covered. (In the rare case that this fails because the maximum number
--   of transaction inputs has been exceeded, fall back on the
--   largest-first algorithm for this step.)</li>
--   <li>The algorithm first makes a random selection for each output from
--   the UTxO, processing the biggest output first and proceeding in a
--   descending order. If the selection is not successful largest-first
--   fallback kicks in. If the selection is successful for each output then
--   the improvement is tried for each selection, once again starting from
--   the selection made for the biggest output. The improvement is tried
--   for the next biggest output's selection. An output is considered an
--   improvement when:</li>
--   </ol>
--   
--   (a) It doesn’t exceed a specified upper limit. (b) Adding the new
--   output gets us closer to the ideal change value. (c) It doesn’t exceed
--   a maximum number of transaction inputs.
--   
--   This algorithm follows three principles:
--   
--   <pre>
--   **Self organisation principle 1**
--   Random selection has a high probability of picking dust outputs precisely
--   when there is a lot of dust in the UTxO.
--   </pre>
--   
--   <pre>
--   **Self organisation principle 2**
--   If for each payment request for value <tt>x</tt> we create a change output roughly
--   of the same value <tt>x</tt>, then we will end up with a lot of change outputs in
--   our UTxO of size <tt>x</tt> precisely when we have a lot of payment requests of
--   size <tt>x</tt>
--   </pre>
--   
--   <pre>
--   **Self organisation principle 3**
--   Searching the UTxO for additional entries to improve our change output is
--   only useful if the UTxO contains entries that are sufficiently small enough.
--   But precisely when the UTxO contains many small entries, it is less likely
--   that a randomly chosen UTxO entry will push the total above the upper bound
--   we set.
--   </pre>
random :: forall m e. MonadRandom m => CoinSelectionOptions e -> NonEmpty TxOut -> UTxO -> ExceptT (ErrCoinSelection e) m (CoinSelection, UTxO)


-- | Primitives for performing address derivation for some given schemes.
--   This is where most of the crypto happens in the wallet and, it is
--   quite important to ensure that the implementations match with other
--   Cardano wallets (like cardano-sl, Yoroi/Icarus, or cardano-cli)
--   
--   The actual implementations are in the following modules:
--   
--   <ul>
--   <li><a>Cardano.Wallet.Primitive.AddressDerivation.Shelley</a></li>
--   <li><a>Cardano.Wallet.Primitive.AddressDerivation.Byron</a></li>
--   </ul>
module Cardano.Wallet.Primitive.AddressDerivation

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   m | purpose' | cointype' | account' | change | address
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   they are left out of the sum type.
data Depth
RootK :: Depth
AccountK :: Depth
AddressK :: Depth

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
newtype Index (derivationType :: DerivationType) (level :: Depth)
Index :: Word32 -> Index
[getIndex] :: Index -> Word32

-- | Marker for addresses type engaged. We want to handle three cases here.
--   The first two are pertinent to UTxO accounting and the last one
--   handles rewards from participation in staking. (a) external chain is
--   used for addresses that are part of the <tt>advertised</tt> targets of
--   a given transaction (b) internal change is for addresses used to
--   handle the change of a the transaction within a given wallet (c) the
--   addresses for a reward (chimeric) account
data AccountingStyle
UTxOExternal :: AccountingStyle
UTxOInternal :: AccountingStyle
MutableAccount :: AccountingStyle

-- | Type of derivation that should be used with the given indexes.
--   
--   In theory, we should only consider two derivation types: soft and
--   hard.
--   
--   However, historically, addresses in Cardano used to be generated
--   across the both soft and hard domain. We therefore introduce a
--   <a>WholeDomain</a> derivation type that is the exact union of
--   <a>Hardened</a> and <a>Soft</a>.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
WholeDomain :: DerivationType

-- | An interface for doing hard derivations from the root private key
class HardDerivation (key :: Depth -> * -> *) where {
    type family AddressIndexDerivationType key :: DerivationType;
}

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: HardDerivation key => Passphrase "encryption" -> key  'RootK XPrv -> Index  'Hardened  'AccountK -> key  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   It is preferred to use <a>deriveAddressPublicKey</a> whenever possible
--   to avoid having to manipulate passphrases and private keys.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: HardDerivation key => Passphrase "encryption" -> key  'AccountK XPrv -> AccountingStyle -> Index (AddressIndexDerivationType key)  'AddressK -> key  'AddressK XPrv

-- | An interface for doing soft derivations from an account public key
class HardDerivation key => SoftDerivation (key :: Depth -> * -> *)

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SoftDerivation key => key  'AccountK XPub -> AccountingStyle -> Index  'Soft  'AddressK -> key  'AddressK XPub

-- | Also known as a staking key, chimeric account is used in group-type
--   address for staking purposes. It is a public key of the account
--   address
newtype ChimericAccount
ChimericAccount :: ByteString -> ChimericAccount
[$sel:unChimericAccount:ChimericAccount] :: ChimericAccount -> ByteString

-- | Derive a reward account from a root private key. It is agreed by
--   standard that every HD wallet will use only a single reward account.
--   This account is located into a special derivation path and uses the
--   first index of that path.
deriveRewardAccount :: (HardDerivation k, Bounded (Index (AddressIndexDerivationType k)  'AddressK)) => Passphrase "encryption" -> k  'RootK XPrv -> k  'AddressK XPrv

-- | Construct a <a>ChimericAccount</a> by extracting the public key from
--   the extended public key.
toChimericAccount :: WalletKey k => k  'AddressK XPub -> ChimericAccount
data XPub
XPub :: !ByteString -> !ChainCode -> XPub
[xpubPublicKey] :: XPub -> !ByteString
[xpubChaincode] :: XPub -> !ChainCode
newtype ChainCode
ChainCode :: ByteString -> ChainCode
data XPrv
unXPub :: XPub -> ByteString
unXPrv :: XPrv -> ByteString
xprv :: ByteArrayAccess bin => bin -> Either String XPrv
xpub :: ByteString -> Either String XPub

-- | Encode a <a>ByteString</a> in base16
hex :: ByteArrayAccess bin => bin -> ByteString

-- | Decode a <a>ByteString</a> from base16
fromHex :: ByteArray bout => ByteString -> Either String bout

-- | Convert a <tt>XPrv</tt> to a 96-byte long extended private key that
--   does <i>not</i> include the public key.
--   
--   The format is:
--   
--   <pre>
--   Extended Private Key (64 bytes) &lt;&gt; ChainCode (32 bytes)
--   </pre>
--   
--   Does <i>not</i> guarantee that <tt>xPrvFromStrippedPubXPrv</tt> will
--   be able to reconstruct the same <tt>XPrv</tt> from the resulting
--   <tt>ByteString</tt>.
unXPrvStripPub :: XPrv -> ByteString

-- | Like <tt>unXPrvStripPub</tt>, but also checks that the result
--   roundtrips.
--   
--   Roundtrip may fail if: - the key is encrypted - the key is an old
--   byron key
unXPrvStripPubCheckRoundtrip :: XPrv -> Either ErrUnXPrvStripPub ByteString

-- | Create a <tt>XPrv</tt> from a 96-byte long extended private key
--   
--   The format is:
--   
--   <pre>
--   Extended Private Key (64 bytes) &lt;&gt; ChainCode (32 bytes)
--   </pre>
--   
--   This function uses
--   <tt>cardano-crypto:encryptedCreateDirectWithTweak</tt> which will
--   modify the key if certain bits are not cleared / set. Byron keys are
--   likely not to have the correct tweak.
--   
--   Byron keys would be silently modified.
xPrvFromStrippedPubXPrv :: ByteString -> Either ErrXPrvFromStrippedPubXPrv XPrv

-- | Like <tt>xPrvFromStrippedPubXPrv</tt>, but also checks that the result
--   roundtrips.
--   
--   Roundtrip may fail if: - the key is encrypted - the key is an old
--   byron key
xPrvFromStrippedPubXPrvCheckRoundtrip :: ByteString -> Either ErrXPrvFromStrippedPubXPrv XPrv
data ErrXPrvFromStrippedPubXPrv

-- | Expected, Actual
ErrInputLengthMismatch :: Int -> Int -> ErrXPrvFromStrippedPubXPrv
ErrCannotRoundtripToSameBytes :: ErrXPrvFromStrippedPubXPrv
data ErrUnXPrvStripPub

-- | The resulting bytestring would have been unable to roundtrip using
--   <tt>xPrvFromStrippedPubXPrv</tt>. Most likely because the input
--   <tt>XPrv</tt> was encrypted, or because it was an old (Byron) key.
ErrCannotRoundtripToSameXPrv :: ErrUnXPrvStripPub

-- | Small helper to collect <a>Nat</a> values from a type-level list
class NatVals (ns :: [Nat])
natVals :: NatVals ns => Proxy ns -> [Integer]

-- | Available network options.
data NetworkDiscriminant
Mainnet :: NetworkDiscriminant
Testnet :: NetworkDiscriminant
class NetworkDiscriminantVal (n :: NetworkDiscriminant)
networkDiscriminantVal :: NetworkDiscriminantVal n => NetworkDiscriminant

-- | Encoding of addresses for certain key types and backend targets.
class MkKeyFingerprint key Address => PaymentAddress (network :: NetworkDiscriminant) key

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
--   
--   Note that <a>paymentAddress</a> is ambiguous and requires therefore a
--   type application.
paymentAddress :: PaymentAddress network key => key  'AddressK XPub -> Address

-- | Lift a payment fingerprint back into a payment address.
liftPaymentAddress :: PaymentAddress network key => KeyFingerprint "payment" key -> Address
class PaymentAddress network key => DelegationAddress (network :: NetworkDiscriminant) key

-- | Convert a public key and a staking key to a delegation <a>Address</a>
--   valid for the given network discrimination. Funds sent to this address
--   will be delegated according to the delegation settings attached to the
--   delegation key.
--   
--   Note that <a>delegationAddress</a> is ambiguous and requires therefore
--   a type application.
delegationAddress :: DelegationAddress network key => key  'AddressK XPub -> key  'AddressK XPub -> Address

-- | Lift a payment fingerprint back into a delegation address.
liftDelegationAddress :: DelegationAddress network key => KeyFingerprint "payment" key -> key  'AddressK XPub -> Address
class WalletKey (key :: Depth -> * -> *)

-- | Re-encrypt a private key using a different passphrase.
--   
--   <ul>
--   <li>*Important**: This function doesn't check that the old passphrase
--   is correct! Caller is expected to have already checked that. Using an
--   incorrect passphrase here will lead to very bad thing.</li>
--   </ul>
changePassphrase :: WalletKey key => Passphrase "encryption-old" -> Passphrase "encryption-new" -> key depth XPrv -> key depth XPrv

-- | Extract the public key part of a private key.
publicKey :: WalletKey key => key depth XPrv -> key depth XPub

-- | Hash a public key to some other representation.
digest :: (WalletKey key, HashAlgorithm a) => key depth XPub -> Digest a

-- | Get a short, human-readable string descriptor that uniquely identifies
--   the specified key type.
keyTypeDescriptor :: WalletKey key => Proxy key -> String

-- | Unwrap the <a>WalletKey</a> to use the <a>XPrv</a> or <a>XPub</a>.
getRawKey :: WalletKey key => key depth raw -> raw

-- | Operations for saving a private key into a database, and restoring it
--   from a database. The keys should be encoded in hexadecimal strings.
class PersistPrivateKey (key :: * -> *)

-- | Convert a private key and its password hash into hexadecimal strings
--   suitable for storing in a text file or database column.
serializeXPrv :: PersistPrivateKey key => (key XPrv, Hash "encryption") -> (ByteString, ByteString)

-- | The reverse of <a>serializeXPrv</a>. This may fail if the inputs are
--   not valid hexadecimal strings, or if the key is of the wrong length.
unsafeDeserializeXPrv :: PersistPrivateKey key => (ByteString, ByteString) -> (key XPrv, Hash "encryption")

-- | Operations for saving a public key into a database, and restoring it
--   from a database. The keys should be encoded in hexadecimal strings.
class PersistPublicKey (key :: * -> *)

-- | Convert a private key and its password hash into hexadecimal strings
--   suitable for storing in a text file or database column.
serializeXPub :: PersistPublicKey key => key XPub -> ByteString

-- | Convert a public key into hexadecimal strings suitable for storing in
--   a text file or database column.
unsafeDeserializeXPub :: PersistPublicKey key => ByteString -> key XPub

-- | Produce <a>KeyFingerprint</a> for existing types. A fingerprint here
--   uniquely identifies part of an address. It can refer to either the
--   payment key or, if any, the delegation key of an address.
--   
--   The fingerprint obeys the following rules:
--   
--   <ul>
--   <li>If two addresses are the same, then they have the same
--   fingerprints</li>
--   <li>It is possible to lift the fingerprint back into an address</li>
--   </ul>
--   
--   This second rule pretty much fixes what can be chosen as a fingerprint
--   for various key types:
--   
--   <ol>
--   <li>For <tt>ByronKey</tt>, it can only be the address itself!</li>
--   <li>For <tt>ShelleyKey</tt>, then the "payment" fingerprint refers to
--   the payment key within a single or grouped address.</li>
--   </ol>
class Show from => MkKeyFingerprint (key :: Depth -> * -> *) from
paymentKeyFingerprint :: MkKeyFingerprint key from => from -> Either (ErrMkKeyFingerprint key from) (KeyFingerprint "payment" key)
data ErrMkKeyFingerprint key from
ErrInvalidAddress :: from -> Proxy key -> ErrMkKeyFingerprint key from

-- | Something that uniquely identifies a public key. Typically, a hash of
--   that key or the key itself.
newtype KeyFingerprint (s :: Symbol) key
KeyFingerprint :: ByteString -> KeyFingerprint key

-- | An encapsulated passphrase. The inner format is free, but the wrapper
--   helps readability in function signatures.
newtype Passphrase (purpose :: Symbol)
Passphrase :: ScrubbedBytes -> Passphrase
class PassphraseMinLength (purpose :: Symbol)

-- | Minimal Length for a passphrase, for lack of better validations
passphraseMinLength :: PassphraseMinLength purpose => Proxy purpose -> Int
class PassphraseMaxLength (purpose :: Symbol)

-- | Maximum length for a passphrase
passphraseMaxLength :: PassphraseMaxLength purpose => Proxy purpose -> Int
data SomeMnemonic
[SomeMnemonic] :: forall mw. KnownNat mw => Mnemonic mw -> SomeMnemonic

-- | Create a passphrase from a mnemonic sentence. This class enables
--   caller to parse text list of variable length into mnemonic sentences.
--   
--   <pre>
--   &gt;&gt;&gt; fromMnemonic @'[12,15,18,21] @"generation" ["toilet", "curse", ... ]
--   Right (Passphrase &lt;ScrubbedBytes&gt;)
--   </pre>
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
class FromMnemonic (sz :: [Nat])
fromMnemonic :: FromMnemonic sz => [Text] -> Either (FromMnemonicError sz) SomeMnemonic

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype FromMnemonicError (sz :: [Nat])
FromMnemonicError :: String -> FromMnemonicError
[getFromMnemonicError] :: FromMnemonicError -> String

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase

-- | Encrypt a <a>Passphrase</a> into a format that is suitable for storing
--   on disk
encryptPassphrase :: MonadRandom m => Passphrase purpose -> m (Hash purpose)

-- | Check whether a <a>Passphrase</a> matches with a stored <a>Hash</a>
checkPassphrase :: Passphrase purpose -> Hash purpose -> Either ErrWrongPassphrase ()
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.ErrXPrvFromStrippedPubXPrv
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.ErrXPrvFromStrippedPubXPrv
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.ErrUnXPrvStripPub
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.ErrUnXPrvStripPub
instance forall k (key :: k) from. GHC.Classes.Eq from => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.ErrMkKeyFingerprint key from)
instance forall k (key :: k) from. GHC.Show.Show from => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.ErrMkKeyFingerprint key from)
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Classes.Ord (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.ErrWrongPassphrase
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.ErrWrongPassphrase
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Base.Monoid (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Base.Semigroup (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.SomeMnemonic
instance forall k (s :: GHC.Types.Symbol) (key :: k). Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminantVal 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet
instance Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminantVal 'Cardano.Wallet.Primitive.AddressDerivation.Testnet
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic rest, Cardano.Wallet.Primitive.AddressDerivation.NatVals rest) => Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic (mw : rest)
instance Cardano.Wallet.Primitive.AddressDerivation.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Wallet.Primitive.AddressDerivation.NatVals rest) => Cardano.Wallet.Primitive.AddressDerivation.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic '[mw]
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.SomeMnemonic
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength "encryption"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength "encryption-old"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength "encryption-new"
instance (Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength purpose, Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength purpose) => Data.Text.Class.FromText (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength "encryption"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength "encryption-old"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength "encryption-new"
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance Crypto.Random.Types.MonadRandom ((->) (Cardano.Wallet.Primitive.AddressDerivation.Passphrase "salt"))
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.WholeDomain level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.WholeDomain level)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle


-- | An extra interface for operation on transactions (e.g. creating
--   witnesses, estimating size...). This makes it possible to decouple
--   those operations from our wallet layer, keeping the implementation
--   flexible to various backends.
module Cardano.Wallet.Transaction
data TransactionLayer t k
TransactionLayer :: ((Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkTx (Tx, SealedTx)) -> (PoolId -> (k  'AddressK XPrv, Passphrase "encryption") -> (Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkTx (Tx, SealedTx)) -> ((k  'AddressK XPrv, Passphrase "encryption") -> (Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkTx (Tx, SealedTx)) -> (CoinSelection -> Quantity "byte" Int) -> (Quantity "byte" Word16 -> Word8 -> Word8) -> (CoinSelection -> Either (ErrValidateSelection t) ()) -> (ByteString -> Either ErrDecodeSignedTx (Tx, SealedTx)) -> TransactionLayer t k

-- | Construct a standard transaction
--   
--   " Standard " here refers to the fact that we do not deal with
--   redemption, multisignature transactions, etc.
--   
--   This expects as a first argument a mean to compute or lookup private
--   key corresponding to a particular address.
[mkStdTx] :: TransactionLayer t k -> (Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkTx (Tx, SealedTx)

-- | Construct a transaction containing a certificate for delegating to a
--   stake pool.
--   
--   The certificate is a combination of the <a>PoolId</a> and the public
--   key of the reward account. (Note that this is an address key and HD
--   account keys are something different)
[mkDelegationJoinTx] :: TransactionLayer t k -> PoolId -> (k  'AddressK XPrv, Passphrase "encryption") -> (Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkTx (Tx, SealedTx)

-- | Construct a transaction containing a certificate for quiting from a
--   stake pool.
--   
--   The certificate is the public key of the reward account.
[mkDelegationQuitTx] :: TransactionLayer t k -> (k  'AddressK XPrv, Passphrase "encryption") -> (Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkTx (Tx, SealedTx)

-- | Estimate the size of a <a>CoinSelection</a>, in bytes. This operation
--   is seemingly coupled to the binary representation of a
--   <tt>Transaction</tt>. This estimation is therefore only a best-effort
--   here as many of the encoding values actually depends on the value of
--   parameters at runtime.
--   
--   For instance, with a CBOR encoding, an amount of `50` lovelace would
--   be encoded using 2 bytes, whereas an amount of `1000000` would be
--   encoded using 4 bytes. In Byron, we have only one piece of unknown
--   from the <a>CoinSelection</a> and it's the value of the <tt>crc32</tt>
--   computed on the address payload, which can be 1,2,3 or 5 bytes and we
--   therefore always consider the worst-case scenario of a 5-byte crc. As
--   a consequence, our estimate may be slightly bigger than the actual
--   transaction fee (up-to 4 extra bytes per change output).
[estimateSize] :: TransactionLayer t k -> CoinSelection -> Quantity "byte" Int

-- | Calculate a "theoretical" maximum number of inputs given a maximum
--   transaction size and desired number of outputs.
--   
--   The actual transaction size cannot be known until it has been fully
--   determined by coin selection.
--   
--   This estimate will err on the side of permitting more inputs,
--   resulting in a transaction which may be too large.
[estimateMaxNumberOfInputs] :: TransactionLayer t k -> Quantity "byte" Word16 -> Word8 -> Word8

-- | Validate coin selection regarding rules that may be specific to a
--   particular backend implementation.
--   
--   For example, Byron nodes do not allow null output amounts. Jörmungandr
--   on its side doesn't support more than 255 inputs or outputs.
[validateSelection] :: TransactionLayer t k -> CoinSelection -> Either (ErrValidateSelection t) ()

-- | Decode an externally-signed transaction to the chain producer
[decodeSignedTx] :: TransactionLayer t k -> ByteString -> Either ErrDecodeSignedTx (Tx, SealedTx)

-- | Possible signing error
newtype ErrMkTx

-- | We tried to sign a transaction with inputs that are unknown to us?
ErrKeyNotFoundForAddress :: Address -> ErrMkTx

-- | A type family for validations that are specific to a particular
--   backend type. This demands an instantiation of the family for a
--   particular backend:
--   
--   type instance (ErrValidateSelection MyBackend) = MyCustomError
type family ErrValidateSelection t

-- | Error while trying to decode externally signed transaction
data ErrDecodeSignedTx
ErrDecodeSignedTxWrongPayload :: Text -> ErrDecodeSignedTx
ErrDecodeSignedTxNotSupported :: ErrDecodeSignedTx
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrMkTx
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrMkTx
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrDecodeSignedTx
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrDecodeSignedTx


-- | This module contains types for address discovery. The two address
--   discovery schemes implemented are:
--   
--   <ul>
--   <li><a>Cardano.Wallet.Primitive.AddressDiscovery.Sequential</a></li>
--   <li><a>Cardano.Wallet.Primitive.AddressDiscovery.Random</a></li>
--   </ul>
module Cardano.Wallet.Primitive.AddressDiscovery

-- | Checks whether or not a given entity belongs to us.
--   
--   This abstraction exists to give us the ability to keep the wallet
--   business logic agnostic to the address derivation and discovery
--   mechanisms.
--   
--   This is needed because two different address schemes lives on Cardano:
--   
--   <ul>
--   <li>A hierarchical random scheme: rather <tt>custom</tt> made, with
--   several flaws; this is the original and now legacy address
--   scheme.</li>
--   <li>A hierarchical sequential scheme: a new scheme based on the
--   BIP-0044 specification, which is better suited for our present
--   needs.</li>
--   </ul>
--   
--   In practice, we will need a wallet that can support both, even if not
--   at the same time, and this little abstraction can buy us this without
--   introducing too much overhead.
class IsOurs s entity
isOurs :: IsOurs s entity => entity -> s -> (Bool, s)

-- | More powerful than <a>isOurs</a>, this abstractions offer the
--   underlying state the ability to find / compute the address private key
--   corresponding to a given known address.
--   
--   Requiring <a>IsOwned</a> as a constraint supposed that there is a way
--   to recover the root private key of a particular wallet. This isn't
--   true for externally owned wallet which would delegate its key
--   management to a third party (like a hardware Ledger or Trezor).
class IsOurs s Address => IsOwned s key
isOwned :: IsOwned s key => s -> (key  'RootK XPrv, Passphrase "encryption") -> Address -> Maybe (key  'AddressK XPrv, Passphrase "encryption")

-- | Abstracting over change address generation. In theory, this is only
--   needed for sending transactions on a wallet following a particular
--   scheme. This abstractions allows for defining an heuristic to pick new
--   change address. For instance, in BIP-44, change addresses belong to a
--   particular change chain (also called "Internal Chain").
class GenChange s where {
    type family ArgGenChange s :: *;
}
genChange :: GenChange s => ArgGenChange s -> s -> (Address, s)

-- | Ordering addresses by discovery date.
--   
--   If <tt>a1</tt> has been discovered before <tt>a2</tt>, then the
--   following equation holds:
--   
--   <pre>
--   compareDiscovery s a1 a2 == LT
--   </pre>
--   
--   If <tt>a1</tt> has been discovered after <tt>a2</tt>, then the
--   following equation holds:
--   
--   <pre>
--   compareDiscovery s a1 a2 == GT
--   </pre>
--   
--   Note that, if an address isn't known it is considered not discovered
--   and therefore, is always _greater than_ any known address.
class CompareDiscovery s
compareDiscovery :: CompareDiscovery s => s -> Address -> Address -> Ordering

-- | Extract the list of all known addresses.
--   
--   NOTE: Change addresses aren't considered "known" until they've been
--   used. The rationale is that, we don't want users or consumers of the
--   wallet to be using change addresses prematurely.
class KnownAddresses s
knownAddresses :: KnownAddresses s => s -> [Address]
class HasRewardAccount s where {
    type family RewardAccountKey s :: Depth -> * -> *;
}
rewardAccount :: HasRewardAccount s => s -> RewardAccountKey s  'AddressK XPub


-- | An implementation of address discovery for the sequential address
--   derivation scheme specified in BIP-0044.
--   
--   The management of _accounts_ is left-out for this implementation
--   focuses on a single account. In practice, one wants to manage a set of
--   pools, one per account.
module Cardano.Wallet.Primitive.AddressDiscovery.Sequential

-- | Maximum number of consecutive undiscovered addresses allowed
data AddressPoolGap

-- | Possible errors when casting to an <a>AddressPoolGap</a>
newtype MkAddressPoolGapError
ErrGapOutOfRange :: Integer -> MkAddressPoolGapError

-- | A default <a>AddressPoolGap</a>, as suggested in BIP-0044
defaultAddressPoolGap :: AddressPoolGap
getAddressPoolGap :: AddressPoolGap -> Word32

-- | Smart constructor for <a>AddressPoolGap</a>
mkAddressPoolGap :: Integer -> Either MkAddressPoolGapError AddressPoolGap

-- | Constructor which allows by-passing the address pool gap boundary
--   limitations. A practical use-case for this are sequential wallets for
--   which we don't have access to the whole history which therefore
--   require using arbitrary big gaps in order to discover addresses with
--   indexes separated by possible huge gaps.
--   
--   This defies a bit the purpose of this type though.
mkUnboundedAddressPoolGap :: Word32 -> AddressPoolGap

-- | An <a>AddressPool</a> which keeps track of sequential addresses within
--   a given Account and change chain. See <a>mkAddressPool</a> to create a
--   new or existing pool:
--   
--   <pre>
--   &gt;&gt;&gt; mkAddressPool xpub gap accountingStyle mempty
--   AddressPool { }
--   </pre>
data AddressPool (chain :: AccountingStyle) (key :: Depth -> * -> *)

-- | The actual gap for the pool. This can't change for a given pool.
gap :: AddressPool chain key -> AddressPoolGap

-- | Get all addresses in the pool, sorted from the first address
--   discovered, up until the next one.
--   
--   In practice, we always have:
--   
--   <pre>
--   mkAddressPool key g cc (addresses pool) == pool
--   </pre>
addresses :: forall c k. () => (KeyFingerprint "payment" k -> Address) -> AddressPool c k -> [Address]

-- | Bring a <a>AccountingStyle</a> type back to the term-level. This
--   requires a type application and either a scoped type variable, or an
--   explicit passing of a <a>AccountingStyle</a>.
--   
--   <pre>
--   &gt;&gt;&gt; accountingStyle @'UTxOExternal
--   UTxOExternal
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; accountingStyle @chain
--   ...
--   </pre>
accountingStyle :: forall (c :: AccountingStyle). Typeable c => AccountingStyle

-- | Corresponding key for the pool (a pool is tied to only one account)
accountPubKey :: AddressPool chain key -> key  'AccountK XPub

-- | Create a new Address pool from a list of addresses. Note that, the
--   list is expected to be ordered in sequence (first indexes, first in
--   the list).
--   
--   The pool will grow from the start if less than <tt>g ::
--   AddressPoolGap</tt> are given, such that, there are always <tt>g</tt>
--   undiscovered addresses in the pool.
--   
--   FIXME: Don't construct from addresses but from fingerprints!
mkAddressPool :: forall c k. (MkKeyFingerprint k (k  'AddressK XPub), MkKeyFingerprint k Address, SoftDerivation k, Typeable c) => k  'AccountK XPub -> AddressPoolGap -> [Address] -> AddressPool c k

-- | Lookup an address in the pool. When we find an address in a pool, the
--   pool may be amended if the address was discovered near the edge. It is
--   also possible that the pool is not amended at all - this happens in
--   the case that an address is discovered <tt>far</tt> from the edge.
lookupAddress :: forall c k. (MkKeyFingerprint k (k  'AddressK XPub), MkKeyFingerprint k Address, SoftDerivation k, Typeable c) => Address -> AddressPool c k -> (Maybe (Index  'Soft  'AddressK), AddressPool c k)
shrinkPool :: forall c key. (Typeable c, MkKeyFingerprint key Address, MkKeyFingerprint key (key  'AddressK XPub), SoftDerivation key) => (KeyFingerprint "payment" key -> Address) -> [Address] -> AddressPoolGap -> AddressPool c key -> AddressPool c key

-- | An ordered set of pending indexes. This keep track of indexes used
data PendingIxs

-- | An empty pending set of change indexes.
--   
--   NOTE: We do not define a <a>Monoid</a> instance here because there's
--   no rational of combining two pending sets.
emptyPendingIxs :: PendingIxs
pendingIxsToList :: PendingIxs -> [Index  'Soft  'AddressK]

-- | Construct a <a>PendingIxs</a> from a list, ensuring that it is a set
--   of indexes in descending order.
pendingIxsFromList :: [Index  'Soft  'AddressK] -> PendingIxs

-- | A state to keep track of sequential addresses as described in
--   <a>BIP-44</a>
--   
--   Internally, the state keeps track of a few things for us and is it is
--   parameterized by a type <tt>n</tt> which captures a particular network
--   discrimination. This enables the state to be agnostic to the
--   underlying address format.
data SeqState (n :: NetworkDiscriminant) k
SeqState :: !AddressPool  'UTxOInternal k -> !AddressPool  'UTxOExternal k -> !PendingIxs -> k  'AddressK XPub -> SeqState k

-- | Addresses living on the <a>UTxOInternal</a>
[internalPool] :: SeqState k -> !AddressPool  'UTxOInternal k

-- | Addresses living on the <a>UTxOExternal</a>
[externalPool] :: SeqState k -> !AddressPool  'UTxOExternal k

-- | Indexes from the internal pool that have been used in pending
--   transactions. The list is maintained sorted in descending order (cf:
--   <a>PendingIxs</a>)
[pendingChangeIxs] :: SeqState k -> !PendingIxs

-- | Reward account public key associated with this wallet
[rewardAccountKey] :: SeqState k -> k  'AddressK XPub

-- | Construct a Sequential state for a wallet from root private key and
--   password.
mkSeqStateFromRootXPrv :: forall n k. (SoftDerivation k, MkKeyFingerprint k (k  'AddressK XPub), MkKeyFingerprint k Address, WalletKey k, Bounded (Index (AddressIndexDerivationType k)  'AddressK)) => (k  'RootK XPrv, Passphrase "encryption") -> AddressPoolGap -> SeqState n k

-- | Construct a Sequential state for a wallet from public account key.
mkSeqStateFromAccountXPub :: forall n k. (SoftDerivation k, MkKeyFingerprint k (k  'AddressK XPub), MkKeyFingerprint k Address) => k  'AccountK XPub -> AddressPoolGap -> SeqState n k
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool chain key)
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.MkAddressPoolGapError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.MkAddressPoolGapError
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Show.Show (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool chain key)
instance GHC.Classes.Eq (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub) => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool chain key)
instance (GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint "payment" k)) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance (Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint "payment" k)) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK) => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance (Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation k, Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint k (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint k Cardano.Wallet.Primitive.Types.Address) => Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) Cardano.Wallet.Primitive.Types.Address
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey k => Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) Cardano.Wallet.Primitive.Types.ChimericAccount
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation k => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance (Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation k, Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint k (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint k Cardano.Wallet.Primitive.Types.Address, Cardano.Wallet.Primitive.AddressDerivation.AddressIndexDerivationType k Data.Type.Equality.~ 'Cardano.Wallet.Primitive.AddressDerivation.Soft) => Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) k
instance (Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint k (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint k Cardano.Wallet.Primitive.Types.Address, Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation k) => Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress n k => Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Cardano.Wallet.Primitive.AddressDiscovery.HasRewardAccount (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance Control.DeepSeq.NFData (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool chain key)
instance (Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK), Data.Typeable.Internal.Typeable chain) => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool chain key)
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap


-- | Implementation of address derivation for <tt>Shelley</tt> Keys.
--   Shelley really means Jörmungandr here.
module Cardano.Wallet.Primitive.AddressDerivation.Shelley

-- | A cryptographic key for Shelley address derivation, with phantom-types
--   to disambiguate derivation paths
--   
--   <pre>
--   let rootPrivateKey = ShelleyKey 'RootK XPrv
--   let accountPubKey = ShelleyKey 'AccountK XPub
--   let addressPubKey = ShelleyKey 'AddressK XPub
--   </pre>
newtype ShelleyKey (depth :: Depth) key
ShelleyKey :: key -> ShelleyKey key
[getKey] :: ShelleyKey key -> key

-- | The minimum seed length for <a>generateKeyFromSeed</a> and
--   <a>unsafeGenerateKeyFromSeed</a>.
minSeedLengthBytes :: Int

-- | Size, in bytes, of a public key (without chain code)
publicKeySize :: Int
addrSingleSize :: Int
addrGroupedSize :: Int

-- | Embed some constants into a network type.
class KnownNetwork (n :: NetworkDiscriminant)
addrSingle :: KnownNetwork n => Word8
addrGrouped :: KnownNetwork n => Word8
addrAccount :: KnownNetwork n => Word8
knownDiscriminants :: KnownNetwork n => [Word8]

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: (SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> ShelleyKey  'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: (SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> ShelleyKey depth XPrv
xpubFromText :: ByteString -> Either String XPub

-- | Verify the structure of a payload decoded from a Bech32 text string
decodeShelleyAddress :: forall n. (KnownNetwork n, NetworkDiscriminantVal n) => ByteString -> Either TextDecodingError Address
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Testnet Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress 'Cardano.Wallet.Primitive.AddressDerivation.Testnet Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.Shelley.KnownNetwork 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet
instance Cardano.Wallet.Primitive.AddressDerivation.Shelley.KnownNetwork 'Cardano.Wallet.Primitive.AddressDerivation.Testnet
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.HardDerivation Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey Cardano.Wallet.Primitive.Types.Address
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPrivateKey (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey 'Cardano.Wallet.Primitive.AddressDerivation.RootK)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth)


-- | This module contains instances and types necessary for storing wallets
--   in a SQL database with Persistent.
--   
--   It's in a separate module due to the GHC stage restriction.
--   
--   The ToJSON/FromJSON and Read instance orphans exist due to class
--   constraints on Persistent functions.
module Cardano.Wallet.DB.Sqlite.Types

-- | Settings for generating the Persistent types.
sqlSettings' :: MkPersistSettings

-- | <a>fromText</a> but with a simpler error type.
fromText' :: FromText a => Text -> Either Text a

-- | Aeson parser defined in terms of <a>fromText</a>
aesonFromText :: FromText a => String -> Value -> Parser a

-- | <a>fromPersistValue</a> defined in terms of <a>fromText</a>
fromPersistValueFromText :: FromText a => PersistValue -> Either Text a

-- | <a>fromPersistValue</a> defined in terms of the <a>Read</a> class
fromPersistValueRead :: Read a => PersistValue -> Either Text a
directionToBool :: Direction -> Bool
directionFromBool :: Bool -> Direction
newtype TxId
TxId :: Hash "Tx" -> TxId
[getTxId] :: TxId -> Hash "Tx"
newtype BlockId
BlockId :: Hash "BlockHeader" -> BlockId
[getBlockId] :: BlockId -> Hash "BlockHeader"

-- | As a short-to-medium term solution of persisting <a>SlotId</a>, we use
--   <a>flatSlot</a> with an artificial epochLength. I.e. /not the same
--   epochLength as the blockchain/. This is just for the sake of storing
--   the epoch number and slot number inside a single 64-bit field.
artificialEpochLength :: EpochLength
persistSlotId :: SlotId -> PersistValue
unPersistSlotId :: PersistValue -> Either Text SlotId
mkCoin :: Word64 -> Either Text Coin
newtype HDPassphrase
HDPassphrase :: Passphrase "addr-derivation-payload" -> HDPassphrase
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Classes.Ord Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Classes.Ord Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.PathPieces.PathPiece Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.TxId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DB.Sqlite.Types.TxId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.PathPieces.PathPiece Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Direction
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Direction
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.FeePolicy
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.FeePolicy
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.WalletId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.WalletId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.WalletId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.WalletId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.WalletId
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.SlotId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.SlotId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.SlotId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.SlotId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.SlotNo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.SlotNo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.EpochNo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.EpochNo
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.SlotId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.SlotId
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.SlotId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.TxStatus
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.TxStatus
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Coin
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Coin
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Address
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Address
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDerivation.AccountingStyle
instance Database.Persist.Class.PersistField.PersistField System.Random.StdGen
instance Database.Persist.Sql.Class.PersistFieldSql System.Random.StdGen
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.PoolId
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.PoolId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.PoolId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.PoolId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.PoolId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.PoolOwner
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.PoolOwner


-- | Auto-generated Sqlite &amp; Persistent machinery via Template-Haskell.
--   This has been moved into a separate file so that we can treat it
--   slightly differently when computing code-coverage.
--   
--   More than 6K lines end-up being generated from the instructions below!
--   As a result, we're going to ignore code-coverage on the following
--   module and, no hand-written functions should be written in this
--   module!
module Cardano.Wallet.DB.Sqlite.TH
data Wallet
Wallet :: !WalletId -> !UTCTime -> !Text -> !Maybe UTCTime -> Wallet
[walId] :: Wallet -> !WalletId
[walCreationTime] :: Wallet -> !UTCTime
[walName] :: Wallet -> !Text
[walPassphraseLastUpdatedAt] :: Wallet -> !Maybe UTCTime
type WalletId = Key Wallet
data PrivateKey
PrivateKey :: !WalletId -> !ByteString -> !ByteString -> PrivateKey
[privateKeyWalletId] :: PrivateKey -> !WalletId
[privateKeyRootKey] :: PrivateKey -> !ByteString
[privateKeyHash] :: PrivateKey -> !ByteString
type PrivateKeyId = Key PrivateKey
data TxMeta
TxMeta :: !TxId -> !WalletId -> !TxStatus -> !Direction -> !SlotId -> !Word32 -> !Natural -> TxMeta
[txMetaTxId] :: TxMeta -> !TxId
[txMetaWalletId] :: TxMeta -> !WalletId
[txMetaStatus] :: TxMeta -> !TxStatus
[txMetaDirection] :: TxMeta -> !Direction
[txMetaSlot] :: TxMeta -> !SlotId
[txMetaBlockHeight] :: TxMeta -> !Word32
[txMetaAmount] :: TxMeta -> !Natural
type TxMetaId = Key TxMeta
data TxIn
TxIn :: !TxId -> !Int -> !TxId -> !Word32 -> !Coin -> TxIn
[txInputTxId] :: TxIn -> !TxId
[txInputOrder] :: TxIn -> !Int
[txInputSourceTxId] :: TxIn -> !TxId
[txInputSourceIndex] :: TxIn -> !Word32
[txInputSourceAmount] :: TxIn -> !Coin
type TxInId = Key TxIn
data TxOut
TxOut :: !TxId -> !Word32 -> !Address -> !Coin -> TxOut
[txOutputTxId] :: TxOut -> !TxId
[txOutputIndex] :: TxOut -> !Word32
[txOutputAddress] :: TxOut -> !Address
[txOutputAmount] :: TxOut -> !Coin
type TxOutId = Key TxOut
data Checkpoint
Checkpoint :: !WalletId -> !SlotId -> !BlockId -> !BlockId -> !Word32 -> !BlockId -> !UTCTime -> !FeePolicy -> !Word64 -> !Word32 -> !Word16 -> !Word32 -> !Double -> Checkpoint
[checkpointWalletId] :: Checkpoint -> !WalletId
[checkpointSlot] :: Checkpoint -> !SlotId
[checkpointHeaderHash] :: Checkpoint -> !BlockId
[checkpointParentHash] :: Checkpoint -> !BlockId
[checkpointBlockHeight] :: Checkpoint -> !Word32
[checkpointGenesisHash] :: Checkpoint -> !BlockId
[checkpointGenesisStart] :: Checkpoint -> !UTCTime
[checkpointFeePolicy] :: Checkpoint -> !FeePolicy
[checkpointSlotLength] :: Checkpoint -> !Word64
[checkpointEpochLength] :: Checkpoint -> !Word32
[checkpointTxMaxSize] :: Checkpoint -> !Word16
[checkpointEpochStability] :: Checkpoint -> !Word32
[checkpointActiveSlotCoeff] :: Checkpoint -> !Double
type CheckpointId = Key Checkpoint
data DelegationCertificate
DelegationCertificate :: !WalletId -> !SlotId -> !Maybe PoolId -> DelegationCertificate
[certWalletId] :: DelegationCertificate -> !WalletId
[certSlot] :: DelegationCertificate -> !SlotId
[certPoolId] :: DelegationCertificate -> !Maybe PoolId
type DelegationCertificateId = Key DelegationCertificate
data UTxO
UTxO :: !WalletId -> !SlotId -> !TxId -> !Word32 -> !Address -> !Coin -> UTxO
[utxoWalletId] :: UTxO -> !WalletId
[utxoSlot] :: UTxO -> !SlotId
[utxoInputId] :: UTxO -> !TxId
[utxoInputIndex] :: UTxO -> !Word32
[utxoOutputAddress] :: UTxO -> !Address
[utxoOutputCoin] :: UTxO -> !Coin
type UTxOId = Key UTxO
data SeqState
SeqState :: !WalletId -> !AddressPoolGap -> !AddressPoolGap -> !ByteString -> !ByteString -> SeqState
[seqStateWalletId] :: SeqState -> !WalletId
[seqStateExternalGap] :: SeqState -> !AddressPoolGap
[seqStateInternalGap] :: SeqState -> !AddressPoolGap
[seqStateAccountXPub] :: SeqState -> !ByteString
[seqStateRewardXPub] :: SeqState -> !ByteString
type SeqStateId = Key SeqState
data SeqStateAddress
SeqStateAddress :: !WalletId -> !SlotId -> !Address -> !Word32 -> !AccountingStyle -> SeqStateAddress
[seqStateAddressWalletId] :: SeqStateAddress -> !WalletId
[seqStateAddressSlot] :: SeqStateAddress -> !SlotId
[seqStateAddressAddress] :: SeqStateAddress -> !Address
[seqStateAddressIndex] :: SeqStateAddress -> !Word32
[seqStateAddressAccountingStyle] :: SeqStateAddress -> !AccountingStyle
type SeqStateAddressId = Key SeqStateAddress
data SeqStatePendingIx
SeqStatePendingIx :: !WalletId -> !Word32 -> SeqStatePendingIx
[seqStatePendingWalletId] :: SeqStatePendingIx -> !WalletId
[seqStatePendingIxIndex] :: SeqStatePendingIx -> !Word32
type SeqStatePendingIxId = Key SeqStatePendingIx
data RndState
RndState :: !WalletId -> !Word32 -> !StdGen -> !HDPassphrase -> RndState
[rndStateWalletId] :: RndState -> !WalletId
[rndStateAccountIndex] :: RndState -> !Word32
[rndStateGen] :: RndState -> !StdGen
[rndStateHdPassphrase] :: RndState -> !HDPassphrase
type RndStateId = Key RndState
data RndStateAddress
RndStateAddress :: !WalletId -> !SlotId -> !Word32 -> !Word32 -> !Address -> RndStateAddress
[rndStateAddressWalletId] :: RndStateAddress -> !WalletId
[rndStateAddressSlot] :: RndStateAddress -> !SlotId
[rndStateAddressAccountIndex] :: RndStateAddress -> !Word32
[rndStateAddressIndex] :: RndStateAddress -> !Word32
[rndStateAddressAddress] :: RndStateAddress -> !Address
type RndStateAddressId = Key RndStateAddress
data RndStatePendingAddress
RndStatePendingAddress :: !WalletId -> !Word32 -> !Word32 -> !Address -> RndStatePendingAddress
[rndStatePendingAddressWalletId] :: RndStatePendingAddress -> !WalletId
[rndStatePendingAddressAccountIndex] :: RndStatePendingAddress -> !Word32
[rndStatePendingAddressIndex] :: RndStatePendingAddress -> !Word32
[rndStatePendingAddressAddress] :: RndStatePendingAddress -> !Address
type RndStatePendingAddressId = Key RndStatePendingAddress
migrateAll :: Migration
rnd_state_pending_address :: RndStatePendingAddress -> Key Wallet
rnd_state_address :: RndStateAddress -> Key Checkpoint
rnd_state :: RndState -> Key Wallet
seq_state_address_pending :: SeqStatePendingIx -> Key Wallet
seq_state_address :: SeqStateAddress -> Key Checkpoint
seq_state :: SeqState -> Key Wallet
utxo :: UTxO -> Key Checkpoint
delegationCertificate :: DelegationCertificate -> Key Wallet
checkpoint :: Checkpoint -> Key Wallet
fk_wallet_tx_meta :: TxMeta -> Key Wallet
fk_wallet_private_key :: PrivateKey -> Key Wallet
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.RndState
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.RndState
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.SeqState
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.SeqState
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.UTxO
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.UTxO
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.TxOut
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.TxOut
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.TxIn
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.TxIn
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.Wallet
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.RndStateAddress Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.RndStateAddress backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.RndState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.RndState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.RndState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.RndState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.RndState
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.RndState Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.RndState backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.SeqState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.SeqState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.SeqState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.SeqState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.SeqState
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.SeqState Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.SeqState backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.UTxO
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.UTxO
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.UTxO
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.UTxO
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.UTxO
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.UTxO Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.UTxO backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.DelegationCertificate backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.Checkpoint Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.Checkpoint backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.TxOut
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.TxOut
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.TxOut
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.TxOut
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.TxOut
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.TxOut Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.TxOut backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.TxIn
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.TxIn
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.TxIn
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.TxIn
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.TxIn
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.TxIn Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.TxIn backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.TxMeta Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.TxMeta backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.PrivateKey Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.PrivateKey backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.Wallet
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.Wallet
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.Wallet
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.Wallet
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.TH.Wallet
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.Wallet Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.Wallet backend


-- | This module contains a function for downloading stake pool metadata
--   from an external registry.
module Cardano.Pool.Metadata

-- | Information about a stake pool, published by a stake pool owner in the
--   stake pool registry.
--   
--   The wallet searches for registrations involving the owner, to find
--   metadata for a given PoolID.
--   
--   The metadata information is not used directly by cardano-wallet, but
--   rather passed straight through to API consumers.
data StakePoolMetadata
StakePoolMetadata :: PoolOwner -> StakePoolTicker -> Text -> Maybe Text -> Text -> Text -> StakePoolMetadata

-- | Bech32-encoded ed25519 public key.
[owner] :: StakePoolMetadata -> PoolOwner

-- | Very short human-readable ID for the stake pool.
[ticker] :: StakePoolMetadata -> StakePoolTicker

-- | Name of the stake pool.
[name] :: StakePoolMetadata -> Text

-- | Short description of the stake pool.
[description] :: StakePoolMetadata -> Maybe Text

-- | Absolute URL for the stake pool's homepage link.
[homepage] :: StakePoolMetadata -> Text

-- | Bech32-encoded address.
[pledgeAddress] :: StakePoolMetadata -> Text

-- | Returns <a>True</a> iff metadata is exactly equal, modulo
--   <a>PoolOwner</a>.
sameStakePoolMetadata :: StakePoolMetadata -> StakePoolMetadata -> Bool

-- | Very short name for a stake pool.
data StakePoolTicker

-- | Configuration parameters used by <a>getStakePoolMetadata</a>.
data MetadataConfig
MetadataConfig :: FilePath -> String -> NominalDiffTime -> String -> MetadataConfig

-- | Directory where the cache is stored
[cacheDirectory] :: MetadataConfig -> FilePath

-- | Name of zip archive.
[cacheName] :: MetadataConfig -> String

-- | A constant for the maximum age of cached registry file before it's
--   considered to be stale.
[cacheTTL] :: MetadataConfig -> NominalDiffTime

-- | URL to use to download registry
[registryURL] :: MetadataConfig -> String

-- | Filepath to the zip archive
cacheArchive :: MetadataConfig -> FilePath

-- | Returns the configuration for fetching metadata.
--   
--   <a>registryURL</a> will be the Cardano Foundation stake pool registry
--   zipfile URL, or the <tt>CARDANO_WALLET_STAKE_POOL_REGISTRY_URL</tt>
--   environment variable if it is set.
--   
--   The default <a>cacheTTL</a> is one hour.
getMetadataConfig :: FilePath -> IO MetadataConfig

-- | Associate a list of stake pool IDs with their metadata (if present),
--   which is downloaded from the given URL.
--   
--   The URL must point to a zip archive, with the following stucture:
--   
--   <pre>
--   master.zip
--   └── testnet-stake-pool-registry-master/
--       └── registry/
--           ├── pk1afhcpw2tg7nr2m3wr4x8jaa4dv7d09gnv27kwfxpjyvukwxs8qdqwg85xp.json
--           └── pk1z4vh8gva25w07x8574uujuveu8gz43fu6qfln3t4prcavrvcphjsk0pdqs.json
--   </pre>
--   
--   <ul>
--   <li>The name of the top-level directory can be anything.</li>
--   <li>Other files in the archive are ignored by
--   <a>getStakePoolMetadata</a>.</li>
--   <li>The JSON file names are <a>PoolOwner</a>s.</li>
--   <li>The required JSON structure is given by the
--   <a>Data.Aeson.FromJSON</a> instance of <a>StakePoolMetadata</a>.</li>
--   </ul>
--   
--   The URL which should be used for incentived testnet is
--   <a>cardanoFoundationRegistryZip</a>.
--   
--   The returned list will have the same length as the given list of
--   <a>PoolOwner</a>. If an metadata entry does not exist or could not be
--   parsed, it will be <a>Nothing</a>.
getStakePoolMetadata :: Tracer IO RegistryLog -> MetadataConfig -> [PoolOwner] -> IO (Either FetchError [Maybe StakePoolMetadata])

-- | Name of the environment variable to set for tweaking the registry URL.
--   Mostly use for testing.
envVarMetadataRegistry :: String

-- | The stake pool registry zipfile download URL for CF.
cardanoFoundationRegistryZip :: String

-- | Things that could go wrong with fetching metadata, which aren't
--   programming errors or expected failures.
data FetchError

-- | Failed to download the registry archive.
FetchErrorDownload :: String -> FetchError

-- | Failed to store the registry archive in a temporary location.
FetchErrorFile :: String -> FetchError

-- | Failed to open the registry archive with the given path, as a zip
--   file, due to the given cause.
FetchErrorZipParsingFailed :: FilePath -> String -> FetchError

-- | The log messages for <a>getStakePoolMetadata</a>.
data RegistryLog
RegistryLog :: String -> FilePath -> RegistryLogMsg -> RegistryLog
[registryLogUrl] :: RegistryLog -> String
[registryLogZipFile] :: RegistryLog -> FilePath
[registryLogMsg] :: RegistryLog -> RegistryLogMsg

-- | Log messages about processing a specific archive.
data RegistryLogMsg
MsgDownloadStarted :: RegistryLogMsg
MsgDownloadComplete :: Integer -> RegistryLogMsg
MsgDownloadError :: FetchError -> RegistryLogMsg
MsgCleanupDownload :: RegistryLogMsg
MsgExtractFile :: FilePath -> RegistryLogMsg
MsgExtractFileResult :: Maybe (Either String StakePoolMetadata) -> RegistryLogMsg
MsgUsingCached :: FilePath -> UTCTime -> RegistryLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Pool.Metadata.RegistryLog
instance GHC.Classes.Eq Cardano.Pool.Metadata.RegistryLog
instance GHC.Show.Show Cardano.Pool.Metadata.RegistryLog
instance GHC.Generics.Generic Cardano.Pool.Metadata.RegistryLog
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Pool.Metadata.RegistryLogMsg
instance GHC.Classes.Eq Cardano.Pool.Metadata.RegistryLogMsg
instance GHC.Show.Show Cardano.Pool.Metadata.RegistryLogMsg
instance GHC.Generics.Generic Cardano.Pool.Metadata.RegistryLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Pool.Metadata.FetchError
instance GHC.Generics.Generic Cardano.Pool.Metadata.FetchError
instance GHC.Classes.Eq Cardano.Pool.Metadata.FetchError
instance GHC.Show.Show Cardano.Pool.Metadata.FetchError
instance GHC.Classes.Eq Cardano.Pool.Metadata.MetadataConfig
instance GHC.Show.Show Cardano.Pool.Metadata.MetadataConfig
instance GHC.Generics.Generic Cardano.Pool.Metadata.StakePoolMetadata
instance GHC.Show.Show Cardano.Pool.Metadata.StakePoolMetadata
instance GHC.Classes.Eq Cardano.Pool.Metadata.StakePoolMetadata
instance Data.Text.Class.ToText Cardano.Pool.Metadata.StakePoolTicker
instance GHC.Classes.Eq Cardano.Pool.Metadata.StakePoolTicker
instance GHC.Show.Show Cardano.Pool.Metadata.StakePoolTicker
instance GHC.Generics.Generic Cardano.Pool.Metadata.StakePoolTicker
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.Pool.Metadata.RegistryLog
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.Pool.Metadata.RegistryLog
instance Data.Text.Class.ToText Cardano.Pool.Metadata.RegistryLog
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.Pool.Metadata.RegistryLogMsg
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.Pool.Metadata.RegistryLogMsg
instance Data.Text.Class.ToText Cardano.Pool.Metadata.RegistryLogMsg
instance Data.Text.Class.ToText Cardano.Pool.Metadata.FetchError
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Pool.Metadata.StakePoolMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Pool.Metadata.StakePoolMetadata
instance Data.Text.Class.FromText Cardano.Pool.Metadata.StakePoolTicker
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Pool.Metadata.StakePoolTicker
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Pool.Metadata.StakePoolTicker


-- | Auto-generated Sqlite &amp; Persistent machinery via Template-Haskell.
--   This has been moved into a separate file so that we can treat it
--   slightly differently when computing code-coverage.
module Cardano.Pool.DB.Sqlite.TH
data ArbitrarySeed
ArbitrarySeed :: !StdGen -> ArbitrarySeed
[seedSeed] :: ArbitrarySeed -> !StdGen
type ArbitrarySeedId = Key ArbitrarySeed
data PoolProduction
PoolProduction :: !PoolId -> !SlotId -> !BlockId -> !BlockId -> !Word32 -> PoolProduction
[poolProductionPoolId] :: PoolProduction -> !PoolId
[poolProductionSlot] :: PoolProduction -> !SlotId
[poolProductionHeaderHash] :: PoolProduction -> !BlockId
[poolProductionParentHash] :: PoolProduction -> !BlockId
[poolProductionBlockHeight] :: PoolProduction -> !Word32
type PoolProductionId = Key PoolProduction
data StakeDistribution
StakeDistribution :: !PoolId -> !Word64 -> !Word64 -> StakeDistribution
[stakeDistributionPoolId] :: StakeDistribution -> !PoolId
[stakeDistributionEpoch] :: StakeDistribution -> !Word64
[stakeDistributionStake] :: StakeDistribution -> !Word64
type StakeDistributionId = Key StakeDistribution
data PoolOwner
PoolOwner :: !PoolId -> !PoolOwner -> !Word8 -> PoolOwner
[poolOwnerPoolId] :: PoolOwner -> !PoolId
[poolOwnerOwner] :: PoolOwner -> !PoolOwner
[poolOwnerIndex] :: PoolOwner -> !Word8
type PoolOwnerId = Key PoolOwner
data PoolRegistration
PoolRegistration :: !PoolId -> !SlotId -> !Word64 -> !Word64 -> !Word64 -> PoolRegistration
[poolRegistrationPoolId] :: PoolRegistration -> !PoolId
[poolRegistrationSlot] :: PoolRegistration -> !SlotId
[poolRegistrationMarginNumerator] :: PoolRegistration -> !Word64
[poolRegistrationMarginDenominator] :: PoolRegistration -> !Word64
[poolRegistrationCost] :: PoolRegistration -> !Word64
type PoolRegistrationId = Key PoolRegistration
migrateAll :: Migration
fk_registration_pool_id :: PoolOwner -> Key PoolRegistration
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Pool.DB.Sqlite.TH.PoolRegistration Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Pool.DB.Sqlite.TH.PoolRegistration backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Pool.DB.Sqlite.TH.PoolOwner Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Pool.DB.Sqlite.TH.PoolOwner backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Pool.DB.Sqlite.TH.StakeDistribution Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Pool.DB.Sqlite.TH.StakeDistribution backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Pool.DB.Sqlite.TH.PoolProduction Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Pool.DB.Sqlite.TH.PoolProduction backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed backend


-- | Here we find the "business logic" to manage a Cardano wallet. This is
--   a direct implementation of the model from the <a>Formal Specification
--   for a Cardano Wallet</a> Note that, this module is purposedly agnostic
--   to how blocks are retrieved or how various types are serialized.
--   
--   This is really about how the wallet keep track of its internal state,
--   and its UTxO (where the relationship is defined via the <a>IsOurs</a>
--   abstraction to allow this core code to be used with any sort of
--   derivation scheme).
--   
--   All those functions are pure and there's no reason to shove in any
--   sort of side-effects in here :)
module Cardano.Wallet.Primitive.Model

-- | An opaque wallet type, see <a>initWallet</a>, <a>updateState</a>,
--   <a>applyBlock</a>, and <a>applyBlocks</a> to construct and update
--   wallets.
--   
--   Internally, this keeps track or a few things including:
--   
--   <ul>
--   <li>UTxOs</li>
--   <li>Transaction history</li>
--   <li>Known &amp; used addresses, via address discovery state</li>
--   <li>Blockchain parameters</li>
--   </ul>
--   
--   The <a>Wallet</a> is parameterized over two types:
--   
--   <ul>
--   <li><tt>s</tt>: A _state_ used to keep track of known addresses. The
--   business logic doesn't know how to answer the question 'Is this
--   address ours?', so we expect this state to be able to answer that for
--   us.</li>
--   <li><tt>t</tt>: A target backend. This makes the wallet fairly
--   agnostic to the type of binary representation used by the underlying
--   target network and it allows us to re-use the same logic to provide a
--   wallet backend for multiple backends (for instance, Byron or Shelley)
--   which may have divergence in their binary formats. For the sake of
--   this module, we only care about one particular super-power, and its
--   the ability to compute transaction id (which is intrinsically linked
--   to the transaction's binary format).</li>
--   </ul>
--   
--   A few examples to make it concrete:
--   
--   <pre>
--   Wallet RndState Byron
--   Wallet SeqState Shelley
--   Wallet SeqState Bitcoin
--   </pre>
data Wallet s

-- | Represents the subset of data from a single block that are relevant to
--   a particular wallet, discovered when applying a block to that wallet.
data FilteredBlock
FilteredBlock :: ![DelegationCertificate] -> ![(Tx, TxMeta)] -> FilteredBlock

-- | Stake delegations made on behalf of the wallet, listed in order of
--   discovery. If the list contains more than element, those that appear
--   later in the list supercede those that appear earlier on.
[$sel:delegations:FilteredBlock] :: FilteredBlock -> ![DelegationCertificate]

-- | The set of transactions that affect the wallet.
[$sel:transactions:FilteredBlock] :: FilteredBlock -> ![(Tx, TxMeta)]

-- | Create a an empty wallet and apply the given genesis block
--   
--   The wallet tip will be set to the header of the applied genesis block.
initWallet :: (IsOurs s Address, IsOurs s ChimericAccount, NFData s, Show s) => Block -> BlockchainParameters -> s -> ([(Tx, TxMeta)], Wallet s)

-- | Update the state of an existing Wallet model
updateState :: (IsOurs s Address, NFData s, Show s) => s -> Wallet s -> Wallet s

-- | Apply a single block to a wallet.
--   
--   This is the primary way of making a wallet evolve.
--   
--   Returns an updated wallet, as well as the set of data relevant to the
--   wallet that were discovered while applying the block.
applyBlock :: Block -> Wallet s -> (FilteredBlock, Wallet s)

-- | Apply multiple blocks in sequence to an existing wallet, returning a
--   list of intermediate wallet states.
--   
--   Each intermediate wallet state is paired with the set of transactions
--   that belong to that state but not the previous state.
--   
--   For an original wallet state <b><tt>w</tt></b> and a list of blocks
--   <b><tt>b</tt></b> such that:
--   
--   <pre>
--   b = [b1, b2, ..., bn]
--   </pre>
--   
--   Returns the following list of updates:
--   
--   <pre>
--   [ (t b1, w + b1)
--   , (t b2, w + b1 + b2)
--   , ...
--   , (t bn, w + b1 + b2 + ... + bn) ]
--   </pre>
--   
--   Where:
--   
--   <ul>
--   <li><b><tt>(t bi)</tt></b> is the set of transactions contained within
--   block <b><tt>bi</tt></b>.</li>
--   <li><b><tt>(w + bi)</tt></b> is the wallet state after applying block
--   <b><tt>bi</tt></b> to wallet <b><tt>w</tt></b>.</li>
--   </ul>
applyBlocks :: NonEmpty Block -> Wallet s -> NonEmpty (FilteredBlock, Wallet s)

-- | Constructs a wallet from the exact given state. Using this function
--   instead of <a>initWallet</a> and <a>applyBlock</a> allows the wallet
--   invariants to be broken. Therefore it should only be used in the
--   special case of loading wallet checkpoints from the database (where it
--   is assumed a valid wallet was stored into the database).
unsafeInitWallet :: (IsOurs s Address, IsOurs s ChimericAccount, NFData s, Show s) => UTxO -> BlockHeader -> s -> BlockchainParameters -> Wallet s

-- | Get the wallet current tip
currentTip :: Wallet s -> BlockHeader

-- | Get the wallet current state
getState :: Wallet s -> s

-- | Available balance = <a>balance</a> . <a>availableUTxO</a>
availableBalance :: Set Tx -> Wallet s -> Natural

-- | Total balance = <a>balance</a> . <a>totalUTxO</a>
totalBalance :: Set Tx -> Wallet s -> Natural

-- | Total UTxO = <a>availableUTxO</a> <tt>&lt;&gt;</tt> <a>changeUTxO</a>
totalUTxO :: Set Tx -> Wallet s -> UTxO

-- | Available UTxO = <tt>pending ⋪ utxo</tt>
availableUTxO :: Set Tx -> Wallet s -> UTxO

-- | Actual utxo
utxo :: Wallet s -> UTxO

-- | Get the current chain parameters.
--   
--   Parameters may change over time via protocol updates, so we keep track
--   of them as part of the wallet checkpoints.
blockchainParameters :: Wallet s -> BlockchainParameters
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Model.FilteredBlock
instance GHC.Show.Show Cardano.Wallet.Primitive.Model.FilteredBlock
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Model.FilteredBlock
instance GHC.Show.Show (Cardano.Wallet.Primitive.Model.Wallet s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Cardano.Wallet.Primitive.Model.Wallet s)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Model.Wallet s)
instance Formatting.Buildable.Buildable s => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Model.Wallet s)


-- | An implementation of the wallet database using only pure functions.
--   
--   These functions and types model the behaviour of the SQLite database
--   backend, and are used for QuickCheck state machine testing, and the
--   MVar database backend.
module Cardano.Wallet.DB.Model

-- | Model database, parameterised by the wallet ID type, the wallet AD
--   state type, the target backend, and the private key type.
--   
--   Tne type parameters exist so that simpler mock types can be used in
--   place of actual wallet types.
data Database wid s xprv
Database :: !Map wid (WalletDatabase s xprv) -> Map (Hash "Tx") Tx -> Database wid s xprv

-- | Wallet-related information.
[$sel:wallets:Database] :: Database wid s xprv -> !Map wid (WalletDatabase s xprv)

-- | In the database, transactions are global and not associated with any
--   particular wallet.
[$sel:txs:Database] :: Database wid s xprv -> Map (Hash "Tx") Tx

-- | Model database record for a single wallet.
data WalletDatabase s xprv
WalletDatabase :: !Map SlotId (Wallet s) -> !Map SlotId (Maybe PoolId) -> !WalletMetadata -> !Map (Hash "Tx") TxMeta -> !Maybe xprv -> WalletDatabase s xprv
[$sel:checkpoints:WalletDatabase] :: WalletDatabase s xprv -> !Map SlotId (Wallet s)
[$sel:certificates:WalletDatabase] :: WalletDatabase s xprv -> !Map SlotId (Maybe PoolId)
[$sel:metadata:WalletDatabase] :: WalletDatabase s xprv -> !WalletMetadata
[$sel:txHistory:WalletDatabase] :: WalletDatabase s xprv -> !Map (Hash "Tx") TxMeta
[$sel:xprv:WalletDatabase] :: WalletDatabase s xprv -> !Maybe xprv

-- | Produces an empty model database.
emptyDatabase :: Ord wid => Database wid s xprv

-- | Shorthand for the readTxHistory result type.
type TxHistory = [(Tx, TxMeta)]

-- | Shorthand for the putTxHistory argument type.
type TxHistoryMap = Map (Hash "Tx") (Tx, TxMeta)

-- | Apply optional filters on slotId and sort using the default sort order
--   (first time/slotId, then by TxId) to a <a>TxHistory</a>.
filterTxHistory :: SortOrder -> Range SlotId -> TxHistory -> TxHistory

-- | A database model operation, which is a function that takes a database
--   and returns: * a value, which is a query of the database, or an error;
--   and * a (possibly) modified database.
type ModelOp wid s xprv a = Database wid s xprv -> (Either (Err wid) a, Database wid s xprv)

-- | All of the possible errors that any of the model database functions
--   might return.
data Err wid
NoSuchWallet :: wid -> Err wid
WalletAlreadyExists :: wid -> Err wid
CannotRemovePendingTx :: ErrErasePendingTx wid -> Err wid
data ErrErasePendingTx wid
ErrErasePendingTxNoSuchWallet :: wid -> ErrErasePendingTx wid
ErrErasePendingTxNoTx :: Hash "Tx" -> ErrErasePendingTx wid
ErrErasePendingTxNoPendingTx :: Hash "Tx" -> ErrErasePendingTx wid
mCleanDB :: Ord wid => ModelOp wid s xprv ()
mInitializeWallet :: forall wid s xprv. Ord wid => wid -> Wallet s -> WalletMetadata -> TxHistory -> ModelOp wid s xprv ()
mRemoveWallet :: Ord wid => wid -> ModelOp wid s xprv ()
mListWallets :: Ord wid => ModelOp wid s xprv [wid]
mPutCheckpoint :: Ord wid => wid -> Wallet s -> ModelOp wid s xprv ()
mReadCheckpoint :: Ord wid => wid -> ModelOp wid s xprv (Maybe (Wallet s))
mListCheckpoints :: Ord wid => wid -> ModelOp wid s xprv [BlockHeader]
mRollbackTo :: Ord wid => wid -> SlotId -> ModelOp wid s xprv SlotId
mPutWalletMeta :: Ord wid => wid -> WalletMetadata -> ModelOp wid s xprv ()
mReadWalletMeta :: Ord wid => wid -> ModelOp wid s xprv (Maybe WalletMetadata)
mPutDelegationCertificate :: Ord wid => wid -> DelegationCertificate -> SlotId -> ModelOp wid s xprv ()
mPutTxHistory :: forall wid s xprv. Ord wid => wid -> TxHistory -> ModelOp wid s xprv ()
mReadTxHistory :: forall wid s xprv. Ord wid => wid -> SortOrder -> Range SlotId -> Maybe TxStatus -> ModelOp wid s xprv TxHistory
mPutPrivateKey :: Ord wid => wid -> xprv -> ModelOp wid s xprv ()
mReadPrivateKey :: Ord wid => wid -> ModelOp wid s xprv (Maybe xprv)
mRemovePendingTx :: Ord wid => wid -> Hash "Tx" -> ModelOp wid s xprv ()
instance Data.Traversable.Traversable Cardano.Wallet.DB.Model.Err
instance Data.Foldable.Foldable Cardano.Wallet.DB.Model.Err
instance GHC.Base.Functor Cardano.Wallet.DB.Model.Err
instance GHC.Classes.Eq wid => GHC.Classes.Eq (Cardano.Wallet.DB.Model.Err wid)
instance GHC.Show.Show wid => GHC.Show.Show (Cardano.Wallet.DB.Model.Err wid)
instance Data.Traversable.Traversable Cardano.Wallet.DB.Model.ErrErasePendingTx
instance Data.Foldable.Foldable Cardano.Wallet.DB.Model.ErrErasePendingTx
instance GHC.Base.Functor Cardano.Wallet.DB.Model.ErrErasePendingTx
instance GHC.Classes.Eq wid => GHC.Classes.Eq (Cardano.Wallet.DB.Model.ErrErasePendingTx wid)
instance GHC.Show.Show wid => GHC.Show.Show (Cardano.Wallet.DB.Model.ErrErasePendingTx wid)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Model.Database wid s xprv)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Model.WalletDatabase s xprv)
instance (GHC.Classes.Eq s, GHC.Classes.Eq xprv) => GHC.Classes.Eq (Cardano.Wallet.DB.Model.WalletDatabase s xprv)
instance GHC.Show.Show xprv => GHC.Show.Show (Cardano.Wallet.DB.Model.WalletDatabase s xprv)
instance (GHC.Show.Show wid, GHC.Show.Show xprv) => GHC.Show.Show (Cardano.Wallet.DB.Model.Database wid s xprv)
instance (GHC.Classes.Eq wid, GHC.Classes.Eq xprv, GHC.Classes.Eq s) => GHC.Classes.Eq (Cardano.Wallet.DB.Model.Database wid s xprv)


-- | Provides the API of Coin Selection algorithm and Fee Calculation This
--   module contains the implementation of adjusting coin selection for a
--   fee. The sender pays for the fee and additional inputs are picked
--   randomly. For more information refer to:
--   <a>https://iohk.io/blog/self-organisation-in-coin-selection/</a>
module Cardano.Wallet.Primitive.Fee

-- | A <a>Fee</a>, isomorph to <a>Coin</a> but ease type-signatures and
--   readability.
newtype Fee
Fee :: Word64 -> Fee
[getFee] :: Fee -> Word64

-- | A linear equation of a free variable <tt>x</tt>. Represents the <tt>x
--   -&gt; a + b*x</tt> function where <tt>x</tt> can be the transaction
--   size in bytes or, a number of inputs + outputs.
--   
--   <tt>a</tt>, <tt>b</tt> and <tt>c</tt> are constant coefficients.
--   
--   FIXME <a>Double</a> is an old artifact from the Byron era on
--   cardano-sl. It must go.
data FeePolicy
LinearFee :: Quantity "lovelace" Double -> Quantity "lovelace/byte" Double -> Quantity "lovelace/certificate" Double -> FeePolicy

-- | Compute fee for a given payload. Fee follows a simple linear equation:
--   
--   <pre>
--   f = a + size * b
--   </pre>
--   
--   where <tt>a</tt> &amp; <tt>b</tt> are values fixed by the protocol.
computeFee :: FeePolicy -> Quantity "byte" Int -> Fee

-- | Compute fee for a delegation certificate. One need to take into
--   consideration that "regular tx" fee calculation still holds. There is
--   additional flat fee inscribed on top of that:
--   
--   <pre>
--   f = a + size * b + c
--   </pre>
--   
--   where <tt>a</tt> &amp; <tt>b</tt> are values fixed by the protocol.
computeCertFee :: Word64 -> FeePolicy -> Quantity "byte" Int -> Fee

-- | Proportionally divide the fee over each output.
--   
--   Pre-condition 1: The given outputs list shouldn't be empty
--   Pre-condition 2: None of the outputs should be null
--   
--   It returns the a list of pairs (fee, output).
divvyFee :: Fee -> [Coin] -> [(Fee, Coin)]
data FeeOptions
FeeOptions :: (CoinSelection -> Fee) -> Coin -> FeeOptions

-- | Estimate fees based on number of inputs and values of the outputs Some
--   pointers / order of magnitude from the current configuration: a:
--   155381 # absolute minimal fees per transaction b: 43.946 # additional
--   minimal fees per byte of transaction size
[estimateFee] :: FeeOptions -> CoinSelection -> Fee

-- | Change addresses below the given threshold will be evicted from the
--   created transaction. Setting <a>dustThreshold</a> to 0 removes output
--   equal to 0
[dustThreshold] :: FeeOptions -> Coin
newtype ErrAdjustForFee

-- | UTxO exhausted during fee covering We record what amount missed to
--   cover the fee
ErrCannotCoverFee :: Word64 -> ErrAdjustForFee

-- | Given the coin selection result from a policy run, adjust the outputs
--   for fees, potentially returning additional inputs that we need to
--   cover all fees. We lose the relationship between the transaction
--   outputs and their corresponding inputs/change outputs here. This is a
--   decision we may wish to revisit later. For now however note that since
--   
--   (a) coin selection tries to establish a particular ratio between
--   payment outputs and change outputs (currently it aims for an average
--   of 1:1)
--   
--   (b) coin selection currently only generates a single change output per
--   payment output, distributing the fee proportionally across all change
--   outputs is roughly equivalent to distributing it proportionally over
--   the payment outputs (roughly, not exactly, because the 1:1 proportion
--   is best effort only, and may in some cases be wildly different).
--   
--   Note that for (a) we don't need the ratio to be 1:1, the above
--   reasoning will remain true for any proportion 1:n. For (b) however, if
--   coin selection starts creating multiple outputs, and this number may
--   vary, then losing the connection between outputs and change outputs
--   will mean that that some outputs may pay a larger percentage of the
--   fee (depending on how many change outputs the algorithm happened to
--   choose).
adjustForFee :: MonadRandom m => FeeOptions -> UTxO -> CoinSelection -> ExceptT ErrAdjustForFee m CoinSelection
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Fee.ErrAdjustForFee
instance GHC.Show.Show Cardano.Wallet.Primitive.Fee.ErrAdjustForFee
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Fee.FeeOptions
instance GHC.Show.Show Cardano.Wallet.Primitive.Fee.Fee
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Fee.Fee
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Fee.Fee


-- | This module contains an algorithm to select coins for migration from
--   legacy wallets to newer wallets.
--   
--   We want users to be able to migrate their funds from a legacy random
--   wallet to a new sequential wallet. To do this, we have to move funds
--   from a wallet to another by making transactions. Funds are ultimately
--   a sum of many coins (a.k.a UTxOs). In a transaction, we can select a
--   few coins, and send them to addresses, effectively creating new coins
--   / UTxOs doing this.
--   
--   There are some limitations regarding the number of coins that can be
--   selected at once in a single transaction (theoretically 255 coins, in
--   practice ~170) because there's a transaction max size (in bytes)
--   enforced by the network. Also, there's a direct relationship between
--   the maximum number of inputs we can select, and the maximum number of
--   outputs we can produce (increasing one will decrease the other, and
--   vice-versa).
--   
--   When making a transaction, coins used as inputs for a transaction
--   becomes unavailable for a while, until the transaction is inserted
--   into the ledger and, make some new coins available as change (very
--   much like when paying with bank notes to a shop, if we give a 20 EUR
--   note to pay for 3 EUR, we can't spend the remaining 17 EUR before we
--   have received the change!). So, a wallet with a small number of UTxO
--   will not be able to make many transactions in parallel and will have
--   to make them sequentially, waiting for the previous ones to be
--   inserted before making new ones (we also say that a wallet is not
--   "fragmented enough").
module Cardano.Wallet.Primitive.CoinSelection.Migration

-- | Construct a list of coin selections / transactions to transfer the
--   totality of a user's wallet. The resulting <a>CoinSelection</a> do not
--   contain any <a>outputs</a>, but only change coins (so there's no
--   restriction about how addresses are generated).
--   
--   It tries to fit as many inputs as possible in a single transaction
--   (fixed by the <a>Word8</a> maximum number of inputs given as argument.
--   
--   The fee options are used to balance the coin selections and fix a
--   threshold for dust that is removed from the selections.
depleteUTxO :: FeeOptions -> Word8 -> UTxO -> [CoinSelection]

-- | Try to find a fix "ideal" number of input transactions that would
--   generate rather balanced transactions.
idealBatchSize :: CoinSelectionOptions e -> Word8


-- | This module provides a data structure and functions for operating on a
--   sequence of block headers.
--   
--   The <a>BlockHeaders</a> sequence is used for maintaining the global
--   unstable blocks state for the network layer. The unstable blocks state
--   can be compared with the block headers state of chain consumers to
--   determine the intersection point.
module Cardano.Wallet.Network.BlockHeaders

-- | A list of block headers and their hashes. The last block in this
--   sequence is the network tip. The first block in this sequence is the
--   block of depth <i>k</i>, which is the last unstable block.
newtype BlockHeaders
BlockHeaders :: Seq BlockHeader -> BlockHeaders

-- | Double-ended queue of block headers, and their IDs.
[$sel:getBlockHeaders:BlockHeaders] :: BlockHeaders -> Seq BlockHeader

-- | Constuct an empty unstable blocks sequence.
emptyBlockHeaders :: BlockHeaders

-- | Updates the unstable blocks state using the given "fetch" functions.
--   
--   This attempts to synchronise the local state with that of the node.
--   The node may be on a different chain to the current unstable blocks,
--   so this function handles switching of chains.
--   
--   For example, this is what it would do when the local tip is
--   <tt>a13</tt>, but the node's tip is <tt>b15</tt>, on a different
--   chain.
--   
--   <pre>
--                                     local tip ↴
--                   ┌───┬───  ───┬───┬───┬───┬───┐
--   Unstable blocks │a03│..    ..│a10│a11│a12│a13│
--                   └───┴───  ───┴───┴───┴───┴───┘
--                             ───┬───┬───┬───┬───┬───┬───┐
--   Node backend chain        ...│a10│a11│b12│b13│b14│b15│
--                             ───┴───┴───┴───┴───┴───┴───┘
--                         rollback point ⬏     node tip ⬏
--   </pre>
--   
--   To start with, the node says the tip hash is <tt>b15</tt>.
--   
--   Work backwards from tip, fetching blocks and adding them to
--   <tt>ac</tt>, and removing overlapping blocks from <tt>ubs</tt>.
--   Overlapping blocks occur when there has been a rollback.
--   
--   <pre>
--       ubs                     ac
--   1.  ───┬───┬───┬───┬───┐    ┌───┐
--       ...│a10│a11│a12│a13│    │b15│
--       ───┴───┴───┴───┴───┘    └───┘
--   2.  ───┬───┬───┬───┬───┐┌───┬───┐
--       ...│a10│a11│a12│a13││b14│b15│
--       ───┴───┴───┴───┴───┘└───┴───┘
--   3.  ───┬───┬───┬───┐┌───┬───┬───┐
--       ...│a10│a11│a12││b13│b14│b15│
--       ───┴───┴───┴───┘└───┴───┴───┘
--   4.  ───┬───┬───┐┌───┬───┬───┬───┐
--       ...│a10│a11││b12│b13│b14│b15│
--       ───┴───┴───┘└───┴───┴───┴───┘
--   </pre>
--   
--   Stop once <tt>ubs</tt> and <tt>ac</tt> meet with a block which has the
--   same hash. If they never meet, stop cleanupConfig fetching <i>k</i>
--   blocks.
--   
--   Finally, to get the new <a>BlockHeaders</a>, append <tt>ac</tt> to
--   <tt>ubs</tt>, and limit the length to <i>k</i>.
--   
--   The new block height is the height of the first block that was
--   fetched.
--   
--   If any errors occur while this process is running (for example,
--   fetching a block which has been rolled back and lost from the node's
--   state), it will immediately terminate.
updateUnstableBlocks :: forall m. Monad m => Quantity "block" Word32 -> m (Hash "BlockHeader") -> (Hash "BlockHeader" -> m BlockHeader) -> BlockHeaders -> m BlockHeaders

-- | The tip block header of the unstable blocks, if it exists.
blockHeadersTip :: BlockHeaders -> Maybe BlockHeader

-- | The base block header is the oldest block header in the unstable
--   blocks,
blockHeadersBase :: BlockHeaders -> Maybe BlockHeader

-- | Whether we are at genesis or not.
blockHeadersAtGenesis :: BlockHeaders -> Bool

-- | Add recently fetched block headers to the unstable blocks. This will
--   drop the oldest block headers to ensure that there are at most
--   <i>k</i> items in the sequence.
appendBlockHeaders :: Quantity "block" Word32 -> BlockHeaders -> [BlockHeader] -> BlockHeaders

-- | Remove unstable blocks which have a slot greater than or equal to the
--   given slot.
dropStartingFromSlotId :: SlotId -> BlockHeaders -> BlockHeaders

-- | Drop any headers that are (strictly) after the given slot id.
dropAfterSlotId :: SlotId -> BlockHeaders -> BlockHeaders

-- | If the two sequences overlap in terms of slots, return the block
--   header of the last block that is common between the two. Otherwise
--   return Nothing.
--   
--   <a>greatestCommonBlockHeader</a> works fine if one (or both) list are
--   sparse and different length.
--   
--   For example: <tt> | (1) | (2) | (3) | (4) | (5) Node | abcdefg | efg |
--   abcdefg | abcde | abc Local | cdpqrst | abc | abcdefg | | efg GCBH |
--   Just d | Nothing | Just g | Nothing | Nothing </tt>
greatestCommonBlockHeader :: BlockHeaders -> BlockHeaders -> Maybe BlockHeader
instance GHC.Generics.Generic Cardano.Wallet.Network.BlockHeaders.BlockHeaders
instance GHC.Classes.Eq Cardano.Wallet.Network.BlockHeaders.BlockHeaders
instance GHC.Show.Show Cardano.Wallet.Network.BlockHeaders.BlockHeaders
instance Control.DeepSeq.NFData Cardano.Wallet.Network.BlockHeaders.BlockHeaders

module Cardano.Wallet.Network
data NetworkLayer m target block
NetworkLayer :: (Cursor target -> ExceptT ErrGetBlock m (NextBlocksResult (Cursor target) block)) -> ([BlockHeader] -> m (Cursor target)) -> (Cursor target -> SlotId) -> ExceptT ErrCurrentNodeTip m BlockHeader -> (SealedTx -> ExceptT ErrPostTx m ()) -> ExceptT ErrNetworkUnavailable m (EpochNo, Map PoolId (Quantity "lovelace" Word64)) -> (ChimericAccount -> ExceptT ErrGetAccountBalance m (Quantity "lovelace" Word64)) -> NetworkLayer m target block

-- | Starting from the given <a>Cursor</a>, fetches a contiguous sequence
--   of blocks from the node, if they are available. An updated cursor will
--   be returned with a <tt>RollFoward</tt> result.
--   
--   Blocks are returned in ascending slot order, without skipping blocks.
--   
--   If the node does not have any blocks after the specified cursor point,
--   it will return <a>AwaitReply</a>.
--   
--   If the node has adopted an alternate fork of the chain, it will return
--   <a>RollBackward</a> with a new cursor.
[nextBlocks] :: NetworkLayer m target block -> Cursor target -> ExceptT ErrGetBlock m (NextBlocksResult (Cursor target) block)

-- | Creates a cursor from the given block header so that <a>nextBlocks</a>
--   can be used to fetch blocks.
[initCursor] :: NetworkLayer m target block -> [BlockHeader] -> m (Cursor target)

-- | Get the slot corresponding to a cursor.
[cursorSlotId] :: NetworkLayer m target block -> Cursor target -> SlotId

-- | Get the current tip from the chain producer
[currentNodeTip] :: NetworkLayer m target block -> ExceptT ErrCurrentNodeTip m BlockHeader

-- | Broadcast a transaction to the chain producer
[postTx] :: NetworkLayer m target block -> SealedTx -> ExceptT ErrPostTx m ()
[stakeDistribution] :: NetworkLayer m target block -> ExceptT ErrNetworkUnavailable m (EpochNo, Map PoolId (Quantity "lovelace" Word64))
[getAccountBalance] :: NetworkLayer m target block -> ChimericAccount -> ExceptT ErrGetAccountBalance m (Quantity "lovelace" Word64)

-- | The result of <a>nextBlocks</a>, which is instructions for what the
--   chain consumer should do next.
data NextBlocksResult cursor block

-- | There are no blocks available from the node, so wait.
AwaitReply :: NextBlocksResult cursor block

-- | Apply the given contiguous non-empty sequence of blocks. Use the
--   updated cursor to get the next batch. The given block header is the
--   current tip of the node.
RollForward :: cursor -> BlockHeader -> [block] -> NextBlocksResult cursor block

-- | The chain consumer must roll back its state, then use the cursor to
--   get the next batch of blocks.
RollBackward :: cursor -> NextBlocksResult cursor block
mapCursor :: (a -> b) -> NextBlocksResult a block -> NextBlocksResult b block

-- | A cursor is local state kept by the chain consumer to use as the
--   starting position for <a>nextBlocks</a>. The actual type is opaque and
--   determined by the backend <tt>target</tt>.
data family Cursor target

-- | Subscribe to a blockchain and get called with new block (in order)!
--   
--   Exits when the node switches to a different chain with the greatest
--   known common tip between the follower and the node. This makes it
--   easier for client to re-start following from a different point if they
--   have, for instance, rolled back to a point further in the past. If
--   this occurs, clients will need to restart the chain follower from a
--   known list of headers, re-initializing the cursor.
--   
--   Exits with <a>Nothing</a> in case of error.
follow :: forall target block e. Show e => NetworkLayer IO target block -> Tracer IO FollowLog -> [BlockHeader] -> (NonEmpty block -> BlockHeader -> IO (FollowAction e)) -> (block -> BlockHeader) -> IO (Maybe SlotId)

-- | <tt>FollowAction</tt> enables the callback of <tt>follow</tt> to
--   signal if the chain-following should <tt>ExitWith</tt>,
--   <tt>Continue</tt>, or if the current callback should be forgotten and
--   retried (<tt>Retry</tt>).
--   
--   NOTE: <tt>Retry</tt> is needed to handle data-races in <a>Metrics</a>,
--   where it is essensial that we fetch the stake distribution while the
--   node-tip
--   
--   FIXME: Retry actions with the Haskell nodes are not possible (or at
--   least, requires some additional manipulation to find a new
--   intersection). As a possible fix, we could use a type family to define
--   <a>FollowAction</a> in terms of the underlying target.
--   <a>RetryImmediately</a> and <a>RetryLater</a> could be authorized in
--   the context of Jormungandr but absent in the context of the Haskell
--   nodes.
data FollowAction err

-- | Stop following the chain.
ExitWith :: err -> FollowAction err

-- | Continue following the chain.
Continue :: FollowAction err

-- | Forget about the blocks in the current callback, and retry
--   immediately.
RetryImmediately :: FollowAction err

-- | Like <a>RetryImmediately</a> but only retries after a short delay
RetryLater :: FollowAction err

-- | Network is unavailable
data ErrNetworkUnavailable

-- | Cannot connect to network backend.
ErrNetworkUnreachable :: Text -> ErrNetworkUnavailable

-- | Network backend reports that the requested network is invalid.
ErrNetworkInvalid :: Text -> ErrNetworkUnavailable

-- | Error while trying to get the node tip
data ErrCurrentNodeTip
ErrCurrentNodeTipNetworkUnreachable :: ErrNetworkUnavailable -> ErrCurrentNodeTip
ErrCurrentNodeTipNotFound :: ErrCurrentNodeTip

-- | Error while trying to get one or more blocks
data ErrGetBlock
ErrGetBlockNetworkUnreachable :: ErrNetworkUnavailable -> ErrGetBlock
ErrGetBlockNotFound :: Hash "BlockHeader" -> ErrGetBlock

-- | Error while trying to send a transaction
data ErrPostTx
ErrPostTxNetworkUnreachable :: ErrNetworkUnavailable -> ErrPostTx
ErrPostTxBadRequest :: Text -> ErrPostTx
ErrPostTxProtocolFailure :: Text -> ErrPostTx
data ErrGetAccountBalance
ErrGetAccountBalanceNetworkUnreachable :: ErrNetworkUnavailable -> ErrGetAccountBalance
ErrGetAccountBalanceAccountNotFound :: ChimericAccount -> ErrGetAccountBalance
data FollowLog
MsgFollowAction :: FollowAction String -> FollowLog
MsgFatalUnhandledException :: Text -> FollowLog
MsgUnhandledException :: Text -> FollowLog
MsgNextBlockFailed :: ErrGetBlock -> FollowLog
MsgSynced :: FollowLog
MsgApplyBlocks :: NonEmpty BlockHeader -> FollowLog

-- | A default <tt>RetryPolicy</tt> with a delay that starts short, and
--   that retries for no longer than a minute.
defaultRetryPolicy :: Monad m => RetryPolicyM m

-- | Wait until 'currentNodeTip networkLayer' succeeds according to a given
--   retry policy. Throws an exception otherwise.
waitForNetwork :: ExceptT ErrNetworkUnavailable IO () -> RetryPolicyM IO -> IO ()
instance GHC.Classes.Eq Cardano.Wallet.Network.FollowLog
instance GHC.Show.Show Cardano.Wallet.Network.FollowLog
instance GHC.Base.Functor Cardano.Wallet.Network.FollowAction
instance GHC.Show.Show err => GHC.Show.Show (Cardano.Wallet.Network.FollowAction err)
instance GHC.Classes.Eq err => GHC.Classes.Eq (Cardano.Wallet.Network.FollowAction err)
instance GHC.Show.Show Cardano.Wallet.Network.ErrGetAccountBalance
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrGetAccountBalance
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrGetAccountBalance
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrPostTx
instance GHC.Show.Show Cardano.Wallet.Network.ErrPostTx
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrPostTx
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrGetBlock
instance GHC.Show.Show Cardano.Wallet.Network.ErrGetBlock
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrGetBlock
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrCurrentNodeTip
instance GHC.Show.Show Cardano.Wallet.Network.ErrCurrentNodeTip
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrCurrentNodeTip
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrNetworkUnavailable
instance GHC.Show.Show Cardano.Wallet.Network.ErrNetworkUnavailable
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrNetworkUnavailable
instance Data.Text.Class.ToText Cardano.Wallet.Network.FollowLog
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.Wallet.Network.FollowLog
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.Wallet.Network.FollowLog
instance GHC.Base.Functor m => GHC.Base.Functor (Cardano.Wallet.Network.NetworkLayer m target)
instance GHC.Base.Functor (Cardano.Wallet.Network.NextBlocksResult cursor)
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrPostTx
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrCurrentNodeTip
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrNetworkUnavailable


-- | Database / Persistence layer for the wallet backend. This is where we
--   define the interface allowing us to store and fetch various data on
--   our wallets.
module Cardano.Wallet.DB

-- | A Database interface for storing various things in a DB. In practice,
--   we'll need some extra contraints on the wallet state that allows us to
--   serialize and unserialize it (e.g. <tt>forall s. (Serialize s) =&gt;
--   ...</tt>)
--   
--   NOTE:
--   
--   We can't use record accessors on the DBLayer as it carries an
--   existential within its constructor. We are forced to pattern-match on
--   the <a>DBLayer</a> record type in order to be able to use its methods
--   in any context. With NamedFieldPuns, or RecordWildCards, this can be
--   quite easy:
--   
--   <pre>
--   myFunction DBLayer{..} = do
--       ...
--   
--   myOtherFunction DBLayer{atomically,initializeWallet} = do
--       ...
--   </pre>
--   
--   Alternatively, in some other context where the database may not be a
--   function argument but come from a different source, it is possible to
--   simply rely on 'Data.Function.(&amp;)' to easily pattern match on it:
--   
--   <pre>
--   myFunction arg0 arg1 = db &amp; DBLayer{..} -&gt; do
--       ...
--     where
--       db = ...
--   </pre>
--   
--   Note that it isn't possible to simply use a <tt>where</tt> clause or a
--   <tt>let</tt> binding here as the semantic for those are slightly
--   different: we really need a pattern match here!
data DBLayer m s k
DBLayer :: (PrimaryKey WalletId -> Wallet s -> WalletMetadata -> [(Tx, TxMeta)] -> ExceptT ErrWalletAlreadyExists stm ()) -> (PrimaryKey WalletId -> ExceptT ErrNoSuchWallet stm ()) -> stm [PrimaryKey WalletId] -> (PrimaryKey WalletId -> Wallet s -> ExceptT ErrNoSuchWallet stm ()) -> (PrimaryKey WalletId -> stm (Maybe (Wallet s))) -> (PrimaryKey WalletId -> stm [BlockHeader]) -> (PrimaryKey WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet stm ()) -> (PrimaryKey WalletId -> stm (Maybe WalletMetadata)) -> (PrimaryKey WalletId -> DelegationCertificate -> SlotId -> ExceptT ErrNoSuchWallet stm ()) -> (PrimaryKey WalletId -> [(Tx, TxMeta)] -> ExceptT ErrNoSuchWallet stm ()) -> (PrimaryKey WalletId -> SortOrder -> Range SlotId -> Maybe TxStatus -> stm [(Tx, TxMeta)]) -> (PrimaryKey WalletId -> Hash "Tx" -> ExceptT ErrRemovePendingTx stm ()) -> (PrimaryKey WalletId -> (k  'RootK XPrv, Hash "encryption") -> ExceptT ErrNoSuchWallet stm ()) -> (PrimaryKey WalletId -> stm (Maybe (k  'RootK XPrv, Hash "encryption"))) -> (PrimaryKey WalletId -> SlotId -> ExceptT ErrNoSuchWallet stm SlotId) -> (PrimaryKey WalletId -> ExceptT ErrNoSuchWallet stm ()) -> (forall a. stm a -> m a) -> DBLayer m s k

-- | Initialize a database entry for a given wallet. <a>putCheckpoint</a>,
--   <a>putWalletMeta</a> or <a>putTxHistory</a> will actually all fail if
--   they are called _first_ on a wallet.
[initializeWallet] :: DBLayer m s k -> PrimaryKey WalletId -> Wallet s -> WalletMetadata -> [(Tx, TxMeta)] -> ExceptT ErrWalletAlreadyExists stm ()

-- | Remove a given wallet and all its associated data (checkpoints,
--   metadata, tx history ...)
[removeWallet] :: DBLayer m s k -> PrimaryKey WalletId -> ExceptT ErrNoSuchWallet stm ()

-- | Get the list of all known wallets in the DB, possibly empty.
[listWallets] :: DBLayer m s k -> stm [PrimaryKey WalletId]

-- | Replace the current checkpoint for a given wallet. We do not handle
--   rollbacks yet, and therefore only stores the latest available
--   checkpoint.
--   
--   If the wallet doesn't exist, this operation returns an error.
[putCheckpoint] :: DBLayer m s k -> PrimaryKey WalletId -> Wallet s -> ExceptT ErrNoSuchWallet stm ()

-- | Fetch the most recent checkpoint of a given wallet.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readCheckpoint] :: DBLayer m s k -> PrimaryKey WalletId -> stm (Maybe (Wallet s))

-- | List all known checkpoint tips, ordered by slot ids from the oldest to
--   the newest.
[listCheckpoints] :: DBLayer m s k -> PrimaryKey WalletId -> stm [BlockHeader]

-- | Replace an existing wallet metadata with the given one.
--   
--   If the wallet doesn't exist, this operation returns an error
[putWalletMeta] :: DBLayer m s k -> PrimaryKey WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet stm ()

-- | Fetch a wallet metadata, if they exist.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readWalletMeta] :: DBLayer m s k -> PrimaryKey WalletId -> stm (Maybe WalletMetadata)

-- | Binds a stake pool id to a wallet. This will have an influence on the
--   wallet metadata: the last known certificate will indicate to which
--   pool a wallet is currently delegating.
--   
--   This is done separately from <a>putWalletMeta</a> because certificate
--   declarations are:
--   
--   <ol>
--   <li>Stored on-chain.</li>
--   <li>Affected by rollbacks (or said differently, tied to a
--   <a>SlotId</a>).</li>
--   </ol>
[putDelegationCertificate] :: DBLayer m s k -> PrimaryKey WalletId -> DelegationCertificate -> SlotId -> ExceptT ErrNoSuchWallet stm ()

-- | Augments the transaction history for a known wallet.
--   
--   If an entry for a particular transaction already exists it is not
--   altered nor merged (just ignored).
--   
--   If the wallet doesn't exist, this operation returns an error.
[putTxHistory] :: DBLayer m s k -> PrimaryKey WalletId -> [(Tx, TxMeta)] -> ExceptT ErrNoSuchWallet stm ()

-- | Fetch the current transaction history of a known wallet, ordered by
--   descending slot number.
--   
--   Returns an empty list if the wallet isn't found.
[readTxHistory] :: DBLayer m s k -> PrimaryKey WalletId -> SortOrder -> Range SlotId -> Maybe TxStatus -> stm [(Tx, TxMeta)]

-- | Remove a pending transaction.
[removePendingTx] :: DBLayer m s k -> PrimaryKey WalletId -> Hash "Tx" -> ExceptT ErrRemovePendingTx stm ()

-- | Store or replace a private key for a given wallet. Note that wallet
--   _could_ be stored and manipulated without any private key associated
--   to it. A private key is only seldomly required for very specific
--   operations (like transaction signing).
[putPrivateKey] :: DBLayer m s k -> PrimaryKey WalletId -> (k  'RootK XPrv, Hash "encryption") -> ExceptT ErrNoSuchWallet stm ()

-- | Read a previously stored private key and its associated passphrase
--   hash.
[readPrivateKey] :: DBLayer m s k -> PrimaryKey WalletId -> stm (Maybe (k  'RootK XPrv, Hash "encryption"))

-- | Drops all checkpoints and transaction data after the given slot.
--   
--   Returns the actual slot to which the database has rolled back. This
--   slot is guaranteed to be earlier than (or identical to) the given
--   point of rollback but can't be guaranteed to be exactly the same
--   because the database may only keep sparse checkpoints.
[rollbackTo] :: DBLayer m s k -> PrimaryKey WalletId -> SlotId -> ExceptT ErrNoSuchWallet stm SlotId

-- | Prune database entities and remove entities that can be discarded.
[prune] :: DBLayer m s k -> PrimaryKey WalletId -> ExceptT ErrNoSuchWallet stm ()

-- | Execute operations of the database in isolation and atomically.
[atomically] :: DBLayer m s k -> forall a. stm a -> m a

-- | Instantiate database layers at will
data DBFactory m s k
DBFactory :: (forall a. WalletId -> (DBLayer m s k -> IO a) -> IO a) -> (WalletId -> IO ()) -> DBFactory m s k

-- | Creates a new or use an existing database, maintaining an open
--   connection so long as necessary
[withDatabase] :: DBFactory m s k -> forall a. WalletId -> (DBLayer m s k -> IO a) -> IO a

-- | Erase any trace of the database
[removeDatabase] :: DBFactory m s k -> WalletId -> IO ()

-- | A primary key which can take many forms depending on the value. This
--   may become a type family as we move forward, but for now, it
--   illustrate that some queries are ran against some sort of store;
--   
--   As a matter of fact, we may manipulate multiple wallets at the same
--   time, so, functions like <tt>enqueueCheckpoint</tt> needs to be
--   associated to a corresponding wallet. Some other may not because they
--   are information valid for all wallets (like for instance, the last
--   known network tip).
newtype PrimaryKey key
PrimaryKey :: key -> PrimaryKey key

-- | Clean a database by removing all wallets.
cleanDB :: DBLayer m s k -> m ()

-- | Storing EVERY checkpoints in the database is quite expensive and
--   useless. We make the following assumptions:
--   
--   <ul>
--   <li>We can't rollback for more than `k=epochStability` blocks in the
--   past</li>
--   <li>It is pretty fast to re-sync a few hundred blocks</li>
--   <li>Small rollbacks may occur more often than long one</li>
--   </ul>
--   
--   So, as we insert checkpoints, we make sure to:
--   
--   <ul>
--   <li>Prune any checkpoint that more than <tt>k</tt> blocks in the
--   past</li>
--   <li>Keep only one checkpoint every 100 blocks</li>
--   <li>But still keep ~10 most recent checkpoints to cope with small
--   rollbacks</li>
--   </ul>
--   
--   <b>Example 1</b>: Inserting <tt>cp153</tt>
--   
--   ℹ: <tt>cp142</tt> is discarded and <tt>cp153</tt> inserted.
--   
--   <pre>
--    Currently in DB:
--   ┌───┬───┬───┬─  ──┬───┐
--   │cp000 │cp100 │cp142 │..    ..│cp152 │
--   └───┴───┴───┴─  ──┴───┘
--    Want in DB:
--   ┌───┬───┬───┬─  ──┬───┐
--   │cp000 │cp100 │cp143 │..    ..│cp153 │
--   └───┴───┴───┴─  ──┴───┘
--    
--   </pre>
--   
--   <b>Example 2</b>: Inserting <tt>cp111</tt>
--   
--   ℹ: <tt>cp100</tt> is kept and <tt>cp111</tt> inserted.
--   
--   <pre>
--    Currently in DB:
--   ┌───┬───┬───┬─  ──┬───┐
--   │cp000 │cp100 │cp101 │..    ..│cp110 │
--   └───┴───┴───┴─  ──┴───┘
--    Want in DB:
--   ┌───┬───┬───┬─  ──┬───┐
--   │cp000 │cp100 │cp101 │..    ..│cp111 │
--   └───┴───┴───┴─  ──┴───┘
--    
--   </pre>
--   
--   NOTE: There might be cases where the chain following "fails" (because,
--   for example, the node has switch to a different chain, different by
--   more than k), and in such cases, we have no choice but rolling back
--   from genesis. Therefore, we need to keep the very first checkpoint in
--   the database, no matter what.
sparseCheckpoints :: Quantity "block" Word32 -> Quantity "block" Word32 -> [Word32]

-- | Can't perform removing pending transaction
data ErrRemovePendingTx
ErrRemovePendingTxNoSuchWallet :: ErrNoSuchWallet -> ErrRemovePendingTx
ErrRemovePendingTxNoSuchTransaction :: Hash "Tx" -> ErrRemovePendingTx
ErrRemovePendingTxTransactionNoMorePending :: Hash "Tx" -> ErrRemovePendingTx

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists
instance GHC.Classes.Ord key => GHC.Classes.Ord (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Show.Show Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Show.Show Cardano.Wallet.DB.ErrNoSuchTransaction
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrNoSuchTransaction
instance GHC.Show.Show Cardano.Wallet.DB.ErrRemovePendingTx
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrRemovePendingTx
instance GHC.Show.Show Cardano.Wallet.DB.ErrNoSuchWallet
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrNoSuchWallet


-- | Dummy implementation of the database-layer, using <a>MVar</a>. This
--   may be good for testing to compare with an implementation on a real
--   data store, or to use when compiling the wallet for targets which
--   don't have SQLite.
module Cardano.Wallet.DB.MVar

-- | Instantiate a new in-memory "database" layer that simply stores data
--   in a local MVar. Data vanishes if the software is shut down.
newDBLayer :: forall s k. NFData (k  'RootK XPrv) => IO (DBLayer IO s k)
instance GHC.Show.Show Cardano.Wallet.DB.MVar.MVarDBError
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.MVar.MVarDBError


-- | An implementation of the production pool database using only pure
--   functions.
--   
--   These functions and types model the behaviour of the SQLite database
--   backend, and are used for QuickCheck state machine testing, and the
--   MVar database backend.
module Cardano.Pool.DB.Model
data PoolDatabase
PoolDatabase :: !Map PoolId [BlockHeader] -> !Map EpochNo [(PoolId, Quantity "lovelace" Word64)] -> !Map PoolId [PoolOwner] -> !Map (SlotId, PoolId) (Percentage, Quantity "lovelace" Word64) -> !SystemSeed -> PoolDatabase

-- | Information of what blocks were produced by which stake pools
[$sel:pools:PoolDatabase] :: PoolDatabase -> !Map PoolId [BlockHeader]

-- | Store known stake distributions for epochs
[$sel:distributions:PoolDatabase] :: PoolDatabase -> !Map EpochNo [(PoolId, Quantity "lovelace" Word64)]

-- | Mapping between pool ids and owners
[$sel:owners:PoolDatabase] :: PoolDatabase -> !Map PoolId [PoolOwner]

-- | On-chain metadata associated with pools
[$sel:metadata:PoolDatabase] :: PoolDatabase -> !Map (SlotId, PoolId) (Percentage, Quantity "lovelace" Word64)

-- | Store an arbitrary random generator seed
[$sel:seed:PoolDatabase] :: PoolDatabase -> !SystemSeed

-- | Produces an empty model pool production database.
emptyPoolDatabase :: PoolDatabase
type ModelPoolOp a = PoolDatabase -> (Either PoolErr a, PoolDatabase)
newtype PoolErr
PointAlreadyExists :: BlockHeader -> PoolErr
mCleanPoolProduction :: ModelPoolOp ()
mPutPoolProduction :: BlockHeader -> PoolId -> ModelPoolOp ()
mReadPoolProduction :: EpochNo -> ModelPoolOp (Map PoolId [BlockHeader])
mReadTotalProduction :: ModelPoolOp (Map PoolId (Quantity "block" Word64))
mPutStakeDistribution :: EpochNo -> [(PoolId, Quantity "lovelace" Word64)] -> ModelPoolOp ()
mReadStakeDistribution :: EpochNo -> ModelPoolOp [(PoolId, Quantity "lovelace" Word64)]
mPutPoolRegistration :: SlotId -> PoolRegistrationCertificate -> ModelPoolOp ()
mReadPoolRegistration :: PoolId -> ModelPoolOp (Maybe PoolRegistrationCertificate)
mListRegisteredPools :: PoolDatabase -> ([PoolId], PoolDatabase)
mReadSystemSeed :: PoolDatabase -> IO (StdGen, PoolDatabase)
mRollbackTo :: SlotId -> ModelPoolOp ()
mReadCursor :: Int -> ModelPoolOp [BlockHeader]
instance GHC.Classes.Eq Cardano.Pool.DB.Model.PoolErr
instance GHC.Show.Show Cardano.Pool.DB.Model.PoolErr
instance GHC.Classes.Eq Cardano.Pool.DB.Model.PoolDatabase
instance GHC.Show.Show Cardano.Pool.DB.Model.PoolDatabase
instance GHC.Generics.Generic Cardano.Pool.DB.Model.PoolDatabase
instance GHC.Show.Show Cardano.Pool.DB.Model.SystemSeed
instance GHC.Generics.Generic Cardano.Pool.DB.Model.SystemSeed
instance GHC.Classes.Eq Cardano.Pool.DB.Model.SystemSeed


-- | Database / Persistence layer for the pool production.
module Cardano.Pool.DB

-- | A Database interface for storing pool production in DB.
--   
--   To use it, you will need the NamedFieldPuns extension and wrap
--   operations with <tt>atomically</tt>:
--   
--   Example: &gt;&gt;&gt; :set -XNamedFieldPuns &gt;&gt;&gt;
--   DBLayer{atomically,putPoolProduction} = db &gt;&gt;&gt; atomically $
--   putPoolProduction blockHeader pool
--   
--   This gives you the power to also run <i>multiple</i> operations
--   atomically.
--   
--   FIXME: Allowing <a>MonadIO</a> to enable logging also within db
--   transactions. Ideally, we should lower than constraint to only allow
--   logging effects and not any dragons in IO.
data DBLayer m
DBLayer :: (BlockHeader -> PoolId -> ExceptT ErrPointAlreadyExists stm ()) -> (EpochNo -> stm (Map PoolId [BlockHeader])) -> stm (Map PoolId (Quantity "block" Word64)) -> (EpochNo -> [(PoolId, Quantity "lovelace" Word64)] -> stm ()) -> (EpochNo -> stm [(PoolId, Quantity "lovelace" Word64)]) -> (Int -> stm [BlockHeader]) -> (SlotId -> PoolRegistrationCertificate -> stm ()) -> (PoolId -> stm (Maybe PoolRegistrationCertificate)) -> stm [PoolId] -> stm StdGen -> (SlotId -> stm ()) -> stm () -> (forall a. stm a -> m a) -> DBLayer m

-- | Write for a given slot id the id of stake pool that produced a a
--   corresponding block
[putPoolProduction] :: DBLayer m -> BlockHeader -> PoolId -> ExceptT ErrPointAlreadyExists stm ()

-- | Read the all stake pools together with corresponding slot ids for a
--   given epoch.
[readPoolProduction] :: DBLayer m -> EpochNo -> stm (Map PoolId [BlockHeader])

-- | Read the total pool production since the pool was first registered.
[readTotalProduction] :: DBLayer m -> stm (Map PoolId (Quantity "block" Word64))

-- | Replace an existing distribution for the given epoch by the one given
--   as argument.
--   
--   If there's no existing distribution, simply inserts it.
[putStakeDistribution] :: DBLayer m -> EpochNo -> [(PoolId, Quantity "lovelace" Word64)] -> stm ()
[readStakeDistribution] :: DBLayer m -> EpochNo -> stm [(PoolId, Quantity "lovelace" Word64)]

-- | Read the latest <tt>k</tt> blockheaders in ascending order. The tip
--   will be the last element in the list.
--   
--   This is useful for the <tt>NetworkLayer</tt> to know how far we have
--   synced.
[readPoolProductionCursor] :: DBLayer m -> Int -> stm [BlockHeader]

-- | Add a mapping between stake pools and their corresponding certificate.
--   If the mapping already exists, data are replaced with the latest
--   version.
[putPoolRegistration] :: DBLayer m -> SlotId -> PoolRegistrationCertificate -> stm ()

-- | Find a registration certificate associated to a given pool
[readPoolRegistration] :: DBLayer m -> PoolId -> stm (Maybe PoolRegistrationCertificate)

-- | List the list of known pools, based on their registration certificate.
--   This list doesn't necessarily match the keys of the map we would get
--   from <a>readPoolProduction</a> because not all registered pools have
--   necessarily produced any block yet!
[listRegisteredPools] :: DBLayer m -> stm [PoolId]

-- | Read the seed assigned to this particular database. The seed is
--   created with the database and is "unique" for each database. This
--   however allow to have a seed that can be used to produce consistent
--   results across requests.
[readSystemSeed] :: DBLayer m -> stm StdGen

-- | Remove all entries of slot ids newer than the argument
[rollbackTo] :: DBLayer m -> SlotId -> stm ()

-- | Clean a database
[cleanDB] :: DBLayer m -> stm ()

-- | Run an operation.
--   
--   For a Sqlite DB, this would be "run a query inside a transaction".
[atomically] :: DBLayer m -> forall a. stm a -> m a

-- | Forbidden operation was executed on an already existing slot
newtype ErrPointAlreadyExists
ErrPointAlreadyExists :: BlockHeader -> ErrPointAlreadyExists
instance GHC.Show.Show Cardano.Pool.DB.ErrPointAlreadyExists
instance GHC.Classes.Eq Cardano.Pool.DB.ErrPointAlreadyExists


-- | This module defines necessary bits to compute an averaged apparent
--   performance for stake pools. The definition is inspired from the
--   "Design Specification for Delegation and Incentives in Cardano" by
--   Kant et Al, yet deviates slightly from it because of different real
--   constraints:
--   
--   a) The wallet software doesn't have a reliable access to various epoch
--   details such as the stake distribution for past epochs.
--   
--   b) The wallet software makes therefore a significant use of the
--   current epoch's data which represents unfinished snapshots of epochs
--   which, because of their non-deterministic nature, may favor leaders
--   elected early in the process more than those not yet elected.
--   
--   To cope with these two issues, we try to harmonize past known epochs
--   with the ongoing one by averaging over a whole range of epochs,
--   simultaneously. This means computing a ratio of the total blocks
--   produced by a leader on the total number of blocks we could reasonably
--   expect a leader to have produced, across many epochs at once (i.e.,
--   doing a ratio of sums, instead of a sum of ratios).
--   
--   This should be less punitive for leaders that have not yet been
--   elected as part of the ongoing epoch while having still performed
--   reasonably okay in the past.
module Cardano.Pool.Performance
data EpochStats
EpochStats :: !Natural -> !Natural -> !Natural -> !Natural -> EpochStats
[poolProduction] :: EpochStats -> !Natural
[poolStake] :: EpochStats -> !Natural
[totalStake] :: EpochStats -> !Natural
[totalProduction] :: EpochStats -> !Natural
apparentPerformance :: [EpochStats] -> Double

-- | Read pool performances of many epochs from the database
readPoolsPerformances :: Monad m => DBLayer m -> EpochNo -> m (Map PoolId Double)

-- | Count elements inside a <a>Map</a>
count :: Map k [a] -> Map k (Quantity any Word64)
instance GHC.Show.Show Cardano.Pool.Performance.EpochStats
instance GHC.Generics.Generic Cardano.Pool.Performance.EpochStats


-- | Dummy implementation of the database-layer, using <a>MVar</a>. This
--   may be good for testing to compare with an implementation on a real
--   data store, or to use when compiling the wallet for targets which
--   don't have SQLite.
module Cardano.Pool.DB.MVar

-- | Instantiate a new in-memory "database" layer that simply stores data
--   in a local MVar. Data vanishes if the software is shut down.
newDBLayer :: IO (DBLayer IO)
instance GHC.Show.Show Cardano.Pool.DB.MVar.MVarPoolDBError
instance GHC.Exception.Type.Exception Cardano.Pool.DB.MVar.MVarPoolDBError


-- | These are (partial) CBOR decoders for Byron binary types. Note that we
--   ignore most of the block's and header's content and only retrieve the
--   pieces of information relevant to us, wallet (we do assume a trusted
--   node and therefore, we needn't to care about verifying signatures and
--   blocks themselves).
--   
--   The format described in the decoders below are the one used in the
--   Byron era of Cardano and will endure in the first stages of Shelley.
--   They are also used by components like the Rust
--   <a>cardano-http-bridge</a>.
module Cardano.Byron.Codec.Cbor
decodeAddressDerivationPath :: Passphrase "addr-derivation-payload" -> Decoder s (Maybe (Index  'WholeDomain  'AccountK, Index  'WholeDomain  'AddressK))
decodeAddressPayload :: Decoder s ByteString

-- | The attributes are pairs of numeric tags and bytes, where the bytes
--   will be CBOR-encoded stuff. This decoder does not enforce "canonicity"
--   of entries.
decodeAllAttributes :: Decoder s [(Word8, ByteString)]
decodeBlockHeader :: Decoder s BlockHeader
decodeDerivationPathAttr :: Passphrase "addr-derivation-payload" -> [(Word8, ByteString)] -> Decoder s (Maybe (Index  'WholeDomain  'AccountK, Index  'WholeDomain  'AddressK))
decodeSignedTx :: Decoder s (([TxIn], [TxOut]), [ByteString])
decodeTx :: Decoder s ([TxIn], [TxOut])
decodeTxWitness :: Decoder s ByteString

-- | Encode a public key to a corresponding Cardano Address. The encoding
--   of the attributes part of an address is left out to the caller; This
--   allows for distinguishing between Sequential and Random addresses (the
--   former doesn't have any attributes to encode).
--   
--   <pre>
--   -- Old / Random Addresses
--   let encodeAddrAttributes = mempty
--        &lt;&gt; CBOR.encodeMapLen 1
--        &lt;&gt; CBOR.encodeWord8 1
--        &lt;&gt; encodeDerivationPath (hdPassphrase rootXPub) accIx addrIx
--   let addr = encodeAddress xpub encodeAddrAttributes
--   
--   -- New / Sequential Addresses
--   let encodeAddrAttributes = mempty &lt;&gt; CBOR.encodeMapLen 0
--   let addr = encodeAddress xpub encodeAddrAttributes
--   </pre>
--   
--   Note that we are passing the behavior to encode attributes as a
--   parameter here and do not handle multiple cases in
--   <a>encodeAddress</a> itself for multiple reasons:
--   
--   <ul>
--   <li>Inversion of control gives us a nicer implementation overall</li>
--   <li>Encoding attributes for Random addresses requires more context
--   than just the public key (like the wallet root id and some extra logic
--   for encoding passphrases). This is just scheme-specific and is better
--   left out of this particular function</li>
--   </ul>
encodeAddress :: XPub -> [Encoding] -> Encoding
encodeAttributes :: [Encoding] -> Encoding
encodeDerivationPathAttr :: Passphrase "addr-derivation-payload" -> Index  'WholeDomain  'AccountK -> Index  'WholeDomain  'AddressK -> Encoding
encodeProtocolMagicAttr :: ProtocolMagic -> Encoding
encodePublicKeyWitness :: XPub -> ByteString -> Encoding
encodeTx :: ([TxIn], [TxOut]) -> Encoding
encodeSignedTx :: ([TxIn], [TxOut]) -> [ByteString] -> Encoding
encodeTxWitness :: ByteString -> Encoding

-- | Shortcut for deserialising a strict <tt>Bytestring</tt> with the given
--   decoder.
deserialiseCbor :: (forall s. Decoder s a) -> ByteString -> Maybe a

-- | Inspect the next token that has to be decoded and print it to the
--   console as a trace. Useful for debugging Decoders. Example:
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s MyType
--   myDecoder = do
--       a &lt;- CBOR.decodeWord64
--       inspectNextToken
--       [...]
--   </pre>
inspectNextToken :: Decoder s ()

-- | Decode an list of known length. Very similar to
--   <tt>decodeListIndef</tt>.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeList decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeList :: forall s a. Decoder s a -> Decoder s [a]

-- | Decode an arbitrary long list. CBOR introduce a "break" character to
--   mark the end of the list, so we simply decode each item until we
--   encounter a break character.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeListIndef decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeListIndef :: forall s a. Decoder s a -> Decoder s [a]


-- | Implementation of address derivation for the random scheme, as
--   implemented by the legacy Cardano wallets.
--   
--   For full documentation of the key derivation schemes, see the
--   <a>Cardano.Crypto.Wallet</a> module, and the implementation in
--   <a>cardano-crypto</a>.
module Cardano.Wallet.Primitive.AddressDerivation.Byron

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.
data ByronKey (depth :: Depth) key
ByronKey :: key -> DerivationPath depth -> Passphrase "addr-derivation-payload" -> ByronKey key

-- | The raw private or public key.
[getKey] :: ByronKey key -> key

-- | The address derivation indices for the level of this key.
[derivationPath] :: ByronKey key -> DerivationPath depth

-- | Used for encryption of payload containing address derivation path.
[payloadPassphrase] :: ByronKey key -> Passphrase "addr-derivation-payload"

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: DerivationPath depth -> SomeMnemonic -> Passphrase "encryption" -> ByronKey depth XPrv

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: SomeMnemonic -> Passphrase "encryption" -> ByronKey  'RootK XPrv

-- | The amount of entropy carried by a BIP-39 12-word mnemonic is 16
--   bytes.
minSeedLengthBytes :: Int

-- | Derives account private key from the given root private key, using
--   derivation scheme 1.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: Passphrase "encryption" -> ByronKey  'RootK XPrv -> Index  'WholeDomain  'AccountK -> ByronKey  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 1.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: Passphrase "encryption" -> ByronKey  'AccountK XPrv -> Index  'WholeDomain  'AddressK -> ByronKey  'AddressK XPrv

-- | Attempt decoding a <a>ByteString</a> into an <a>Address</a>. This
--   merely checks that the underlying bytestring has a "valid" structure /
--   format without doing much more.
decodeLegacyAddress :: ByteString -> Maybe Address
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Byron.DerivationPath depth)) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Byron.DerivationPath depth)) => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Byron.DerivationPath depth)) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Testnet Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey Cardano.Wallet.Primitive.Types.Address
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPrivateKey (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey 'Cardano.Wallet.Primitive.AddressDerivation.RootK)


-- | An implementation of address discovery for the random address scheme
--   as used by the legacy Cardano wallets.
module Cardano.Wallet.Primitive.AddressDiscovery.Random

-- | HD random address discovery state and key material for AD.
data RndState (network :: NetworkDiscriminant)
RndState :: Passphrase "addr-derivation-payload" -> Index  'WholeDomain  'AccountK -> Map DerivationPath Address -> Map DerivationPath Address -> StdGen -> RndState

-- | The HD derivation passphrase
[hdPassphrase] :: RndState -> Passphrase "addr-derivation-payload"

-- | The account index used for address _generation_ in this wallet. Note
--   that addresses will be _discovered_ from any and all account indices,
--   regardless of this value.
[accountIndex] :: RndState -> Index  'WholeDomain  'AccountK

-- | The addresses which have so far been discovered, and their derivation
--   paths.
[addresses] :: RndState -> Map DerivationPath Address

-- | The addresses which have been generated for use as change addresses,
--   and their derivation paths. Once addresses have been discovered they
--   are removed from this set and added to <a>addresses</a>.
[pendingAddresses] :: RndState -> Map DerivationPath Address

-- | The state of the RNG.
[gen] :: RndState -> StdGen

-- | Initialize the HD random address discovery state from a root key and
--   RNG seed.
mkRndState :: ByronKey  'RootK XPrv -> Int -> RndState n
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n) Cardano.Wallet.Primitive.Types.Address
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n) Cardano.Wallet.Primitive.Types.ChimericAccount
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n) Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)
instance Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)
instance Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)


-- | An implementation of the DBLayer which uses Persistent and SQLite.
module Cardano.Wallet.DB.Sqlite

-- | Sets up a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
--   
--   <tt>getDBLayer</tt> will provide the actual <a>DBLayer</a>
--   implementation. The database should be closed with
--   <a>destroyDBLayer</a>. If you use <a>withDBLayer</a> then both of
--   these things will be handled for you.
newDBLayer :: forall s k. (IsOurs s Address, IsOurs s ChimericAccount, NFData s, Show s, PersistState s, PersistPrivateKey (k  'RootK)) => Tracer IO DBLog -> DefaultFieldValues -> Maybe FilePath -> IO (SqliteContext, DBLayer IO s k)

-- | Instantiate a <a>DBFactory</a> from a given directory
newDBFactory :: forall s k. (IsOurs s Address, IsOurs s ChimericAccount, NFData s, Show s, PersistState s, PersistPrivateKey (k  'RootK), WalletKey k) => Tracer IO DBLog -> DefaultFieldValues -> Maybe FilePath -> IO (DBFactory IO s k)

-- | Return all wallet databases that match the specified key type within
--   the specified directory.
findDatabases :: forall k. WalletKey k => Tracer IO DatabasesStartupLog -> FilePath -> IO [WalletId]

-- | Runs an action with a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
withDBLayer :: forall s k a. (IsOurs s Address, IsOurs s ChimericAccount, NFData s, Show s, PersistState s, PersistPrivateKey (k  'RootK)) => Tracer IO DBLog -> DefaultFieldValues -> Maybe FilePath -> ((SqliteContext, DBLayer IO s k) -> IO a) -> IO a

-- | Functions for saving/loading the wallet's address discovery state into
--   SQLite.
class PersistState s

-- | Store the state for a checkpoint.
insertState :: PersistState s => (WalletId, SlotId) -> s -> SqlPersistT IO ()

-- | Load the state for a checkpoint.
selectState :: PersistState s => (WalletId, SlotId) -> SqlPersistT IO (Maybe s)

-- | A set of default field values that can be consulted when performing a
--   database migration.
newtype DefaultFieldValues
DefaultFieldValues :: ActiveSlotCoefficient -> DefaultFieldValues
[$sel:defaultActiveSlotCoefficient:DefaultFieldValues] :: DefaultFieldValues -> ActiveSlotCoefficient

-- | Log messages arising from accessing the wallet repository.
data DatabasesStartupLog
MsgFoundDatabase :: FilePath -> WalletId -> DatabasesStartupLog
MsgUnknownFile :: FilePath -> DatabasesStartupLog
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.DatabasesStartupLog
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.DatabasesStartupLog
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.ErrRollbackTo
instance Data.Text.Class.ToText Cardano.Wallet.DB.Sqlite.DatabasesStartupLog
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.Wallet.DB.Sqlite.DatabasesStartupLog
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.Wallet.DB.Sqlite.DatabasesStartupLog
instance (GHC.Classes.Eq (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK), Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK), Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint k (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n k, Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation k) => Cardano.Wallet.DB.Sqlite.PersistState (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Cardano.Wallet.DB.Sqlite.PersistState (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState t)
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.Sqlite.ErrRollbackTo


-- | Implementation of address derivation for <tt>Icarus</tt> keys. This
--   uses the Byron derivation for addresses, but on top of the derivation
--   scheme V2.
module Cardano.Wallet.Primitive.AddressDerivation.Icarus

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = IcarusKey 'RootK XPrv
--   let accountPubKey = IcarusKey 'AccountK XPub
--   let addressPubKey = IcarusKey 'AddressK XPub
--   </pre>
newtype IcarusKey (depth :: Depth) key
IcarusKey :: key -> IcarusKey key
[getKey] :: IcarusKey key -> key

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: SomeMnemonic -> Passphrase "encryption" -> IcarusKey  'RootK XPrv

-- | Hardware Ledger devices generates keys from mnemonic using a different
--   approach (different from the rest of Cardano).
--   
--   It is a combination of:
--   
--   <ul>
--   <li><a>SLIP 0010</a></li>
--   <li><a>BIP 0032</a></li>
--   <li><a>BIP 0039</a></li>
--   <li><a>RFC 8032</a></li>
--   <li>What seems to be arbitrary changes from Ledger regarding the
--   calculation of the initial chain code and generation of the root
--   private key.</li>
--   </ul>
generateKeyFromHardwareLedger :: SomeMnemonic -> Passphrase "encryption" -> IcarusKey  'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: SomeMnemonic -> Passphrase "encryption" -> IcarusKey depth XPrv

-- | The minimum seed length for <a>generateKeyFromSeed</a> and
--   <a>unsafeGenerateKeyFromSeed</a>.
minSeedLengthBytes :: Int
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.HardDerivation Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Testnet Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey Cardano.Wallet.Primitive.Types.Address
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPrivateKey (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey 'Cardano.Wallet.Primitive.AddressDerivation.RootK)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth)


-- | Utility functions for converting time values to and from text.
module Data.Time.Text

-- | Convert the specified time value to text, using the specified time
--   format.
utcTimeToText :: TimeFormat -> UTCTime -> Text

-- | Attempt to use each of the specified time formats to parse the given
--   text. Returns a time value that corresponds to the first matching
--   format, or <a>Nothing</a> if none of the formats matched.
utcTimeFromText :: [TimeFormat] -> Text -> Maybe UTCTime

-- | Represents a particular way of representing a moment in time in text.
data TimeFormat
TimeFormat :: String -> String -> TimeFormat
[timeFormatName] :: TimeFormat -> String
[timeFormatPattern] :: TimeFormat -> String

-- | Represents the ISO 8601 basic format (UTC).
iso8601BasicUtc :: TimeFormat

-- | Represents the ISO 8601 basic format (with local timezone).
iso8601BasicLocal :: TimeFormat

-- | Represents the ISO 8601 extended format (UTC).
iso8601ExtendedUtc :: TimeFormat

-- | Represents the ISO 8601 extended format (with local timezone).
iso8601ExtendedLocal :: TimeFormat

-- | Represents the ISO 8601 family of formats.
iso8601 :: [TimeFormat]

-- | Represents the ISO 8601 basic family of formats.
iso8601Basic :: [TimeFormat]

-- | Represents the ISO 8601 extended family of formats.
iso8601Extended :: [TimeFormat]
instance GHC.Classes.Eq Data.Time.Text.TimeFormat


-- | API type representations of various types. We define here pretty much
--   all our user-facing types that are mostly composed with internal /
--   primitive types.
--   
--   This module also define required API instances (JSON, HttpApiData...)
--   for all those types, making sure to match the specification document:
--   
--   <a>Wallet API Specification</a>
module Cardano.Wallet.Api.Types
data WalletStyle
Shelley :: WalletStyle
Byron :: WalletStyle
data ByronWalletStyle
Random :: ByronWalletStyle
Icarus :: ByronWalletStyle
Trezor :: ByronWalletStyle
Ledger :: ByronWalletStyle
type family StyleSymbol (style :: ByronWalletStyle) :: Symbol
type family AllowedMnemonics (style :: k) :: [Nat]
data ApiAddress (n :: NetworkDiscriminant)
ApiAddress :: !(ApiT Address, Proxy n) -> !ApiT AddressState -> ApiAddress
[$sel:id:ApiAddress] :: ApiAddress -> !(ApiT Address, Proxy n)
[$sel:state:ApiAddress] :: ApiAddress -> !ApiT AddressState
data ApiEpochInfo
ApiEpochInfo :: !ApiT EpochNo -> !UTCTime -> ApiEpochInfo
[$sel:epochNumber:ApiEpochInfo] :: ApiEpochInfo -> !ApiT EpochNo
[$sel:epochStartTime:ApiEpochInfo] :: ApiEpochInfo -> !UTCTime
newtype ApiSelectCoinsData (n :: NetworkDiscriminant)
ApiSelectCoinsData :: NonEmpty (AddressAmount n) -> ApiSelectCoinsData
[$sel:payments:ApiSelectCoinsData] :: ApiSelectCoinsData -> NonEmpty (AddressAmount n)
data ApiCoinSelection (n :: NetworkDiscriminant)
ApiCoinSelection :: !NonEmpty (ApiCoinSelectionInput n) -> !NonEmpty (AddressAmount n) -> ApiCoinSelection
[$sel:inputs:ApiCoinSelection] :: ApiCoinSelection -> !NonEmpty (ApiCoinSelectionInput n)
[$sel:outputs:ApiCoinSelection] :: ApiCoinSelection -> !NonEmpty (AddressAmount n)
data ApiCoinSelectionInput (n :: NetworkDiscriminant)
ApiCoinSelectionInput :: !ApiT (Hash "Tx") -> !Word32 -> !(ApiT Address, Proxy n) -> !Quantity "lovelace" Natural -> ApiCoinSelectionInput
[$sel:id:ApiCoinSelectionInput] :: ApiCoinSelectionInput -> !ApiT (Hash "Tx")
[$sel:index:ApiCoinSelectionInput] :: ApiCoinSelectionInput -> !Word32
[$sel:address:ApiCoinSelectionInput] :: ApiCoinSelectionInput -> !(ApiT Address, Proxy n)
[$sel:amount:ApiCoinSelectionInput] :: ApiCoinSelectionInput -> !Quantity "lovelace" Natural
data ApiStakePool
ApiStakePool :: !ApiT PoolId -> !ApiStakePoolMetrics -> !Double -> !Maybe StakePoolMetadata -> !Quantity "lovelace" Natural -> !Quantity "percent" Percentage -> !Double -> !Double -> ApiStakePool
[$sel:id:ApiStakePool] :: ApiStakePool -> !ApiT PoolId
[$sel:metrics:ApiStakePool] :: ApiStakePool -> !ApiStakePoolMetrics
[$sel:apparentPerformance:ApiStakePool] :: ApiStakePool -> !Double
[$sel:metadata:ApiStakePool] :: ApiStakePool -> !Maybe StakePoolMetadata
[$sel:cost:ApiStakePool] :: ApiStakePool -> !Quantity "lovelace" Natural
[$sel:margin:ApiStakePool] :: ApiStakePool -> !Quantity "percent" Percentage
[$sel:desirability:ApiStakePool] :: ApiStakePool -> !Double
[$sel:saturation:ApiStakePool] :: ApiStakePool -> !Double
data ApiStakePoolMetrics
ApiStakePoolMetrics :: !Quantity "lovelace" Natural -> !Quantity "block" Natural -> ApiStakePoolMetrics
[$sel:controlledStake:ApiStakePoolMetrics] :: ApiStakePoolMetrics -> !Quantity "lovelace" Natural
[$sel:producedBlocks:ApiStakePoolMetrics] :: ApiStakePoolMetrics -> !Quantity "block" Natural
data ApiWallet
ApiWallet :: !ApiT WalletId -> !ApiT AddressPoolGap -> !ApiT WalletBalance -> !ApiWalletDelegation -> !ApiT WalletName -> !Maybe (ApiT WalletPassphraseInfo) -> !ApiT SyncProgress -> !ApiBlockReference -> ApiWallet
[$sel:id:ApiWallet] :: ApiWallet -> !ApiT WalletId
[$sel:addressPoolGap:ApiWallet] :: ApiWallet -> !ApiT AddressPoolGap
[$sel:balance:ApiWallet] :: ApiWallet -> !ApiT WalletBalance
[$sel:delegation:ApiWallet] :: ApiWallet -> !ApiWalletDelegation
[$sel:name:ApiWallet] :: ApiWallet -> !ApiT WalletName
[$sel:passphrase:ApiWallet] :: ApiWallet -> !Maybe (ApiT WalletPassphraseInfo)
[$sel:state:ApiWallet] :: ApiWallet -> !ApiT SyncProgress
[$sel:tip:ApiWallet] :: ApiWallet -> !ApiBlockReference
newtype ApiWalletPassphrase
ApiWalletPassphrase :: ApiT (Passphrase "encryption") -> ApiWalletPassphrase
[$sel:passphrase:ApiWalletPassphrase] :: ApiWalletPassphrase -> ApiT (Passphrase "encryption")
data ApiUtxoStatistics
ApiUtxoStatistics :: !Quantity "lovelace" Natural -> !ApiT BoundType -> !Map Word64 Word64 -> ApiUtxoStatistics
[$sel:total:ApiUtxoStatistics] :: ApiUtxoStatistics -> !Quantity "lovelace" Natural
[$sel:scale:ApiUtxoStatistics] :: ApiUtxoStatistics -> !ApiT BoundType
[$sel:distribution:ApiUtxoStatistics] :: ApiUtxoStatistics -> !Map Word64 Word64
data WalletBalance
WalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> WalletBalance
[$sel:available:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:total:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:reward:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
data WalletPostData
WalletPostData :: !Maybe (ApiT AddressPoolGap) -> !ApiMnemonicT (AllowedMnemonics  'Shelley) -> !Maybe (ApiMnemonicT (AllowedMnemonics  'SndFactor)) -> !ApiT WalletName -> !ApiT (Passphrase "encryption") -> WalletPostData
[$sel:addressPoolGap:WalletPostData] :: WalletPostData -> !Maybe (ApiT AddressPoolGap)
[$sel:mnemonicSentence:WalletPostData] :: WalletPostData -> !ApiMnemonicT (AllowedMnemonics  'Shelley)
[$sel:mnemonicSecondFactor:WalletPostData] :: WalletPostData -> !Maybe (ApiMnemonicT (AllowedMnemonics  'SndFactor))
[$sel:name:WalletPostData] :: WalletPostData -> !ApiT WalletName
[$sel:passphrase:WalletPostData] :: WalletPostData -> !ApiT (Passphrase "encryption")
newtype WalletPutData
WalletPutData :: Maybe (ApiT WalletName) -> WalletPutData
[$sel:name:WalletPutData] :: WalletPutData -> Maybe (ApiT WalletName)
data WalletPutPassphraseData
WalletPutPassphraseData :: !ApiT (Passphrase "encryption-old") -> !ApiT (Passphrase "encryption-new") -> WalletPutPassphraseData
[$sel:oldPassphrase:WalletPutPassphraseData] :: WalletPutPassphraseData -> !ApiT (Passphrase "encryption-old")
[$sel:newPassphrase:WalletPutPassphraseData] :: WalletPutPassphraseData -> !ApiT (Passphrase "encryption-new")
data PostTransactionData n
PostTransactionData :: !NonEmpty (AddressAmount n) -> !ApiT (Passphrase "encryption") -> PostTransactionData n
[$sel:payments:PostTransactionData] :: PostTransactionData n -> !NonEmpty (AddressAmount n)
[$sel:passphrase:PostTransactionData] :: PostTransactionData n -> !ApiT (Passphrase "encryption")
newtype PostTransactionFeeData n
PostTransactionFeeData :: NonEmpty (AddressAmount n) -> PostTransactionFeeData n
[$sel:payments:PostTransactionFeeData] :: PostTransactionFeeData n -> NonEmpty (AddressAmount n)
newtype PostExternalTransactionData
PostExternalTransactionData :: ByteString -> PostExternalTransactionData
[$sel:payload:PostExternalTransactionData] :: PostExternalTransactionData -> ByteString
data ApiTimeReference
ApiTimeReference :: !UTCTime -> !ApiBlockReference -> ApiTimeReference
[$sel:time:ApiTimeReference] :: ApiTimeReference -> !UTCTime
[$sel:block:ApiTimeReference] :: ApiTimeReference -> !ApiBlockReference
data ApiTransaction n
ApiTransaction :: !ApiT (Hash "Tx") -> !Quantity "lovelace" Natural -> !Maybe ApiTimeReference -> !Maybe ApiTimeReference -> !Quantity "block" Natural -> !ApiT Direction -> ![ApiTxInput n] -> ![AddressAmount n] -> !ApiT TxStatus -> ApiTransaction n
[$sel:id:ApiTransaction] :: ApiTransaction n -> !ApiT (Hash "Tx")
[$sel:amount:ApiTransaction] :: ApiTransaction n -> !Quantity "lovelace" Natural
[$sel:insertedAt:ApiTransaction] :: ApiTransaction n -> !Maybe ApiTimeReference
[$sel:pendingSince:ApiTransaction] :: ApiTransaction n -> !Maybe ApiTimeReference
[$sel:depth:ApiTransaction] :: ApiTransaction n -> !Quantity "block" Natural
[$sel:direction:ApiTransaction] :: ApiTransaction n -> !ApiT Direction
[$sel:inputs:ApiTransaction] :: ApiTransaction n -> ![ApiTxInput n]
[$sel:outputs:ApiTransaction] :: ApiTransaction n -> ![AddressAmount n]
[$sel:status:ApiTransaction] :: ApiTransaction n -> !ApiT TxStatus
newtype ApiFee
ApiFee :: Quantity "lovelace" Natural -> ApiFee
[$sel:amount:ApiFee] :: ApiFee -> Quantity "lovelace" Natural
newtype ApiTxId
ApiTxId :: ApiT (Hash "Tx") -> ApiTxId
[$sel:id:ApiTxId] :: ApiTxId -> ApiT (Hash "Tx")
data ApiTxInput n
ApiTxInput :: !Maybe (AddressAmount n) -> !ApiT TxIn -> ApiTxInput n
[$sel:source:ApiTxInput] :: ApiTxInput n -> !Maybe (AddressAmount n)
[$sel:input:ApiTxInput] :: ApiTxInput n -> !ApiT TxIn
data AddressAmount (n :: NetworkDiscriminant)
AddressAmount :: !(ApiT Address, Proxy n) -> !Quantity "lovelace" Natural -> AddressAmount
[$sel:address:AddressAmount] :: AddressAmount -> !(ApiT Address, Proxy n)
[$sel:amount:AddressAmount] :: AddressAmount -> !Quantity "lovelace" Natural

-- | Error codes returned by the API, in the form of snake_cased strings
data ApiErrorCode
NoSuchWallet :: ApiErrorCode
NoSuchTransaction :: ApiErrorCode
TransactionNotPending :: ApiErrorCode
WalletAlreadyExists :: ApiErrorCode
NoRootKey :: ApiErrorCode
WrongEncryptionPassphrase :: ApiErrorCode
MalformedTxPayload :: ApiErrorCode
KeyNotFoundForAddress :: ApiErrorCode
NotEnoughMoney :: ApiErrorCode
UtxoNotEnoughFragmented :: ApiErrorCode
TransactionIsTooBig :: ApiErrorCode
InputsDepleted :: ApiErrorCode
CannotCoverFee :: ApiErrorCode
InvalidCoinSelection :: ApiErrorCode
NetworkUnreachable :: ApiErrorCode
NetworkMisconfigured :: ApiErrorCode
NetworkTipNotFound :: ApiErrorCode
CreatedInvalidTransaction :: ApiErrorCode
RejectedByCoreNode :: ApiErrorCode
BadRequest :: ApiErrorCode
NotFound :: ApiErrorCode
MethodNotAllowed :: ApiErrorCode
NotAcceptable :: ApiErrorCode
StartTimeLaterThanEndTime :: ApiErrorCode
UnsupportedMediaType :: ApiErrorCode
UnexpectedError :: ApiErrorCode
NotSynced :: ApiErrorCode
NothingToMigrate :: ApiErrorCode
NoSuchPool :: ApiErrorCode
PoolAlreadyJoined :: ApiErrorCode
NotDelegatingTo :: ApiErrorCode
InvalidRestorationParameters :: ApiErrorCode
RejectedTip :: ApiErrorCode
NoSuchEpochNo :: ApiErrorCode
InvalidDelegationDiscovery :: ApiErrorCode
data ApiNetworkInformation
ApiNetworkInformation :: !ApiT SyncProgress -> !ApiEpochInfo -> !ApiBlockReference -> !ApiNetworkTip -> ApiNetworkInformation
[$sel:syncProgress:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiT SyncProgress
[$sel:nextEpoch:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiEpochInfo
[$sel:nodeTip:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiBlockReference
[$sel:networkTip:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiNetworkTip
data ApiNtpStatus
ApiNtpStatus :: !NtpSyncingStatus -> !Maybe (Quantity "microsecond" Integer) -> ApiNtpStatus
[$sel:status:ApiNtpStatus] :: ApiNtpStatus -> !NtpSyncingStatus
[$sel:offset:ApiNtpStatus] :: ApiNtpStatus -> !Maybe (Quantity "microsecond" Integer)
data NtpSyncingStatus
NtpSyncingStatusUnavailable :: NtpSyncingStatus
NtpSyncingStatusPending :: NtpSyncingStatus
NtpSyncingStatusAvailable :: NtpSyncingStatus
newtype ApiNetworkClock
ApiNetworkClock :: ApiNtpStatus -> ApiNetworkClock
[$sel:ntpStatus:ApiNetworkClock] :: ApiNetworkClock -> ApiNtpStatus
data ApiBlockReference
ApiBlockReference :: !ApiT EpochNo -> !ApiT SlotNo -> !Quantity "block" Natural -> ApiBlockReference
[$sel:epochNumber:ApiBlockReference] :: ApiBlockReference -> !ApiT EpochNo
[$sel:slotNumber:ApiBlockReference] :: ApiBlockReference -> !ApiT SlotNo
[$sel:height:ApiBlockReference] :: ApiBlockReference -> !Quantity "block" Natural
data ApiNetworkTip
ApiNetworkTip :: !ApiT EpochNo -> !ApiT SlotNo -> ApiNetworkTip
[$sel:epochNumber:ApiNetworkTip] :: ApiNetworkTip -> !ApiT EpochNo
[$sel:slotNumber:ApiNetworkTip] :: ApiNetworkTip -> !ApiT SlotNo

-- | Defines a point in time that can be formatted as and parsed from an
--   ISO 8601-compliant string.
newtype Iso8601Time
Iso8601Time :: UTCTime -> Iso8601Time
[$sel:getIso8601Time:Iso8601Time] :: Iso8601Time -> UTCTime
data ApiEpochNumber
ApiEpochNumberLatest :: ApiEpochNumber
ApiEpochNumber :: EpochNo -> ApiEpochNumber
data ApiNetworkParameters
ApiNetworkParameters :: !ApiT (Hash "Genesis") -> !ApiT StartTime -> !Quantity "second" NominalDiffTime -> !Quantity "slot" Word32 -> !Quantity "block" Word32 -> !Quantity "percent" Double -> ApiNetworkParameters
[$sel:genesisBlockHash:ApiNetworkParameters] :: ApiNetworkParameters -> !ApiT (Hash "Genesis")
[$sel:blockchainStartTime:ApiNetworkParameters] :: ApiNetworkParameters -> !ApiT StartTime
[$sel:slotLength:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "second" NominalDiffTime
[$sel:epochLength:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "slot" Word32
[$sel:epochStability:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "block" Word32
[$sel:activeSlotCoefficient:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "percent" Double
toApiNetworkParameters :: BlockchainParameters -> ApiNetworkParameters
data ApiWalletDelegation
ApiWalletDelegation :: !ApiWalletDelegationNext -> ![ApiWalletDelegationNext] -> ApiWalletDelegation
[$sel:active:ApiWalletDelegation] :: ApiWalletDelegation -> !ApiWalletDelegationNext
[$sel:next:ApiWalletDelegation] :: ApiWalletDelegation -> ![ApiWalletDelegationNext]
data ApiWalletDelegationStatus
NotDelegating :: ApiWalletDelegationStatus
Delegating :: ApiWalletDelegationStatus
data ApiWalletDelegationNext
ApiWalletDelegationNext :: !ApiWalletDelegationStatus -> !Maybe (ApiT PoolId) -> !Maybe ApiEpochInfo -> ApiWalletDelegationNext
[$sel:status:ApiWalletDelegationNext] :: ApiWalletDelegationNext -> !ApiWalletDelegationStatus
[$sel:target:ApiWalletDelegationNext] :: ApiWalletDelegationNext -> !Maybe (ApiT PoolId)
[$sel:changesAt:ApiWalletDelegationNext] :: ApiWalletDelegationNext -> !Maybe ApiEpochInfo
data ApiPoolId
ApiPoolIdPlaceholder :: ApiPoolId
ApiPoolId :: PoolId -> ApiPoolId
data ApiByronWallet
ApiByronWallet :: !ApiT WalletId -> !ApiByronWalletBalance -> !ApiT WalletName -> !Maybe (ApiT WalletPassphraseInfo) -> !ApiT SyncProgress -> !ApiBlockReference -> ApiByronWallet
[$sel:id:ApiByronWallet] :: ApiByronWallet -> !ApiT WalletId
[$sel:balance:ApiByronWallet] :: ApiByronWallet -> !ApiByronWalletBalance
[$sel:name:ApiByronWallet] :: ApiByronWallet -> !ApiT WalletName
[$sel:passphrase:ApiByronWallet] :: ApiByronWallet -> !Maybe (ApiT WalletPassphraseInfo)
[$sel:state:ApiByronWallet] :: ApiByronWallet -> !ApiT SyncProgress
[$sel:tip:ApiByronWallet] :: ApiByronWallet -> !ApiBlockReference
data ApiByronWalletBalance
ApiByronWalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> ApiByronWalletBalance
[$sel:available:ApiByronWalletBalance] :: ApiByronWalletBalance -> !Quantity "lovelace" Natural
[$sel:total:ApiByronWalletBalance] :: ApiByronWalletBalance -> !Quantity "lovelace" Natural
newtype ApiByronWalletMigrationInfo
ApiByronWalletMigrationInfo :: Quantity "lovelace" Natural -> ApiByronWalletMigrationInfo
[$sel:migrationCost:ApiByronWalletMigrationInfo] :: ApiByronWalletMigrationInfo -> Quantity "lovelace" Natural
data ByronWalletPostData mw
ByronWalletPostData :: !ApiMnemonicT mw -> !ApiT WalletName -> !ApiT (Passphrase "encryption") -> ByronWalletPostData mw
[$sel:mnemonicSentence:ByronWalletPostData] :: ByronWalletPostData mw -> !ApiMnemonicT mw
[$sel:name:ByronWalletPostData] :: ByronWalletPostData mw -> !ApiT WalletName
[$sel:passphrase:ByronWalletPostData] :: ByronWalletPostData mw -> !ApiT (Passphrase "encryption")
data SomeByronWalletPostData
SomeRandomWallet :: ByronWalletPostData (AllowedMnemonics  'Random) -> SomeByronWalletPostData
SomeIcarusWallet :: ByronWalletPostData (AllowedMnemonics  'Icarus) -> SomeByronWalletPostData
SomeTrezorWallet :: ByronWalletPostData (AllowedMnemonics  'Trezor) -> SomeByronWalletPostData
SomeLedgerWallet :: ByronWalletPostData (AllowedMnemonics  'Ledger) -> SomeByronWalletPostData
data AccountPostData
AccountPostData :: !ApiT WalletName -> !ApiAccountPublicKey -> !Maybe (ApiT AddressPoolGap) -> AccountPostData
[$sel:name:AccountPostData] :: AccountPostData -> !ApiT WalletName
[$sel:accountPublicKey:AccountPostData] :: AccountPostData -> !ApiAccountPublicKey
[$sel:addressPoolGap:AccountPostData] :: AccountPostData -> !Maybe (ApiT AddressPoolGap)
newtype ApiAccountPublicKey
ApiAccountPublicKey :: ApiT (ShelleyKey  'AccountK XPub) -> ApiAccountPublicKey
[$sel:key:ApiAccountPublicKey] :: ApiAccountPublicKey -> ApiT (ShelleyKey  'AccountK XPub)
newtype WalletOrAccountPostData
WalletOrAccountPostData :: Either WalletPostData AccountPostData -> WalletOrAccountPostData
[$sel:postData:WalletOrAccountPostData] :: WalletOrAccountPostData -> Either WalletPostData AccountPostData

-- | An abstract class to allow encoding of addresses depending on the
--   target backend used.
class EncodeAddress (n :: NetworkDiscriminant)
encodeAddress :: EncodeAddress n => Address -> Text

-- | An abstract class to allow decoding of addresses depending on the
--   target backend used.
class DecodeAddress (n :: NetworkDiscriminant)
decodeAddress :: DecodeAddress n => Text -> Either TextDecodingError Address

-- | Polymorphic wrapper type to put around primitive types and, 3rd party
--   lib types to avoid defining orphan instances and/or, undesirable
--   instances on primitive types. It helps to keep a nice separation of
--   concerns between the API layer and other modules.
newtype ApiT a
ApiT :: a -> ApiT a
[$sel:getApiT:ApiT] :: ApiT a -> a

-- | Representation of mnemonics at the API-level, using a polymorphic type
--   in the lengths of mnemonics that are supported (and an underlying
--   purpose). In practice, mnemonics correspond to passphrases or seeds,
--   and although they're nice to manipulate as mnemonics from a
--   user-perspective, carrying around a list of words doesn't really make
--   sense for the business logic, which prefers manipulating scrubbed
--   bytes directly.
--   
--   <pre>
--   data MyWallet
--       { mnemonic :: ApiMnemonicT '[15,18,21,24]
--       }
--   </pre>
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
--   
--   Also, the internal representation holds a <tt>[Text]</tt> which
--   contains the list of mnemonic words that was parsed. This is only to
--   be able to implement the <a>ToJSON</a> instances and roundtrip, which
--   is a very dubious argument. In practice, we'll NEVER peek at the
--   mnemonic, output them and whatnot.
newtype ApiMnemonicT (sizes :: [Nat])
ApiMnemonicT :: SomeMnemonic -> ApiMnemonicT
[$sel:getApiMnemonicT:ApiMnemonicT] :: ApiMnemonicT -> SomeMnemonic
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiByronWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiByronWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiByronWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Show.Show Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiAddress n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiAddress n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiAddress n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletDelegation
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletDelegation
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletDelegation
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkInformation
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkInformation
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkInformation
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiEpochInfo
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiEpochInfo
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiEpochInfo
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiCoinSelectionInput n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiCoinSelectionInput n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiCoinSelectionInput n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiStakePool
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiStakePool
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiStakePool
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Show.Show Cardano.Wallet.Api.Types.AccountPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.AccountPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.AccountPostData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Show.Show (Cardano.Wallet.Api.Types.PostTransactionData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.PostTransactionData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.PostTransactionData n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkParameters
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkParameters
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkParameters
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTransaction n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTransaction n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTransaction n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTxInput n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTxInput n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTxInput n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.PostTransactionFeeData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.PostTransactionFeeData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.PostTransactionFeeData n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.AddressAmount n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.AddressAmount n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.AddressAmount n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTimeReference
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTimeReference
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTimeReference
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiBlockReference
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiBlockReference
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiBlockReference
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkTip
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkTip
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkTip
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiByronWalletMigrationInfo
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiByronWalletMigrationInfo
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiByronWalletMigrationInfo
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPoolId
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPoolId
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPoolId
instance GHC.Show.Show Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkClock
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkClock
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkClock
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNtpStatus
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNtpStatus
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNtpStatus
instance GHC.Show.Show Cardano.Wallet.Api.Types.NtpSyncingStatus
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.NtpSyncingStatus
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.NtpSyncingStatus
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiEpochNumber
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiEpochNumber
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiEpochNumber
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiFee
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiFee
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiFee
instance GHC.Show.Show Cardano.Wallet.Api.Types.PostExternalTransactionData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.PostExternalTransactionData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.PostExternalTransactionData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance GHC.Enum.Enum Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Enum.Bounded Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Show.Show Cardano.Wallet.Api.Types.ByronWalletStyle
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiAddress n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionInput n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address, Data.Proxy.Proxy n)
instance Cardano.Wallet.Api.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.PostTransactionData t)
instance Cardano.Wallet.Api.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.PostTransactionFeeData t)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.AddressAmount n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTransaction n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTxInput n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Text.Class.FromText (Cardano.Wallet.Api.Types.AddressAmount n)
instance Cardano.Wallet.Api.Types.DecodeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet
instance Cardano.Wallet.Api.Types.DecodeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Testnet
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiAddress n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionInput n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address, Data.Proxy.Proxy n)
instance Cardano.Wallet.Api.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.PostTransactionData t)
instance Cardano.Wallet.Api.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.PostTransactionFeeData t)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.AddressAmount n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTransaction n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTxInput n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Text.Class.ToText (Cardano.Wallet.Api.Types.AddressAmount n)
instance Cardano.Wallet.Api.Types.EncodeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet
instance Cardano.Wallet.Api.Types.EncodeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Testnet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiByronWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiByronWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic mw => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic sizes => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletDelegation
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletDelegation
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkInformation
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkInformation
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiEpochInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiEpochInfo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiStakePool
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiStakePool
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.AccountPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.AccountPostData
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkParameters
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkParameters
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTxId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTxId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.ApiTxId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.ApiTxId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTimeReference
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTimeReference
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiBlockReference
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiBlockReference
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkTip
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkTip
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.AddressState)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.AddressState)
instance (Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength purpose, Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength purpose) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletBalance)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletBalance)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletPassphraseInfo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletPassphraseInfo)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SyncProgress)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SyncProgress)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.BoundType)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.BoundType)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochNo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochNo)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotNo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotNo)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxIn)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxIn)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Tx"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Tx"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Direction)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Direction)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxStatus)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxStatus)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StartTime)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StartTime)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotLength)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotLength)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochLength)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochLength)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Genesis"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Genesis"))
instance Data.Text.Class.FromText a => Web.Internal.HttpApiData.FromHttpApiData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Text.Class.ToText a => Web.Internal.HttpApiData.ToHttpApiData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiByronWalletMigrationInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiByronWalletMigrationInfo
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.ApiPoolId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.ApiPoolId
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.Iso8601Time
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.Iso8601Time
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.Iso8601Time
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.Iso8601Time
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiErrorCode
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkClock
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkClock
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNtpStatus
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNtpStatus
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.ApiEpochNumber
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.ApiEpochNumber
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.ApiEpochNumber
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.ApiEpochNumber
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiFee
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiFee
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.PostExternalTransactionData
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream Cardano.Wallet.Api.Types.PostExternalTransactionData
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream Cardano.Wallet.Api.Types.PostExternalTransactionData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.ByronWalletStyle
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.ByronWalletStyle

module Cardano.Wallet.Unsafe

-- | Decode an hex-encoded <a>ByteString</a> into raw bytes, or fail.
unsafeFromHex :: HasCallStack => ByteString -> ByteString

-- | Load a hex string from file. Any non-hexadecimal characters are
--   ignored.
unsafeFromHexFile :: HasCallStack => FilePath -> IO ByteString

-- | Decode a bech32-encoded <a>Text</a> into an <a>Address</a>, or fail.
unsafeDecodeAddress :: forall n. (HasCallStack, DecodeAddress n) => Text -> Address

-- | Run a decoder on a hex-encoded <a>ByteString</a>, or fail.
unsafeDecodeHex :: HasCallStack => Get a -> ByteString -> a

-- | Decode the given data-type from a textual representation, or fail.
unsafeFromText :: (FromText a, HasCallStack) => Text -> a

-- | Run an <a>ExceptT</a> and throws the error if any. This makes sense
--   only if called after checking for an invariant or, after ensuring that
--   preconditions for meeting the underlying error have been discarded.
unsafeRunExceptT :: (MonadFail m, Show e) => ExceptT e m a -> m a

-- | Build a <a>XPrv</a> from a bytestring
unsafeXPrv :: HasCallStack => ByteString -> XPrv

-- | CBOR deserialise without error handling - handy for prototypes or
--   testing.
unsafeDeserialiseCbor :: HasCallStack => (forall s. Decoder s a) -> ByteString -> a

-- | Load the data part of a bech32-encoded string from file. These files
--   often come from <tt>jcli</tt>. Only the first line of the file is
--   read.
unsafeBech32DecodeFile :: HasCallStack => FilePath -> IO ByteString

-- | Get the data part of a bech32-encoded string, ignoring the
--   human-readable part.
unsafeBech32Decode :: HasCallStack => Text -> ByteString
unsafeMkPercentage :: HasCallStack => Rational -> Percentage

-- | A dummy <tt>SomeMnemonic</tt> for testing.
--   
--   Could have been named <tt>dummySomeMnemonic</tt>, but this way it
--   sounds more like valid english.
someDummyMnemonic :: forall mw ent csz. (HasCallStack, ValidEntropySize ent, ValidChecksumSize ent csz, ValidMnemonicSentence mw, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Proxy mw -> SomeMnemonic

-- | Build <a>Mnemonic</a> from literals
unsafeMkMnemonic :: forall mw n csz. (ConsistentEntropy n mw csz, EntropySize mw ~ n, HasCallStack) => [Text] -> Mnemonic mw
unsafeMkEntropy :: forall ent csz. (HasCallStack, ValidEntropySize ent, ValidChecksumSize ent csz) => ByteString -> Entropy ent
unsafeMkSomeMnemonicFromEntropy :: forall mw ent csz. (HasCallStack, ValidEntropySize ent, ValidChecksumSize ent csz, ValidMnemonicSentence mw, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Proxy mw -> ByteString -> SomeMnemonic


-- | A self contained module for ranking pools according to the delegation
--   design spec <i>Design Specification for Delegation and Incentives in
--   Cardano</i> <a>(Kant et al, 2019)</a>.
--   
--   The module currently implements the non-myopic desirability, and might
--   later support calculating the full non-myopic pool member rewards. The
--   latter being the recomended way to rank stake-pools (see section 4.3).
--   
--   The term non-myopic is explained on page 37:
--   
--   <pre>
--   It would be short-sighted (“myopic”) for stakeholders to directly use the
--   reward splitting formulas from Section 6.5. They should instead take the
--   long-term (“non-myopic”) view. To this end, the system will calculate and
--   display the “non-myopic” rewards that pool leaders and pool members can
--   expect, thus supporting stakeholders in their decision whether to create a
--   pool and to which pool to delegate their stake.
--   
--   The idea is to first rank all pools by “desirability”, to then assume that
--   the k most desirable pools will eventually be saturated, whereas all other
--   pools will lose all their members, then to finally base all reward
--   calculations on these assumptions.
--   </pre>
--   
--   <h2>Relevant identifiers</h2>
--   
--   Epoch Parameters
--   
--   TODO: table
--   
--   Pool's Parameters
--   
--   TODO: table
module Cardano.Pool.Ranking

-- | Non-myopic pool desirability according to section 5.6.1.
--   
--   Is <i>not</i> affected by oversaturation nor pool stake in general.
desirability :: EpochConstants -> Pool -> Double

-- | The saturation-level of a pool indicate how far a pool is from the
--   desired relative stake fixed by the network. A saturation level above
--   1 means that the pool is satured. A level of 0.5 / 50% means that the
--   pool owns half the ideal stake.
--   
--   The saturation corresponds therefore to the ratio between the ideal
--   relative stake of a pool on the actual relative stake of that pool.
--   
--   The ideal relative stake is given by:
--   
--   1 S 1 σ_ideal = --- * --- = --- = z0 (where S stands for the total
--   available S k k stake in Ada)
--   
--   which gives us the saturation as:
--   
--   σ σ sat = --------- = ---- σ_ideal z0
saturation :: EpochConstants -> Quantity "lovelace" Word64 -> Quantity "lovelace" Word64 -> Double

-- | Total rewards for a pool if it were saturated.
--   
--   When a0 = 0 this reduces to just p*R*z0 (tested by
--   <tt>prop_saturatedPoolRewardsReduces</tt>)
saturatedPoolRewards :: EpochConstants -> Pool -> Double

-- | Determines z0, i.e 1 / k
saturatedPoolSize :: EpochConstants -> Percentage
data EpochConstants
EpochConstants :: NonNegative Double -> Positive Int -> Quantity "lovelace" Word64 -> EpochConstants

-- | a_0
[leaderStakeInfluence] :: EpochConstants -> NonNegative Double

-- | k
[desiredNumberOfPools] :: EpochConstants -> Positive Int

-- | Total rewards in an epoch. <a>R</a> in the spec.
[totalRewards] :: EpochConstants -> Quantity "lovelace" Word64
data Pool
Pool :: Percentage -> Quantity "lovelace" Word64 -> Percentage -> NonNegative Double -> Pool

-- | s
[leaderStake] :: Pool -> Percentage

-- | c
[cost] :: Pool -> Quantity "lovelace" Word64

-- | m
[margin] :: Pool -> Percentage

-- | hat{p}, an already averaged (apparent) performance-value.
--   
--   Should mostly be in the range [0, 1]. May be higher than 1 due to
--   randomness.
[recentAvgPerformance] :: Pool -> NonNegative Double
newtype NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a
newtype Positive a
Positive :: a -> Positive a
[getPositive] :: Positive a -> a
unsafeMkPositive :: (Ord a, Show a, Num a) => a -> Positive a
unsafeMkNonNegative :: (Ord a, Show a, Num a) => a -> NonNegative a
instance GHC.Generics.Generic Cardano.Pool.Ranking.EpochConstants
instance GHC.Classes.Eq Cardano.Pool.Ranking.EpochConstants
instance GHC.Show.Show Cardano.Pool.Ranking.EpochConstants
instance GHC.Generics.Generic Cardano.Pool.Ranking.Pool
instance GHC.Classes.Eq Cardano.Pool.Ranking.Pool
instance GHC.Show.Show Cardano.Pool.Ranking.Pool
instance GHC.Num.Num a => GHC.Num.Num (Cardano.Pool.Ranking.NonNegative a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Pool.Ranking.NonNegative a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Pool.Ranking.NonNegative a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Pool.Ranking.NonNegative a)
instance GHC.Generics.Generic (Cardano.Pool.Ranking.NonNegative a)
instance GHC.Num.Num a => GHC.Num.Num (Cardano.Pool.Ranking.Positive a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Pool.Ranking.Positive a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Pool.Ranking.Positive a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Pool.Ranking.Positive a)
instance GHC.Generics.Generic (Cardano.Pool.Ranking.Positive a)
instance Formatting.Buildable.Buildable Cardano.Pool.Ranking.EpochConstants


-- | An implementation of the DBLayer which uses Persistent and SQLite.
module Cardano.Pool.DB.Sqlite

-- | Sets up a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
--   
--   <tt>getDBLayer</tt> will provide the actual <a>DBLayer</a>
--   implementation. The database should be closed with
--   <a>destroyDBLayer</a>. If you use <a>withDBLayer</a> then both of
--   these things will be handled for you.
newDBLayer :: Tracer IO DBLog -> Maybe FilePath -> IO (SqliteContext, DBLayer IO)

-- | Runs an action with a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
withDBLayer :: Tracer IO DBLog -> Maybe FilePath -> (DBLayer IO -> IO a) -> IO a

-- | Return the preferred <tt>FilePath</tt> for the stake pool .sqlite
--   file, given a parent directory.
defaultFilePath :: FilePath -> FilePath


-- | Utility functions for manipulating time values.
module Data.Time.Utils

-- | For a given time <tt>t0</tt>, get the closest representable time
--   <tt>t1</tt> to <tt>t0</tt> for which 't1 &lt; t0'.
utcTimePred :: UTCTime -> UTCTime

-- | For a given time <tt>t0</tt>, get the closest representable time
--   <tt>t1</tt> to <tt>t0</tt> for which 't0 &lt; t1'.
utcTimeSucc :: UTCTime -> UTCTime

module Data.Vector.Shuffle

-- | Shuffles a list of elements.
--   
--   <pre>
--   &gt;&gt;&gt; shuffle (outputs coinSel)
--   [...]
--   </pre>
shuffle :: [a] -> IO [a]

-- | Generate a random generator seed from a text string
mkSeed :: Text -> StdGen

-- | Like <a>shuffle</a>, but from a given seed. <a>shuffle</a> will use a
--   randomly generate seed using <a>newStdGen</a> from
--   <tt>System.Random</tt>.
--   
--   <b>Properties:</b>
--   
--   <ul>
--   <li><pre>shuffleWith g es == shuffleWith g es</pre></li>
--   <li><pre>∃Δ&gt; 1. g ≠g', length es &gt; Δ⇒ shuffleWith g es
--   ≠shuffleWith g' es</pre></li>
--   </ul>
shuffleWith :: RandomGen g => g -> [a] -> IO [a]


-- | Provides wallet layer functions that are used by API layer. Uses both
--   <a>Cardano.Wallet.DB</a> and <a>Cardano.Wallet.Network</a> to realize
--   its role as being intermediary between the three.
--   
--   Functions of the wallet layer are often parameterized with variables
--   following the convention below:
--   
--   <ul>
--   <li><tt>s</tt>: A <b>s</b>tate used to keep track of known addresses.
--   Typically, possible values for this parameter are described in
--   <a>AddressDiscovery</a> sub-modules. For instance <tt>SeqState</tt> or
--   <tt>Rnd State</tt>.</li>
--   <li><tt>t</tt>: A <b>t</b>arget backend which captures details
--   specific to a particular chain producer (binary formats, fee policy,
--   networking layer).</li>
--   <li><tt>k</tt>: A <b>k</b>ey derivation scheme intrisically connected
--   to the underlying discovery state <tt>s</tt>. This describes how the
--   hierarchical structure of a wallet is defined as well as the
--   relationship between secret keys and public addresses.</li>
--   </ul>
module Cardano.Wallet
data WalletLayer s t (k :: Depth -> * -> *)
WalletLayer :: Tracer IO WalletLog -> (Block, BlockchainParameters, SyncTolerance) -> NetworkLayer IO t Block -> TransactionLayer t k -> DBLayer IO s k -> WalletLayer s t
type HasDBLayer s k = HasType (DBLayer IO s k)
dbLayer :: forall s k ctx. HasDBLayer s k ctx => Lens' ctx (DBLayer IO s k)
type HasLogger msg = HasType (Tracer IO msg)
logger :: forall msg ctx. HasLogger msg ctx => Lens' ctx (Tracer IO msg)

-- | This module is only interested in one block-, and tx-type. This
--   constraint hides that choice, for some ease of use.
type HasNetworkLayer t = HasType (NetworkLayer IO t Block)
networkLayer :: forall t ctx. HasNetworkLayer t ctx => Lens' ctx (NetworkLayer IO t Block)
type HasTransactionLayer t k = HasType (TransactionLayer t k)
transactionLayer :: forall t k ctx. HasTransactionLayer t k ctx => Lens' ctx (TransactionLayer t k)
type HasGenesisData = HasType (Block, BlockchainParameters, SyncTolerance)
genesisData :: forall ctx. HasGenesisData ctx => Lens' ctx (Block, BlockchainParameters, SyncTolerance)

-- | Initialise and store a new wallet, returning its ID.
createWallet :: forall ctx s k. (HasGenesisData ctx, HasDBLayer s k ctx, Show s, NFData s, IsOurs s Address, IsOurs s ChimericAccount) => ctx -> WalletId -> WalletName -> s -> ExceptT ErrWalletAlreadyExists IO WalletId

-- | Initialise and store a new legacy Icarus wallet. These wallets are
--   intrinsically sequential, but, in the incentivized testnet, we only
--   have access to the a snapshot of the MainNet.
--   
--   To work-around this, we scan the genesis block with an arbitrary big
--   gap and resort to a default gap afterwards.
createIcarusWallet :: forall ctx s k n. (HasGenesisData ctx, HasDBLayer s k ctx, PaymentAddress n k, k ~ IcarusKey, s ~ SeqState n k) => ctx -> WalletId -> WalletName -> (k  'RootK XPrv, Passphrase "encryption") -> ExceptT ErrWalletAlreadyExists IO WalletId

-- | Attach a given private key to a wallet. The private key is necessary
--   for some operations like signing transactions, or generating new
--   accounts.
attachPrivateKey :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> (k  'RootK XPrv, Passphrase "encryption") -> ExceptT ErrNoSuchWallet IO ()

-- | List the wallet's UTxO statistics.
listUtxoStatistics :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> ExceptT ErrListUTxOStatistics IO UTxOStatistics

-- | Retrieve the wallet state for the wallet with the given ID.
readWallet :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO (Wallet s, WalletMetadata, Set Tx)

-- | Remove an existing wallet. Note that there's no particular work to be
--   done regarding the restoration worker as it will simply terminate on
--   the next tick when noticing that the corresponding wallet is gone.
deleteWallet :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | Restore a wallet from its current tip up to the network tip.
--   
--   This function returns immediately, starting a worker thread in the
--   background that will fetch and apply remaining blocks until the
--   network tip is reached or until failure.
restoreWallet :: forall ctx s t k. (HasLogger WalletLog ctx, HasNetworkLayer t ctx, HasDBLayer s k ctx, HasGenesisData ctx) => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | Update a wallet's metadata with the given update function.
updateWallet :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> (WalletMetadata -> WalletMetadata) -> ExceptT ErrNoSuchWallet IO ()

-- | Change a wallet's passphrase to the given passphrase.
updateWalletPassphrase :: forall ctx s k. (HasDBLayer s k ctx, WalletKey k) => ctx -> WalletId -> (Passphrase "encryption-old", Passphrase "encryption-new") -> ExceptT ErrUpdatePassphrase IO ()
walletSyncProgress :: forall ctx s. HasGenesisData ctx => ctx -> Wallet s -> IO SyncProgress

-- | Fetch the reward balance of a given wallet.
--   
--   Rather than force all callers of <a>readWallet</a> to wait for
--   fetching the account balance (via the <a>NetworkLayer</a>), we expose
--   this function for it.
fetchRewardBalance :: forall ctx s t k. (HasDBLayer s k ctx, HasNetworkLayer t ctx, HasRewardAccount s, k ~ RewardAccountKey s, WalletKey k) => ctx -> WalletId -> ExceptT ErrFetchRewards IO (Quantity "lovelace" Word64)

-- | Rewind the UTxO snapshots, transaction history and other information
--   to a the earliest point in the past that is before or is the point of
--   rollback.
rollbackBlocks :: forall ctx s k. (HasLogger WalletLog ctx, HasDBLayer s k ctx) => ctx -> WalletId -> SlotId -> ExceptT ErrNoSuchWallet IO ()

-- | Check whether a wallet is in good shape when restarting a worker.
checkWalletIntegrity :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> BlockchainParameters -> ExceptT ErrCheckWalletIntegrity IO ()

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Errors that can occur when listing UTxO statistics.
newtype ErrListUTxOStatistics
ErrListUTxOStatisticsNoSuchWallet :: ErrNoSuchWallet -> ErrListUTxOStatistics

-- | Errors that can occur when trying to change a wallet's passphrase.
data ErrUpdatePassphrase
ErrUpdatePassphraseNoSuchWallet :: ErrNoSuchWallet -> ErrUpdatePassphrase
ErrUpdatePassphraseWithRootKey :: ErrWithRootKey -> ErrUpdatePassphrase

-- | Errors that can occur when fetching the reward balance of a wallet
data ErrFetchRewards
ErrFetchRewardsNetworkUnreachable :: ErrNetworkUnavailable -> ErrFetchRewards
ErrFetchRewardsNoSuchWallet :: ErrNoSuchWallet -> ErrFetchRewards
data ErrCheckWalletIntegrity
ErrCheckWalletIntegrityNoSuchWallet :: ErrNoSuchWallet -> ErrCheckWalletIntegrity
ErrCheckIntegrityDifferentGenesis :: Hash "Genesis" -> Hash "Genesis" -> ErrCheckWalletIntegrity

-- | List all addresses of a wallet with their metadata. Addresses are
--   ordered from the most-recently-discovered to the oldest known.
listAddresses :: forall ctx s k n. (HasDBLayer s k ctx, IsOurs s Address, CompareDiscovery s, KnownAddresses s, MkKeyFingerprint k Address, DelegationAddress n k, HasRewardAccount s, k ~ RewardAccountKey s) => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO [(Address, AddressState)]

-- | Makes a fully-resolved coin selection for the given set of payments.
selectCoinsExternal :: forall ctx s t k e. (GenChange s, HasDBLayer s k ctx, HasLogger WalletLog ctx, HasTransactionLayer t k ctx, IsOwned s k, NFData s, Show s, e ~ ErrValidateSelection t) => ctx -> WalletId -> ArgGenChange s -> NonEmpty TxOut -> ExceptT (ErrSelectCoinsExternal e) IO UnsignedTx

-- | Prepare a transaction and automatically select inputs from the wallet
--   to cover the requested outputs. Note that this only runs coin
--   selection for the given outputs. In order to construct (and sign) an
--   actual transaction, use <a>signPayment</a>.
selectCoinsForPayment :: forall ctx s t k e. (HasTransactionLayer t k ctx, HasLogger WalletLog ctx, HasDBLayer s k ctx, e ~ ErrValidateSelection t) => ctx -> WalletId -> NonEmpty TxOut -> ExceptT (ErrSelectForPayment e) IO CoinSelection

-- | Produce witnesses and construct a transaction from a given selection.
--   Requires the encryption passphrase in order to decrypt the root
--   private key. Note that this doesn't broadcast the transaction to the
--   network. In order to do so, use <a>submitTx</a>.
signPayment :: forall ctx s t k. (HasTransactionLayer t k ctx, HasDBLayer s k ctx, Show s, NFData s, IsOwned s k, GenChange s) => ctx -> WalletId -> ArgGenChange s -> Passphrase "encryption" -> CoinSelection -> ExceptT ErrSignPayment IO (Tx, TxMeta, UTCTime, SealedTx)
data ErrSelectCoinsExternal e
ErrSelectCoinsExternalNoSuchWallet :: ErrNoSuchWallet -> ErrSelectCoinsExternal e
ErrSelectCoinsExternalUnableToMakeSelection :: ErrSelectForPayment e -> ErrSelectCoinsExternal e
ErrSelectCoinsExternalUnableToAssignInputs :: WalletId -> ErrSelectCoinsExternal e
ErrSelectCoinsExternalUnableToAssignOutputs :: WalletId -> ErrSelectCoinsExternal e

-- | Errors that can occur when creating an unsigned transaction.
data ErrSelectForPayment e
ErrSelectForPaymentNoSuchWallet :: ErrNoSuchWallet -> ErrSelectForPayment e
ErrSelectForPaymentCoinSelection :: ErrCoinSelection e -> ErrSelectForPayment e
ErrSelectForPaymentFee :: ErrAdjustForFee -> ErrSelectForPayment e

-- | Errors that can occur when signing a transaction.
data ErrSignPayment
ErrSignPaymentMkTx :: ErrMkTx -> ErrSignPayment
ErrSignPaymentNoSuchWallet :: ErrNoSuchWallet -> ErrSignPayment
ErrSignPaymentWithRootKey :: ErrWithRootKey -> ErrSignPayment
data ErrCoinSelection e

-- | UTxO exhausted during input selection We record the balance of the
--   UTxO as well as the size of the payment we tried to make.
ErrNotEnoughMoney :: Word64 -> Word64 -> ErrCoinSelection e

-- | UTxO is not enough fragmented for the number of transaction outputs We
--   record the number of UTxO entries as well as the number of the outputs
--   of the transaction.
ErrUtxoNotEnoughFragmented :: Word64 -> Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the max number of allowed
--   inputs was reached.
ErrMaximumInputsReached :: Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the available inputs are
--   depleted even when UTxO is properly fragmented and with enough funds
--   to cover payment
ErrInputsDepleted :: ErrCoinSelection e

-- | Somewhat, we ended up generating an invalid coin selection because of
--   inputs passed down to the coin selection function, or because a target
--   backend has extra-limitations not covered by our coin selection
--   algorithm.
ErrInvalidSelection :: e -> ErrCoinSelection e
newtype ErrAdjustForFee

-- | UTxO exhausted during fee covering We record what amount missed to
--   cover the fee
ErrCannotCoverFee :: Word64 -> ErrAdjustForFee

-- | A type family for validations that are specific to a particular
--   backend type. This demands an instantiation of the family for a
--   particular backend:
--   
--   type instance (ErrValidateSelection MyBackend) = MyCustomError
type family ErrValidateSelection t

-- | Constructs a set of coin selections that select all funds from the
--   given source wallet, returning them as change.
--   
--   If the coin selections returned by this function are used to create
--   transactions from the given wallet to a target wallet, executing those
--   transactions will have the effect of migrating all funds from the
--   given source wallet to the specified target wallet.
selectCoinsForMigration :: forall ctx s t k. (HasTransactionLayer t k ctx, HasDBLayer s k ctx) => ctx -> WalletId -> ExceptT ErrSelectForMigration IO [CoinSelection]

-- | Transform the given set of migration coin selections (for a source
--   wallet) into a set of coin selections that will migrate funds to the
--   specified target wallet.
--   
--   Each change entry in the specified set of coin selections is replaced
--   with a corresponding output entry in the returned set, where the
--   output entry has a address corresponding to the target wallet.
--   
--   All addresses generated by this function are also registered as
--   pending change addresses for the target wallet.
assignMigrationTargetAddresses :: forall ctx s k. (HasDBLayer s k ctx, GenChange s, IsOurs s Address, NFData s, Show s) => ctx -> WalletId -> ArgGenChange s -> [CoinSelection] -> ExceptT ErrNoSuchWallet IO [UnsignedTx]
data ErrSelectForMigration
ErrSelectForMigrationNoSuchWallet :: ErrNoSuchWallet -> ErrSelectForMigration

-- | User attempted to migrate an empty wallet
ErrSelectForMigrationEmptyWallet :: WalletId -> ErrSelectForMigration

-- | Helper function to factor necessary logic for joining a stake pool.
joinStakePool :: forall ctx s t k. (HasDBLayer s k ctx, HasLogger WalletLog ctx, HasNetworkLayer t ctx, HasTransactionLayer t k ctx, Show s, NFData s, IsOwned s k, GenChange s, HardDerivation k, AddressIndexDerivationType k ~  'Soft) => ctx -> WalletId -> (PoolId, [PoolId]) -> ArgGenChange s -> Passphrase "encryption" -> ExceptT ErrJoinStakePool IO (Tx, TxMeta, UTCTime)

-- | Helper function to factor necessary logic for quitting a stake pool.
quitStakePool :: forall ctx s t k. (HasDBLayer s k ctx, HasLogger WalletLog ctx, HasNetworkLayer t ctx, HasTransactionLayer t k ctx, Show s, NFData s, IsOwned s k, GenChange s, HardDerivation k, AddressIndexDerivationType k ~  'Soft) => ctx -> WalletId -> ArgGenChange s -> Passphrase "encryption" -> ExceptT ErrQuitStakePool IO (Tx, TxMeta, UTCTime)

-- | Select necessary coins to cover for a single delegation request
--   (including one certificate).
selectCoinsForDelegation :: forall ctx s t k. (HasTransactionLayer t k ctx, HasLogger WalletLog ctx, HasDBLayer s k ctx) => ctx -> WalletId -> ExceptT ErrSelectForDelegation IO CoinSelection
signDelegation :: forall ctx s t k. (HasTransactionLayer t k ctx, HasDBLayer s k ctx, Show s, NFData s, IsOwned s k, GenChange s, HardDerivation k, AddressIndexDerivationType k ~  'Soft) => ctx -> WalletId -> ArgGenChange s -> Passphrase "encryption" -> CoinSelection -> DelegationAction -> ExceptT ErrSignDelegation IO (Tx, TxMeta, UTCTime, SealedTx)
guardJoin :: [PoolId] -> WalletDelegation -> PoolId -> Either ErrCannotJoin ()
guardQuit :: WalletDelegation -> Either ErrCannotQuit ()
data ErrJoinStakePool
ErrJoinStakePoolNoSuchWallet :: ErrNoSuchWallet -> ErrJoinStakePool
ErrJoinStakePoolSelectCoin :: ErrSelectForDelegation -> ErrJoinStakePool
ErrJoinStakePoolSignDelegation :: ErrSignDelegation -> ErrJoinStakePool
ErrJoinStakePoolSubmitTx :: ErrSubmitTx -> ErrJoinStakePool
ErrJoinStakePoolCannotJoin :: ErrCannotJoin -> ErrJoinStakePool
data ErrCannotJoin
ErrAlreadyDelegating :: PoolId -> ErrCannotJoin
ErrNoSuchPool :: PoolId -> ErrCannotJoin
data ErrQuitStakePool
ErrQuitStakePoolNoSuchWallet :: ErrNoSuchWallet -> ErrQuitStakePool
ErrQuitStakePoolSelectCoin :: ErrSelectForDelegation -> ErrQuitStakePool
ErrQuitStakePoolSignDelegation :: ErrSignDelegation -> ErrQuitStakePool
ErrQuitStakePoolSubmitTx :: ErrSubmitTx -> ErrQuitStakePool
ErrQuitStakePoolCannotQuit :: ErrCannotQuit -> ErrQuitStakePool
data ErrCannotQuit
ErrNotDelegatingOrAboutTo :: ErrCannotQuit

-- | Errors that can occur when creating unsigned delegation certificate
--   transaction.
data ErrSelectForDelegation
ErrSelectForDelegationNoSuchWallet :: ErrNoSuchWallet -> ErrSelectForDelegation
ErrSelectForDelegationFee :: ErrAdjustForFee -> ErrSelectForDelegation

-- | Errors that can occur when signing a delegation certificate.
data ErrSignDelegation
ErrSignDelegationNoSuchWallet :: ErrNoSuchWallet -> ErrSignDelegation
ErrSignDelegationWithRootKey :: ErrWithRootKey -> ErrSignDelegation
ErrSignDelegationMkTx :: ErrMkTx -> ErrSignDelegation

-- | Forget pending transaction.
forgetPendingTx :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> Hash "Tx" -> ExceptT ErrRemovePendingTx IO ()

-- | List all transactions and metadata from history for a given wallet.
listTransactions :: forall ctx s k. HasDBLayer s k ctx => ctx -> WalletId -> Maybe UTCTime -> Maybe UTCTime -> SortOrder -> ExceptT ErrListTransactions IO [TransactionInfo]

-- | Broadcast an externally-signed transaction to the network.
submitExternalTx :: forall ctx t k. (HasNetworkLayer t ctx, HasTransactionLayer t k ctx) => ctx -> ByteString -> ExceptT ErrSubmitExternalTx IO Tx

-- | Very much like <a>signPayment</a>, but doesn't not generate change
--   addresses.
signTx :: forall ctx s t k. (HasTransactionLayer t k ctx, HasDBLayer s k ctx, Show s, NFData s, IsOwned s k) => ctx -> WalletId -> Passphrase "encryption" -> UnsignedTx -> ExceptT ErrSignPayment IO (Tx, TxMeta, UTCTime, SealedTx)

-- | Broadcast a (signed) transaction to the network.
submitTx :: forall ctx s t k. (HasNetworkLayer t ctx, HasDBLayer s k ctx) => ctx -> WalletId -> (Tx, TxMeta, SealedTx) -> ExceptT ErrSubmitTx IO ()

-- | Possible signing error
newtype ErrMkTx

-- | We tried to sign a transaction with inputs that are unknown to us?
ErrKeyNotFoundForAddress :: Address -> ErrMkTx

-- | Errors that can occur when submitting a signed transaction to the
--   network.
data ErrSubmitTx
ErrSubmitTxNetwork :: ErrPostTx -> ErrSubmitTx
ErrSubmitTxNoSuchWallet :: ErrNoSuchWallet -> ErrSubmitTx

-- | Errors that can occur when submitting an externally-signed transaction
--   to the network.
data ErrSubmitExternalTx
ErrSubmitExternalTxNetwork :: ErrPostTx -> ErrSubmitExternalTx
ErrSubmitExternalTxDecode :: ErrDecodeSignedTx -> ErrSubmitExternalTx

-- | Can't perform removing pending transaction
data ErrRemovePendingTx
ErrRemovePendingTxNoSuchWallet :: ErrNoSuchWallet -> ErrRemovePendingTx
ErrRemovePendingTxNoSuchTransaction :: Hash "Tx" -> ErrRemovePendingTx
ErrRemovePendingTxTransactionNoMorePending :: Hash "Tx" -> ErrRemovePendingTx

-- | Error while trying to send a transaction
data ErrPostTx
ErrPostTxNetworkUnreachable :: ErrNetworkUnavailable -> ErrPostTx
ErrPostTxBadRequest :: Text -> ErrPostTx
ErrPostTxProtocolFailure :: Text -> ErrPostTx

-- | Error while trying to decode externally signed transaction
data ErrDecodeSignedTx
ErrDecodeSignedTxWrongPayload :: Text -> ErrDecodeSignedTx
ErrDecodeSignedTxNotSupported :: ErrDecodeSignedTx

-- | Errors that can occur when trying to list transactions.
data ErrListTransactions
ErrListTransactionsNoSuchWallet :: ErrNoSuchWallet -> ErrListTransactions
ErrListTransactionsStartTimeLaterThanEndTime :: ErrStartTimeLaterThanEndTime -> ErrListTransactions

-- | Network is unavailable
data ErrNetworkUnavailable

-- | Cannot connect to network backend.
ErrNetworkUnreachable :: Text -> ErrNetworkUnavailable

-- | Network backend reports that the requested network is invalid.
ErrNetworkInvalid :: Text -> ErrNetworkUnavailable

-- | Indicates that the specified start time is later than the specified
--   end time.
data ErrStartTimeLaterThanEndTime
ErrStartTimeLaterThanEndTime :: UTCTime -> UTCTime -> ErrStartTimeLaterThanEndTime
[$sel:errStartTime:ErrStartTimeLaterThanEndTime] :: ErrStartTimeLaterThanEndTime -> UTCTime
[$sel:errEndTime:ErrStartTimeLaterThanEndTime] :: ErrStartTimeLaterThanEndTime -> UTCTime

-- | Execute an action which requires holding a root XPrv.
withRootKey :: forall ctx s k e a. HasDBLayer s k ctx => ctx -> WalletId -> Passphrase "encryption" -> (ErrWithRootKey -> e) -> (k  'RootK XPrv -> ExceptT e IO a) -> ExceptT e IO a

-- | Errors that can occur when trying to perform an operation on a wallet
--   that requires a private key, but where none is attached to the wallet.
data ErrWithRootKey
ErrWithRootKeyNoRootKey :: WalletId -> ErrWithRootKey
ErrWithRootKeyWrongPassphrase :: WalletId -> ErrWrongPassphrase -> ErrWithRootKey

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase
data WalletLog
MsgTryingRollback :: SlotId -> WalletLog
MsgRolledBack :: SlotId -> WalletLog
MsgFollow :: FollowLog -> WalletLog
MsgDelegation :: SlotId -> DelegationCertificate -> WalletLog
MsgCheckpoint :: BlockHeader -> WalletLog
MsgWalletMetadata :: WalletMetadata -> WalletLog
MsgSyncProgress :: SyncProgress -> WalletLog
MsgDiscoveredTxs :: [(Tx, TxMeta)] -> WalletLog
MsgDiscoveredTxsContent :: [(Tx, TxMeta)] -> WalletLog
MsgTip :: BlockHeader -> WalletLog
MsgBlocks :: NonEmpty Block -> WalletLog
MsgDelegationCoinSelection :: CoinSelection -> WalletLog
MsgPaymentCoinSelection :: CoinSelection -> WalletLog
MsgPaymentCoinSelectionAdjusted :: CoinSelection -> WalletLog
instance GHC.Generics.Generic (Cardano.Wallet.WalletLayer s t k)
instance GHC.Classes.Eq Cardano.Wallet.WalletLog
instance GHC.Show.Show Cardano.Wallet.WalletLog
instance GHC.Show.Show Cardano.Wallet.ErrQuitStakePool
instance GHC.Classes.Eq Cardano.Wallet.ErrQuitStakePool
instance GHC.Generics.Generic Cardano.Wallet.ErrQuitStakePool
instance GHC.Show.Show Cardano.Wallet.ErrCannotQuit
instance GHC.Classes.Eq Cardano.Wallet.ErrCannotQuit
instance GHC.Generics.Generic Cardano.Wallet.ErrCannotQuit
instance GHC.Show.Show Cardano.Wallet.ErrJoinStakePool
instance GHC.Classes.Eq Cardano.Wallet.ErrJoinStakePool
instance GHC.Generics.Generic Cardano.Wallet.ErrJoinStakePool
instance GHC.Show.Show Cardano.Wallet.ErrCannotJoin
instance GHC.Classes.Eq Cardano.Wallet.ErrCannotJoin
instance GHC.Generics.Generic Cardano.Wallet.ErrCannotJoin
instance GHC.Show.Show Cardano.Wallet.ErrCheckWalletIntegrity
instance GHC.Classes.Eq Cardano.Wallet.ErrCheckWalletIntegrity
instance GHC.Show.Show Cardano.Wallet.ErrSelectForMigration
instance GHC.Classes.Eq Cardano.Wallet.ErrSelectForMigration
instance GHC.Classes.Eq Cardano.Wallet.ErrSignDelegation
instance GHC.Show.Show Cardano.Wallet.ErrSignDelegation
instance GHC.Classes.Eq Cardano.Wallet.ErrSelectForDelegation
instance GHC.Show.Show Cardano.Wallet.ErrSelectForDelegation
instance GHC.Classes.Eq Cardano.Wallet.ErrListTransactions
instance GHC.Show.Show Cardano.Wallet.ErrListTransactions
instance GHC.Classes.Eq Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance GHC.Show.Show Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance GHC.Classes.Eq Cardano.Wallet.ErrSignPayment
instance GHC.Show.Show Cardano.Wallet.ErrSignPayment
instance GHC.Classes.Eq Cardano.Wallet.ErrUpdatePassphrase
instance GHC.Show.Show Cardano.Wallet.ErrUpdatePassphrase
instance GHC.Classes.Eq Cardano.Wallet.ErrWithRootKey
instance GHC.Show.Show Cardano.Wallet.ErrWithRootKey
instance GHC.Classes.Eq Cardano.Wallet.ErrSubmitExternalTx
instance GHC.Show.Show Cardano.Wallet.ErrSubmitExternalTx
instance GHC.Classes.Eq Cardano.Wallet.ErrSubmitTx
instance GHC.Show.Show Cardano.Wallet.ErrSubmitTx
instance GHC.Classes.Eq Cardano.Wallet.ErrListUTxOStatistics
instance GHC.Show.Show Cardano.Wallet.ErrListUTxOStatistics
instance GHC.Show.Show e => GHC.Show.Show (Cardano.Wallet.ErrSelectCoinsExternal e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Cardano.Wallet.ErrSelectCoinsExternal e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Cardano.Wallet.ErrSelectForPayment e)
instance GHC.Show.Show e => GHC.Show.Show (Cardano.Wallet.ErrSelectForPayment e)
instance Data.Text.Class.ToText Cardano.Wallet.WalletLog
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.Wallet.WalletLog
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.Wallet.WalletLog
instance GHC.Exception.Type.Exception Cardano.Wallet.ErrCheckWalletIntegrity

module Cardano.Wallet.Registry

-- | A registry to keep track of worker threads and acquired resources.
data WorkerRegistry key resource

-- | Construct a new empty registry
empty :: Ord key => IO (WorkerRegistry key resource)

-- | Get all registered keys in the registry
keys :: WorkerRegistry key resource -> IO [key]

-- | Lookup the registry for a given worker
lookup :: (MonadIO m, Ord key) => WorkerRegistry key resource -> key -> m (Maybe (Worker key resource))

-- | Register a new worker for a given key.
--   
--   A worker maintains an acquired resource. It expects a task as an
--   argument and will terminate as soon as its task is over. In practice,
--   we provide a never-ending task that keeps the worker alive forever.
--   
--   Returns <a>Nothing</a> if the worker fails to acquire the necessary
--   resource or terminates unexpectedly before entering its <tt>main</tt>
--   action.
register :: forall resource ctx key msg. (Ord key, key ~ WorkerKey ctx, msg ~ WorkerMsg ctx, HasLogger (WorkerLog key msg) ctx, HasWorkerCtx resource ctx) => WorkerRegistry key resource -> ctx -> key -> MkWorker key resource msg ctx -> IO (Maybe (Worker key resource))

-- | Unregister a worker from the registry, terminating the running task.
unregister :: Ord key => WorkerRegistry key resource -> key -> IO ()

-- | A worker which holds and manipulate a paticular acquired resource.
--   That resource can be, for example, a handle to a database connection.
data Worker key resource

-- | See <tt>newWorker</tt>
data MkWorker key resource msg ctx
MkWorker :: (WorkerCtx ctx -> key -> IO ()) -> (WorkerCtx ctx -> key -> IO ()) -> (Tracer IO (WorkerLog key msg) -> Either SomeException () -> IO ()) -> ((resource -> IO ()) -> IO ()) -> MkWorker key resource msg ctx

-- | A task to execute before the main worker's task. When creating a
--   worker, this task is guaranteed to have terminated once
--   <tt>newWorker</tt> returns.
[workerBefore] :: MkWorker key resource msg ctx -> WorkerCtx ctx -> key -> IO ()

-- | A task for the worker, possibly infinite
[workerMain] :: MkWorker key resource msg ctx -> WorkerCtx ctx -> key -> IO ()

-- | Action to run when the worker exits
[workerAfter] :: MkWorker key resource msg ctx -> Tracer IO (WorkerLog key msg) -> Either SomeException () -> IO ()

-- | A bracket-style factory to acquire a resource
[workerAcquire] :: MkWorker key resource msg ctx -> (resource -> IO ()) -> IO ()
defaultWorkerAfter :: Tracer IO (WorkerLog key msg) -> Either SomeException a -> IO ()
workerThread :: Worker key resource -> ThreadId
workerId :: Worker key resource -> key
workerResource :: Worker key resource -> resource

-- | A class to link an existing context to a worker context.
class HasType resource (WorkerCtx ctx) => HasWorkerCtx resource ctx where {
    type family WorkerCtx ctx :: *;
    type family WorkerMsg ctx :: *;
    type family WorkerKey ctx :: *;
}
hoistResource :: HasWorkerCtx resource ctx => resource -> (WorkerMsg ctx -> WorkerLog (WorkerKey ctx) (WorkerMsg ctx)) -> ctx -> WorkerCtx ctx
data WorkerLog key msg
MsgFinished :: WorkerLog key msg
MsgThreadKilled :: WorkerLog key msg
MsgUserInterrupt :: WorkerLog key msg
MsgUnhandledException :: Text -> WorkerLog key msg
MsgFromWorker :: key -> msg -> WorkerLog key msg
instance (GHC.Classes.Eq key, GHC.Classes.Eq msg) => GHC.Classes.Eq (Cardano.Wallet.Registry.WorkerLog key msg)
instance (GHC.Show.Show key, GHC.Show.Show msg) => GHC.Show.Show (Cardano.Wallet.Registry.WorkerLog key msg)
instance GHC.Generics.Generic (Cardano.Wallet.Registry.Worker key resource)
instance (Data.Text.Class.ToText key, Data.Text.Class.ToText msg) => Data.Text.Class.ToText (Cardano.Wallet.Registry.WorkerLog key msg)
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation (Cardano.Wallet.Registry.WorkerLog key msg)
instance Cardano.BM.Data.Tracer.DefineSeverity msg => Cardano.BM.Data.Tracer.DefineSeverity (Cardano.Wallet.Registry.WorkerLog key msg)

module Cardano.Wallet.Api
type Api n = Wallets :<|> Addresses n :<|> CoinSelections n :<|> Transactions n :<|> StakePools n :<|> ByronWallets :<|> ByronTransactions n :<|> ByronMigrations n :<|> Network :<|> Proxy_
type ApiV2 n = "v2" :> Api n
type Wallets = DeleteWallet :<|> GetWallet :<|> ListWallets :<|> PostWallet :<|> PutWallet :<|> PutWalletPassphrase :<|> GetUTxOsStatistics :<|> ForceResyncWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteWallet</a>
type DeleteWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> DeleteNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getWallet</a>
type GetWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> Get '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listWallets</a>
type ListWallets = "wallets" :> Get '[JSON] [ApiWallet]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postWallet</a>
type PostWallet = "wallets" :> ReqBody '[JSON] WalletOrAccountPostData :> PostCreated '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWallet</a>
type PutWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] WalletPutData :> Put '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWalletPassphrase</a>
type PutWalletPassphrase = "wallets" :> Capture "walletId" (ApiT WalletId) :> "passphrase" :> ReqBody '[JSON] WalletPutPassphraseData :> PutNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getUTxOsStatistics</a>
type GetUTxOsStatistics = "wallets" :> Capture "walletId" (ApiT WalletId) :> "statistics" :> "utxos" :> Get '[JSON] ApiUtxoStatistics

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/forceResync</a>
type ForceResyncWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> "tip" :> ReqBody '[JSON] ApiNetworkTip :> PutNoContent
type Addresses n = ListAddresses n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listAddresses</a>
type ListAddresses n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> QueryParam "state" (ApiT AddressState) :> Get '[JSON] [ApiAddress n]
type CoinSelections n = SelectCoins n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/selectCoins</a>
type SelectCoins n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "coin-selections" :> "random" :> ReqBody '[JSON] (ApiSelectCoinsData n) :> Post '[JSON] (ApiCoinSelection n)
type Transactions n = CreateTransaction n :<|> ListTransactions n :<|> PostTransactionFee n :<|> DeleteTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postTransaction</a>
type CreateTransaction n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> ReqBody '[JSON] (PostTransactionData n) :> PostAccepted '[JSON] (ApiTransaction n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postTransactionFee</a>
type PostTransactionFee n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "payment-fees" :> ReqBody '[JSON] (PostTransactionFeeData n) :> PostAccepted '[JSON] ApiFee

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listTransaction</a>
type ListTransactions n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> QueryParam "start" Iso8601Time :> QueryParam "end" Iso8601Time :> QueryParam "order" (ApiT SortOrder) :> Get '[JSON] [ApiTransaction n]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteTransaction</a>
type DeleteTransaction = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> Capture "transactionId" ApiTxId :> DeleteNoContent
type StakePools n = ListStakePools :<|> JoinStakePool n :<|> QuitStakePool n :<|> DelegationFee

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/edge/#operation/listStakePools</a>
type ListStakePools = "stake-pools" :> Get '[JSON] [ApiStakePool]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/joinStakePool</a>
type JoinStakePool n = "stake-pools" :> Capture "stakePoolId" ApiPoolId :> "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] ApiWalletPassphrase :> PutAccepted '[JSON] (ApiTransaction n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/quitStakePool</a>
type QuitStakePool n = "stake-pools" :> "*" :> "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] ApiWalletPassphrase :> DeleteAccepted '[JSON] (ApiTransaction n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getDelegationFee</a>
type DelegationFee = "wallets" :> Capture "walletId" (ApiT WalletId) :> "delegation-fees" :> Get '[JSON] ApiFee
type ByronWallets = PostByronWallet :<|> DeleteByronWallet :<|> GetByronWallet :<|> ListByronWallets :<|> ForceResyncByronWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteByronWallet</a>
type DeleteByronWallet = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> DeleteNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronWallet</a>
type GetByronWallet = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> Get '[JSON] ApiByronWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listByronWallets</a>
type ListByronWallets = "byron-wallets" :> Get '[JSON] [ApiByronWallet]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postByronWallet</a>
type PostByronWallet = "byron-wallets" :> ReqBody '[JSON] SomeByronWalletPostData :> PostCreated '[JSON] ApiByronWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/forceResyncByron</a>
type ForceResyncByronWallet = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "tip" :> ReqBody '[JSON] ApiNetworkTip :> PutNoContent
type ByronTransactions n = CreateByronTransaction n :<|> ListByronTransactions n :<|> PostByronTransactionFee n :<|> DeleteByronTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postByronTransaction</a>
type CreateByronTransaction n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> ReqBody '[JSON] (PostTransactionData n) :> PostAccepted '[JSON] (ApiTransaction n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listByronTransactions</a>
type ListByronTransactions n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> QueryParam "start" Iso8601Time :> QueryParam "end" Iso8601Time :> QueryParam "order" (ApiT SortOrder) :> Get '[JSON] [ApiTransaction n]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postByronTransactionFee</a>
type PostByronTransactionFee n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "payment-fees" :> ReqBody '[JSON] (PostTransactionFeeData n) :> PostAccepted '[JSON] ApiFee

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteByronTransaction</a>
type DeleteByronTransaction = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> Capture "transactionId" ApiTxId :> DeleteNoContent
type ByronMigrations n = GetByronWalletMigrationInfo :<|> MigrateByronWallet n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/migrateByronWallet</a>
type MigrateByronWallet n = "byron-wallets" :> Capture "sourceWalletId" (ApiT WalletId) :> "migrations" :> Capture "targetWalletId" (ApiT WalletId) :> ReqBody '[JSON] ApiWalletPassphrase :> PostAccepted '[JSON] [ApiTransaction n]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronWalletMigrationInfo</a>
type GetByronWalletMigrationInfo = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "migrations" :> Get '[JSON] ApiByronWalletMigrationInfo
type Network = GetNetworkInformation :<|> GetNetworkParameters :<|> GetNetworkClock
type GetNetworkInformation = "network" :> "information" :> Get '[JSON] ApiNetworkInformation
type GetNetworkParameters = "network" :> "parameters" :> Capture "epochId" ApiEpochNumber :> Get '[JSON] ApiNetworkParameters
type GetNetworkClock = "network" :> "clock" :> Get '[JSON] ApiNetworkClock
type Proxy_ = PostExternalTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postExternalTransaction</a>
type PostExternalTransaction = "proxy" :> "transactions" :> ReqBody '[OctetStream] PostExternalTransactionData :> PostAccepted '[JSON] ApiTxId
data ApiLayer s t (k :: Depth -> * -> *)
ApiLayer :: Tracer IO (WorkerLog WalletId WalletLog) -> (Block, BlockchainParameters, SyncTolerance) -> NetworkLayer IO t Block -> TransactionLayer t k -> DBFactory IO s k -> WorkerRegistry WalletId (DBLayer IO s k) -> ApiLayer s t
type HasWorkerRegistry s k ctx = (HasType (WorkerRegistry WalletId (DBLayer IO s k)) ctx, HasWorkerCtx (DBLayer IO s k) ctx, WorkerKey ctx ~ WalletId, WorkerMsg ctx ~ WalletLog)
workerRegistry :: forall s k ctx. HasWorkerRegistry s k ctx => Lens' ctx (WorkerRegistry WalletId (DBLayer IO s k))
type HasDBFactory s k = HasType (DBFactory IO s k)
dbFactory :: forall s k ctx. HasDBFactory s k ctx => Lens' ctx (DBFactory IO s k)
instance GHC.Generics.Generic (Cardano.Wallet.Api.ApiLayer s t k)
instance Cardano.Wallet.Registry.HasWorkerCtx (Cardano.Wallet.DB.DBLayer GHC.Types.IO s k) (Cardano.Wallet.Api.ApiLayer s t k)


-- | Type-safe endpoint accessors for the wallet API. Under normal
--   circumstances, one would prefer to use <tt>WalletClient</tt> from
--   <a>Client</a> and not to bother with endpoints at all.
--   
--   Yet, in some cases (like in black-box testing), one could want to
--   purposely send malformed requests to specific endpoints. Thus, this
--   module facilitates the construction of valid endpoints that'd be
--   accepted by the server, and for which, users are free to send all sort
--   of data as payload, valid or invalid.
--   
--   This module is meant to be used via qualified imports and with
--   type-applications since all exposed functions are type ambiguous in a
--   variable <tt>style</tt> of type <a>WalletStyle</a>.
--   
--   <pre>
--   import qualified Cardano.Wallet.Api.Link as Link
--   </pre>
--   
--   For examples:
--   
--   <pre>
--   &gt;&gt;&gt; Link.deleteWallet @'Shelley myWallet
--   ( "DELETE", "/v2/wallets/2512a00e9653fe49a44a5886202e24d77eeb998f" )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Link.getWallet @('Byron 'Icarus) myWallet
--   ( "GET", "/v2/byron-wallets/2512a00e9653fe49a44a5886202e24d77eeb998f" )
--   </pre>
module Cardano.Wallet.Api.Link
deleteWallet :: forall (style :: WalletStyle) w. (Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
getWallet :: forall (style :: WalletStyle) w. (Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
listWallets :: forall (style :: WalletStyle). Discriminate style => (Method, Text)
postWallet :: PostWallet style => (Method, Text)
putWallet :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
putWalletPassphrase :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getUTxOsStatistics :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getMigrationInfo :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
migrateWallet :: forall from to. (HasType (ApiT WalletId) from, HasType (ApiT WalletId) to) => from -> to -> (Method, Text)
forceResyncWallet :: forall style w. (HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
listAddresses :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
listAddresses' :: forall w. HasType (ApiT WalletId) w => w -> Maybe AddressState -> (Method, Text)
selectCoins :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
createTransaction :: forall style w. (HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
listTransactions :: forall (style :: WalletStyle) w. (Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
listTransactions' :: forall (style :: WalletStyle) w. (Discriminate style, HasType (ApiT WalletId) w) => w -> Maybe Iso8601Time -> Maybe Iso8601Time -> Maybe SortOrder -> (Method, Text)
getTransactionFee :: forall style w. (HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
deleteTransaction :: forall (style :: WalletStyle) w t. (Discriminate style, HasType (ApiT WalletId) w, HasType (ApiT (Hash "Tx")) t) => w -> t -> (Method, Text)
listStakePools :: (Method, Text)
joinStakePool :: forall s w. (HasType (ApiT PoolId) s, HasType (ApiT WalletId) w) => s -> w -> (Method, Text)
quitStakePool :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getDelegationFee :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getNetworkInfo :: (Method, Text)
getNetworkParams :: forall e. HasType ApiEpochNumber e => e -> (Method, Text)
getNetworkClock :: (Method, Text)
postExternalTransaction :: (Method, Text)
class PostWallet (style :: WalletStyle)
class Discriminate (style :: WalletStyle)
instance forall k1 (m :: k1). Servant.API.Verbs.ReflectMethod m => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Verbs.NoContentVerb m)
instance forall k1 (m :: k1) (s :: GHC.Types.Nat) (ct :: [*]) a. Servant.API.Verbs.ReflectMethod m => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Verbs.Verb m s ct a)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (path Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Capture.Capture param t Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.ReqBody.ReqBody a b Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.QueryParam.QueryParam a b Servant.API.Sub.:> sub)
instance forall k sub (opts :: [*]) (name :: GHC.Types.Symbol) (ty :: k). Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Header.Header' opts name ty Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.Discriminate 'Cardano.Wallet.Api.Types.Shelley
instance Cardano.Wallet.Api.Link.Discriminate 'Cardano.Wallet.Api.Types.Byron
instance Cardano.Wallet.Api.Link.PostWallet 'Cardano.Wallet.Api.Types.Shelley
instance Cardano.Wallet.Api.Link.PostWallet 'Cardano.Wallet.Api.Types.Byron


-- | This module provides a Servant client for the cardano-wallet V2 API.
--   
--   The functions in this module can be run with
--   "Servant.Client.runClientM".
module Cardano.Wallet.Api.Client

-- | This data type encapsulates the client functions for all endpoints of
--   the cardano-wallet V2 API.
data WalletClient t
WalletClient :: (ApiT WalletId -> Maybe (ApiT AddressState) -> ClientM [ApiAddress t]) -> (ApiT WalletId -> ClientM ()) -> (ApiT WalletId -> ClientM ApiWallet) -> (ApiT WalletId -> ClientM ApiUtxoStatistics) -> ClientM [ApiWallet] -> (WalletOrAccountPostData -> ClientM ApiWallet) -> (ApiT WalletId -> WalletPutData -> ClientM ApiWallet) -> (ApiT WalletId -> WalletPutPassphraseData -> ClientM NoContent) -> (ApiT WalletId -> ApiNetworkTip -> ClientM NoContent) -> (ApiT WalletId -> Maybe Iso8601Time -> Maybe Iso8601Time -> Maybe (ApiT SortOrder) -> ClientM [ApiTransaction t]) -> (ApiT WalletId -> PostTransactionData t -> ClientM (ApiTransaction t)) -> (ApiT WalletId -> PostTransactionFeeData t -> ClientM ApiFee) -> (PostExternalTransactionData -> ClientM ApiTxId) -> (ApiT WalletId -> ApiTxId -> ClientM NoContent) -> ClientM [ApiStakePool] -> (ApiPoolId -> ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransaction t)) -> (ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransaction t)) -> ClientM ApiNetworkInformation -> (ApiEpochNumber -> ClientM ApiNetworkParameters) -> ClientM ApiNetworkClock -> WalletClient t
[$sel:listAddresses:WalletClient] :: WalletClient t -> ApiT WalletId -> Maybe (ApiT AddressState) -> ClientM [ApiAddress t]
[$sel:deleteWallet:WalletClient] :: WalletClient t -> ApiT WalletId -> ClientM ()
[$sel:getWallet:WalletClient] :: WalletClient t -> ApiT WalletId -> ClientM ApiWallet
[$sel:getWalletUtxoStatistics:WalletClient] :: WalletClient t -> ApiT WalletId -> ClientM ApiUtxoStatistics
[$sel:listWallets:WalletClient] :: WalletClient t -> ClientM [ApiWallet]
[$sel:postWallet:WalletClient] :: WalletClient t -> WalletOrAccountPostData -> ClientM ApiWallet
[$sel:putWallet:WalletClient] :: WalletClient t -> ApiT WalletId -> WalletPutData -> ClientM ApiWallet
[$sel:putWalletPassphrase:WalletClient] :: WalletClient t -> ApiT WalletId -> WalletPutPassphraseData -> ClientM NoContent
[$sel:forceResyncWallet:WalletClient] :: WalletClient t -> ApiT WalletId -> ApiNetworkTip -> ClientM NoContent
[$sel:listTransactions:WalletClient] :: WalletClient t -> ApiT WalletId -> Maybe Iso8601Time -> Maybe Iso8601Time -> Maybe (ApiT SortOrder) -> ClientM [ApiTransaction t]
[$sel:postTransaction:WalletClient] :: WalletClient t -> ApiT WalletId -> PostTransactionData t -> ClientM (ApiTransaction t)
[$sel:postTransactionFee:WalletClient] :: WalletClient t -> ApiT WalletId -> PostTransactionFeeData t -> ClientM ApiFee
[$sel:postExternalTransaction:WalletClient] :: WalletClient t -> PostExternalTransactionData -> ClientM ApiTxId
[$sel:deleteTransaction:WalletClient] :: WalletClient t -> ApiT WalletId -> ApiTxId -> ClientM NoContent
[$sel:listPools:WalletClient] :: WalletClient t -> ClientM [ApiStakePool]
[$sel:joinStakePool:WalletClient] :: WalletClient t -> ApiPoolId -> ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransaction t)
[$sel:quitStakePool:WalletClient] :: WalletClient t -> ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransaction t)
[$sel:networkInformation:WalletClient] :: WalletClient t -> ClientM ApiNetworkInformation
[$sel:networkParameters:WalletClient] :: WalletClient t -> ApiEpochNumber -> ClientM ApiNetworkParameters
[$sel:networkClock:WalletClient] :: WalletClient t -> ClientM ApiNetworkClock

-- | Produces a <a>WalletClient</a> for the cardano-wallet V2 API.
--   
--   You should apply a
--   <a>Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminant</a>
--   type parameter to this to get a concrete client.
walletClient :: forall t. (DecodeAddress t, EncodeAddress t) => WalletClient t

-- | Poll the wallet server until it reports that it has synced with the
--   network.
waitForSync :: WalletClient t -> ClientM ()

-- | Poll a wallet by ID until it has restored.
waitForRestore :: WalletClient t -> ApiT WalletId -> ClientM ApiWallet


-- | This module can fold over a blockchain to collect metrics about Stake
--   pools.
--   
--   It interacts with: - <a>Cardano.Wallet.Network</a> which provides the
--   chain - <a>Cardano.Pool.DB</a> - which can persist the metrics -
--   <a>Cardano.Wallet.Api.Server</a> - which presents the results in an
--   endpoint
module Cardano.Pool.Metrics

-- | Information from a block relevant to monitoring stake pools.
data Block
Block :: BlockHeader -> PoolId -> ![PoolRegistrationCertificate] -> Block
[$sel:header:Block] :: Block -> BlockHeader

-- | The stake pool that minted this block.
[$sel:producer:Block] :: Block -> PoolId

-- | Any stake pools that were registered in this block.
[$sel:poolRegistrations:Block] :: Block -> ![PoolRegistrationCertificate]
data StakePool
StakePool :: PoolId -> Quantity "lovelace" Word64 -> Quantity "block" Word64 -> Double -> Double -> Quantity "lovelace" Word64 -> Percentage -> Double -> StakePool
[$sel:poolId:StakePool] :: StakePool -> PoolId
[$sel:stake:StakePool] :: StakePool -> Quantity "lovelace" Word64
[$sel:production:StakePool] :: StakePool -> Quantity "block" Word64
[$sel:performance:StakePool] :: StakePool -> Double
[$sel:desirability:StakePool] :: StakePool -> Double
[$sel:cost:StakePool] :: StakePool -> Quantity "lovelace" Word64
[$sel:margin:StakePool] :: StakePool -> Percentage
[$sel:saturation:StakePool] :: StakePool -> Double

-- | <tt>StakePoolLayer</tt> is a thin layer ontop of the DB. It is
--   <i>one</i> value that can easily be passed to the API-server, where it
--   can be used in a simple way.
data StakePoolLayer m
StakePoolLayer :: ExceptT ErrListStakePools m [(StakePool, Maybe StakePoolMetadata)] -> m [PoolId] -> StakePoolLayer m
[$sel:listStakePools:StakePoolLayer] :: StakePoolLayer m -> ExceptT ErrListStakePools m [(StakePool, Maybe StakePoolMetadata)]

-- | Get a list of known pools that doesn't require fetching things from
--   Jörmungandr or any registry. This list comes from the registration
--   certificates that have been seen on chain.
[$sel:knownStakePools:StakePoolLayer] :: StakePoolLayer m -> m [PoolId]
newStakePoolLayer :: Tracer IO StakePoolLog -> BlockHeader -> (EpochNo -> Quantity "lovelace" Word64 -> EpochConstants) -> DBLayer IO -> NetworkLayer IO t Block -> FilePath -> StakePoolLayer IO
data ErrListStakePools
ErrMetricsIsUnsynced :: Quantity "percent" Percentage -> ErrListStakePools
ErrListStakePoolsMetricsInconsistency :: ErrMetricsInconsistency -> ErrListStakePools
ErrListStakePoolsCurrentNodeTip :: ErrCurrentNodeTip -> ErrListStakePools

-- | <a>monitorStakePools</a> follows the chain and puts pool productions
--   and stake distributions to a <a>DBLayer</a>, such that the data in the
--   database is always consistent.
--   
--   The pool productions and stake distrubtions in the db can <i>never</i>
--   be from different forks such that it's safe for readers to access it.
monitorStakePools :: Tracer IO StakePoolLog -> (Block, Quantity "block" Word32) -> NetworkLayer IO t Block -> DBLayer IO -> IO ()

-- | Possible errors returned by <a>combineMetrics</a>.
newtype ErrMetricsInconsistency

-- | Somehow, we tried to combine invalid metrics together and passed a
--   passed a block production that doesn't match the producers found in
--   the stake activity.
--   
--   Note that the opposite case is okay as we only observe pools that have
--   produced blocks. So it could be the case that a pool exists in the
--   distribution but not in the production! (In which case, we'll assign
--   it a production of '0').
ErrProducerNotInDistribution :: PoolId -> ErrMetricsInconsistency

-- | Combines three different sources of data into one:
--   
--   <ol>
--   <li>A stake-distribution map</li>
--   <li>A pool-production map</li>
--   <li>A pool-performance map</li>
--   </ol>
--   
--   If a pool has produced a block without existing in the
--   stake-distribution, i.e it exists in (2) but not (1), this function
--   will return <tt>Left ErrMetricsInconsistency</tt>.
--   
--   If a pool is in (1) but not (2), it simply means it has produced 0
--   blocks so far.
--   
--   Similarly, if we do have metrics about a pool in (3), but this pool is
--   unknown from (1) &amp; (2), this function also returns <tt>Left
--   ErrMetricsInconsistency</tt>.
--   
--   If a pool is in (1+2) but not in (3), it simply means it has produced
--   0 blocks so far.
combineMetrics :: Map PoolId (Quantity "lovelace" Word64) -> Map PoolId (Quantity "block" Word64) -> Map PoolId Double -> Either ErrMetricsInconsistency (Map PoolId (Quantity "lovelace" Word64, Quantity "block" Word64, Double))

-- | Given a mapping from <a>PoolId</a> -&gt; <a>PoolOwner</a> and a
--   mapping between <a>PoolOwner</a> <a>-</a> <a>StakePoolMetadata</a>,
--   return a matching <tt>StakePoolMeta</tt> entry for every
--   <a>PoolId</a>.
--   
--   If there is no metadata for a pool, it returns Nothing for that
--   <a>PoolId</a>. If there is different metadata submitted by multiple
--   owners of a pool, it returns Nothing. If there is one unique metadata
--   for a pool, it returns <a>Just</a> the metadata for that
--   <a>PoolId</a>.
--   
--   It also provides a log message for each association.
associateMetadata :: [(PoolId, [PoolOwner])] -> [(PoolOwner, Maybe StakePoolMetadata)] -> [(StakePoolLog, Maybe StakePoolMetadata)]

-- | Messages associated with stake pool layer.
data StakePoolLog
MsgRegistry :: RegistryLog -> StakePoolLog
MsgListStakePoolsBegin :: StakePoolLog
MsgMetadataUnavailable :: StakePoolLog
MsgMetadataUsing :: PoolId -> PoolOwner -> StakePoolMetadata -> StakePoolLog
MsgMetadataMissing :: PoolId -> StakePoolLog
MsgMetadataMultiple :: PoolId -> [(PoolOwner, StakePoolMetadata)] -> StakePoolLog
MsgComputedProgress :: BlockHeader -> BlockHeader -> StakePoolLog
MsgStartMonitoring :: [BlockHeader] -> StakePoolLog
MsgFollow :: FollowLog -> StakePoolLog
MsgStakeDistribution :: EpochNo -> StakePoolLog
MsgStakePoolRegistration :: PoolRegistrationCertificate -> StakePoolLog
MsgRollingBackTo :: SlotId -> StakePoolLog
MsgApplyError :: ErrMonitorStakePools -> StakePoolLog
MsgUsingRankingEpochConstants :: EpochConstants -> StakePoolLog
MsgUsingTotalStakeForRanking :: Quantity "lovelace" Word64 -> StakePoolLog
instance GHC.Classes.Eq Cardano.Pool.Metrics.StakePoolLog
instance GHC.Show.Show Cardano.Pool.Metrics.StakePoolLog
instance GHC.Show.Show Cardano.Pool.Metrics.ErrListStakePools
instance GHC.Classes.Eq Cardano.Pool.Metrics.ErrMetricsInconsistency
instance GHC.Show.Show Cardano.Pool.Metrics.ErrMetricsInconsistency
instance GHC.Classes.Eq Cardano.Pool.Metrics.ErrMonitorStakePools
instance GHC.Show.Show Cardano.Pool.Metrics.ErrMonitorStakePools
instance GHC.Generics.Generic Cardano.Pool.Metrics.StakePool
instance GHC.Show.Show Cardano.Pool.Metrics.StakePool
instance GHC.Generics.Generic Cardano.Pool.Metrics.Block
instance GHC.Show.Show Cardano.Pool.Metrics.Block
instance GHC.Classes.Eq Cardano.Pool.Metrics.Block
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Cardano.Pool.Metrics.StakePoolLog
instance Cardano.BM.Data.Tracer.DefineSeverity Cardano.Pool.Metrics.StakePoolLog
instance Data.Text.Class.ToText Cardano.Pool.Metrics.StakePoolLog


-- | This module provides the Ntp client related settings, types and
--   re-exports used in a number of places throught codebase.
module Network.Ntp
ntpSettings :: NtpSettings
getNtpStatus :: NtpClient -> IO ApiNetworkClock
withNtpClient :: () => Tracer IO NtpTrace -> NtpSettings -> (NtpClient -> IO a) -> IO a
data NtpTrace
NtpTraceStartNtpClient :: NtpTrace
NtpTraceTriggerUpdate :: NtpTrace
NtpTraceRestartDelay :: !Int -> NtpTrace
NtpTraceRestartingClient :: NtpTrace
NtpTraceClientSleeping :: NtpTrace
NtpTraceIOError :: !IOError -> NtpTrace
NtpTraceLookupServerFailed :: !String -> NtpTrace
NtpTraceClientStartQuery :: NtpTrace
NtpTraceNoLocalAddr :: NtpTrace
NtpTraceIPv4IPv6NoReplies :: NtpTrace
NtpTraceReportPolicyQueryFailed :: NtpTrace
NtpTraceQueryResult :: !Microsecond -> NtpTrace
NtpTraceRunProtocolError :: !IPVersion -> !IOError -> NtpTrace
NtpTraceRunProtocolNoResult :: !IPVersion -> NtpTrace
NtpTraceRunProtocolSuccess :: !IPVersion -> NtpTrace
NtpTraceSocketOpen :: !IPVersion -> NtpTrace
NtpTraceSocketClosed :: !IPVersion -> NtpTrace
NtpTracePacketSent :: !IPVersion -> NtpTrace
NtpTracePacketSentError :: !IPVersion -> !IOError -> NtpTrace
NtpTracePacketDecodeError :: !IPVersion -> !String -> NtpTrace
NtpTracePacketReceived :: !IPVersion -> NtpTrace
NtpTraceWaitingForRepliesTimeout :: !IPVersion -> NtpTrace
data NtpClient
NtpClient :: STM NtpStatus -> IO NtpStatus -> Async Void -> NtpClient
[ntpGetStatus] :: NtpClient -> STM NtpStatus
[ntpQueryBlocking] :: NtpClient -> IO NtpStatus
[ntpThread] :: NtpClient -> Async Void
instance Data.Text.Class.ToText Network.NTP.Trace.IPVersion
instance Data.Text.Class.ToText Network.NTP.Trace.NtpTrace
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Network.NTP.Trace.NtpTrace
instance Cardano.BM.Data.Tracer.DefineSeverity Network.NTP.Trace.NtpTrace

module Network.Wai.Middleware.Logging

-- | Installs a request &amp; response logger on a Wai application.
--   
--   The logger logs requests' and responses' bodies along with a few other
--   useful piece of information.
withApiLogger :: Tracer IO ApiLog -> ApiLoggerSettings -> Middleware

-- | Create a new opaque <a>ApiLoggerSettings</a>
newApiLoggerSettings :: IO ApiLoggerSettings

-- | API logger settings
data ApiLoggerSettings

-- | Define a set of top-level object keys that should be obfuscated for a
--   given request in a JSON format.
obfuscateKeys :: (Request -> [Text]) -> ApiLoggerSettings -> ApiLoggerSettings

-- | Tracer events related to the handling of a single request.
data HandlerLog
LogRequestStart :: HandlerLog
LogRequest :: Request -> HandlerLog

-- | Request content, with list of sensitive json keys.
LogRequestBody :: [Text] -> ByteString -> HandlerLog
LogResponse :: NominalDiffTime -> Maybe Status -> HandlerLog
LogResponseBody :: ByteString -> HandlerLog
LogRequestFinish :: HandlerLog

-- | API handler trace events are associated with a unique request ID.
data ApiLog
ApiLog :: RequestId -> HandlerLog -> ApiLog

-- | Unique integer associated with the request, for the purpose of
--   tracing.
[requestId] :: ApiLog -> RequestId

-- | Event trace for the handler.
[logMsg] :: ApiLog -> HandlerLog

-- | Just a wrapper for readability
newtype RequestId
RequestId :: Integer -> RequestId
instance GHC.Show.Show Network.Wai.Middleware.Logging.ApiLog
instance GHC.Generics.Generic Network.Wai.Middleware.Logging.ApiLog
instance GHC.Show.Show Network.Wai.Middleware.Logging.HandlerLog
instance GHC.Generics.Generic Network.Wai.Middleware.Logging.HandlerLog
instance GHC.Classes.Eq Network.Wai.Middleware.Logging.RequestId
instance GHC.Show.Show Network.Wai.Middleware.Logging.RequestId
instance GHC.Generics.Generic Network.Wai.Middleware.Logging.RequestId
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Network.Wai.Middleware.Logging.ApiLog
instance Cardano.BM.Data.Tracer.DefineSeverity Network.Wai.Middleware.Logging.ApiLog
instance Data.Text.Class.ToText Network.Wai.Middleware.Logging.ApiLog
instance Data.Text.Class.ToText Network.Wai.Middleware.Logging.HandlerLog
instance Cardano.BM.Data.Tracer.DefinePrivacyAnnotation Network.Wai.Middleware.Logging.HandlerLog
instance Cardano.BM.Data.Tracer.DefineSeverity Network.Wai.Middleware.Logging.HandlerLog


-- | Middleware between Wai <a>-</a> Servant to accommodate raw error
--   responses returned by servant. See also <a>handleRawError</a>.
module Network.Wai.Middleware.ServerError

-- | Make sure every error is converted to a suitable application-level
--   error.
--   
--   There are many cases where Servant will handle errors itself and reply
--   to a client without even disturbing the application. This is both
--   handy and clunky since our application return errors in a specific
--   format (e.g. JSON, XML ...).
--   
--   This is the case for instance if the client hits a non-exiting
--   endpoint of the API, or if the client requests an invalid
--   content-type, etc ...
--   
--   Ideally, we would like clients to be able to expect one and only one
--   format, so this middleware allows for manipulating the response
--   returned by a Wai application (what servant boils down to) and adjust
--   the response when necessary. So, any response with or without payload
--   but no content-type will trigger the <tt>convert</tt> function and
--   offer the caller to adjust the response as needed.
handleRawError :: (Request -> ServerError -> ServerError) -> Middleware


-- | API handlers and server using the underlying wallet layer to provide
--   endpoints reachable through HTTP.
module Cardano.Wallet.Api.Server

-- | How the server should listen for incoming requests.
data Listen

-- | Listen on given TCP port
ListenOnPort :: Port -> Listen

-- | Listen on an unused TCP port, selected at random
ListenOnRandomPort :: Listen
data ListenError
ListenErrorAddressAlreadyInUse :: Maybe Port -> ListenError
ListenErrorOperationNotPermitted :: ListenError
ListenErrorHostDoesNotExist :: HostPreference -> ListenError
ListenErrorInvalidAddress :: HostPreference -> ListenError
data HostPreference

-- | Start the application server, using the given settings and a bound
--   socket.
start :: Settings -> Tracer IO ApiLog -> Socket -> Application -> IO ()
serve :: HasServer api ([] :: [Type]) => Proxy api -> Server api -> Application

-- | A Servant server for our wallet API
server :: forall t n byron icarus shelley. (byron ~ ApiLayer (RndState  'Mainnet) t ByronKey, icarus ~ ApiLayer (SeqState  'Mainnet IcarusKey) t IcarusKey, shelley ~ ApiLayer (SeqState n ShelleyKey) t ShelleyKey, DelegationAddress n ShelleyKey, Buildable (ErrValidateSelection t)) => byron -> icarus -> shelley -> StakePoolLayer IO -> NtpClient -> Server (Api n)

-- | A diminished servant server to serve Byron wallets only.
byronServer :: forall t n. (Buildable (ErrValidateSelection t), PaymentAddress n IcarusKey) => ApiLayer (RndState  'Mainnet) t ByronKey -> ApiLayer (SeqState  'Mainnet IcarusKey) t IcarusKey -> NtpClient -> Server (Api n)

-- | Create a new instance of the wallet layer.
newApiLayer :: forall ctx s t k. ctx ~ ApiLayer s t k => Tracer IO (WorkerLog WalletId WalletLog) -> (Block, BlockchainParameters, SyncTolerance) -> NetworkLayer IO t Block -> TransactionLayer t k -> DBFactory IO s k -> [WalletId] -> IO ctx

-- | Run an action with a TCP socket bound to a port specified by the
--   <a>Listen</a> parameter.
withListeningSocket :: HostPreference -> Listen -> (Either ListenError (Port, Socket) -> IO a) -> IO a

-- | Lift our wallet layer into servant <a>Handler</a>, by mapping each
--   error to a corresponding servant error.
class LiftHandler e
liftHandler :: LiftHandler e => ExceptT e IO a -> Handler a
handler :: LiftHandler e => e -> ServerError
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrRejectedTip
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrRejectedTip
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrCreateWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrCreateWallet
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrUnexpectedPoolIdPlaceholder
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrUnexpectedPoolIdPlaceholder
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrNoSuchEpoch
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrNoSuchEpoch
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ListenError
instance GHC.Show.Show Cardano.Wallet.Api.Server.ListenError
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.Listen
instance GHC.Show.Show Cardano.Wallet.Api.Server.Listen
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Api.Server.ErrRejectedTip
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Api.Server.ErrCreateWallet
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Api.Server.ErrUnexpectedPoolIdPlaceholder
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSelectForMigration
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.DB.ErrNoSuchWallet
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.DB.ErrWalletAlreadyExists
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrWithRootKey
instance Formatting.Buildable.Buildable e => Cardano.Wallet.Api.Server.LiftHandler (Cardano.Wallet.ErrSelectCoinsExternal e)
instance Formatting.Buildable.Buildable e => Cardano.Wallet.Api.Server.LiftHandler (Cardano.Wallet.Primitive.CoinSelection.ErrCoinSelection e)
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Primitive.Fee.ErrAdjustForFee
instance Formatting.Buildable.Buildable e => Cardano.Wallet.Api.Server.LiftHandler (Cardano.Wallet.ErrSelectForPayment e)
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrListUTxOStatistics
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Transaction.ErrMkTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSignPayment
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Transaction.ErrDecodeSignedTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSubmitExternalTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.DB.ErrRemovePendingTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Network.ErrPostTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSubmitTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Network.ErrNetworkUnavailable
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrUpdatePassphrase
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrListTransactions
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Network.ErrCurrentNodeTip
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Pool.Metrics.ErrListStakePools
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Pool.Metrics.ErrMetricsInconsistency
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSelectForDelegation
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSignDelegation
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrJoinStakePool
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrFetchRewards
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrQuitStakePool
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Api.Server.ErrNoSuchEpoch
instance Cardano.Wallet.Api.Server.LiftHandler (Network.Wai.Internal.Request, Servant.Server.Internal.ServerError.ServerError)


-- | Provides the package version and git revision which this was compiled
--   from.
--   
--   It is assumed that all cardano-wallet packages have the same version,
--   that of the core package.
--   
--   Stack builds will have the <tt>git</tt> command available to run
--   during compilation.
--   
--   Nix builds will inject the git revision into the executables after
--   compiling. If the git revision has changed but the sources have not,
--   then no haskell packages will be rebuilt, but the embedded git
--   revision will be updated.
module Cardano.Wallet.Version
version :: Version

-- | The Git revision ID (40 character hex string) of this build.
--   
--   This requires <tt>git</tt> do be available when building.
--   Alternatively, the git revision of the <tt>cardano-wallet</tt> binary
--   can be updated post-build using "Data.FileEmbed.injectWith".
gitRevision :: GitRevision
data GitRevision

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String

-- | Like <a>showVersion</a>, but also show the git revision.
showFullVersion :: Version -> GitRevision -> String
instance GHC.Classes.Eq Cardano.Wallet.Version.GitRevision
instance GHC.Show.Show Cardano.Wallet.Version.GitRevision
